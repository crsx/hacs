// CookPG: CRSX3 RULES FOR CONVERTING RAW(1) HACS FORMAT TO PG FORMAT.
//
CookPG[(

// Grammar for raw.
$CheckGrammar["org.crsx.hacs.Raw"];
$Use["org/crsx/hacs/Raw.crs"];

// Normalization and normalized structure (includes base library).
$Use["org/crsx/hacs/CookN.crs"];

// Insert options automatically.
$Lax;


/////////////////////////////////////////////////////////////////////
// TOP LEVEL

PG[RawModule] :: Text;
PG[%rawModule⟦ module #ModuleName# { #Declarations# } ⟧]
→
PG1[#ModuleName#, N-resolve[#Declarations#]]
;

PG1[$String, $List[RawDeclaration]] :: Text;
PG1[#Name#, #Declarations#]
→
PG2[{} N-Declarations[#Declarations#, #Name#], FullName[#Name#], ParsePrefix[#Name#], #Declarations#]
;


/////////////////////////////////////////////////////////////////////
// TEXT OF PG GRAMMAR.
//
// Main entry point for generating CRSX3 PG grammar specification for normalized HACS specification.
//
// Uses three passes:
// a. Generate text of names of exported productions.
// b. Generate text of productions.
// c. Generate text of lexical declarations.

PG2[NormalizedSortMap, $String<!--JavaModuleName-->, $String<!--ParsePrefix-->, $List[RawDeclaration]] :: Text ;
PG2[{#ND}NSM[#SortNames], #Name, #ParsePrefix, #Declarations]
→
PG3[{#ND}NSM[#SortNames], #Name, #ParsePrefix, #Declarations, {#ND} DerivedSorts[#SortNames]]
;

PG3[NormalizedSortMap, $String<!--JavaModuleName-->, $String<!--ParsePrefix-->, $List[RawDeclaration], $List[DERIVED_SORT]] :: Text ;
-[Data[#Name,#ParsePrefix,#Declarations,#Derived]]:
PG3[{#ND}NSM[#SortNames], #Name, #ParsePrefix, #Declarations, #Derived]
→
%n⟪/** PG Grammar for HACS module †« #Name ».
 * @version $Id: CookPG.crs,v 1.48 2014/01/26 21:14:39 krisrose Exp $
 */

class †«#Name»Parser : ⟦« TextFold[Map[s.%n⟨<†‹s›>⟩, {#ND}ProductionNames[{#ND}SortNameList]], %n⟨,⟩] »
//<META>
, <RawTerm>, <RawTerms>, <RawSortedTerm>, <RawConstruction>, <RawVariableUse>, <RawMetaApplication>, <RawScope>, <RawScopes>, <RawVariables>
« TextFold[Map[s.%n⟨, <Raw_†‹s›>, <RawSorted_†‹s›>, <RawPresorted_†‹s›>⟩, {#ND}SortNameList], %n⟨⟩] »
« TextFold[Map[s.%n⟨, <Raw_†‹s›>, <RawSorted_†‹s›>, <RawPresorted_†‹s›>⟩, {#ND}TokenNameList], %n⟨⟩] »
//</META>
« TextFold[Map[p.%n⟨, <†‹p›>⟩, NameSetList[Fold[x z.AddName[z, x], Map[d.TextToString[ProductionNameDerived[d]], #Derived], NoNames]]], %n⟨⟩] »⟧

prefix †«#ParsePrefix»

//<META>
declarations
%{
String unconcrete(String s) {return s.substring(1, s.length()-1).trim();}
String unmeta(String s, int skip) {return s.substring(1+skip, s.length()-1).trim();}
String rawornaked(String category) {return ((net.sf.crsx.generic.GenericFactory) factory).defined("raw") ? category : "" ;}
%}
//</META>

/* GRAMMAR. */
« {#ND; "$ParsePrefix" : #ParsePrefix} PG-Productions[#SortNames] »

//<META>
/* Raw term entry points.
 */
<RawTerms> (RAW) ::= {$Cons} <RawTerm> <RawTermsTail> | {$Nil} .
<RawTermsTail> (RAW) ::= {$Cons} RAW_COMMA <RawTerm> <RawTermsTail> | {$Nil} .
<RawTerm> (RAW) ::= <RawSortedTerm> | <RawConstruction> | <RawVariableUse> | <RawMetaApplication> | <RawUnparsed> .

<RawSortedTerm> (RAW) ::= « TextFold[Map[s.%n⟨<RawSorted_†‹s›>⟩, {#ND} SortNameList], %n⟨ | ⟩] » .

<RawConstruction> (RAW) ::= {RAW-Construction} (RAW_CONSTRUCTOR$) ( RAW_LPAREN <RawScopes>  RAW_RPAREN | {$Nil} ) <RawAttributes> .
<RawVariableUse> (RAW) ::= {RAW-VariableUse} (RAW_VARIABLE!!!) <RawAttributes> .
<RawMetaApplication> (RAW) ::= {RAW-MetaApplication} (RAW_META_VARIABLE$) ( RAW_LBRACKET <RawTerms>  RAW_RBRACKET | {$Nil} ) <RawAttributes> .
<RawUnparsed> (RAW) ::= {RAW-Unparsed} (RAW_CONCRETE$:unconcrete) <RawAttributes> .

<RawScopes> (RAW) ::= {$Cons} <RawScope> <RawScopesTail> | {$Nil} .
<RawScopesTail> (RAW) ::= {$Cons} RAW_COMMA <RawScope> <RawScopesTail> | {$Nil} .
<RawScope> (RAW) ::= {RAW-Scope} ( RAW_LBRACKET <RawVariables> RAW_RBRACKET | {$Nil} ) <RawTerm> .
<RawVariables> (RAW) ::= {$Cons} (RAW_VARIABLE$) ( RAW_COMMA <RawVariables> | {$Nil} ) .

<RawAttributes> (RAW) ::= {$Cons} <RawAttribute> <RawAttributes> | {$Nil} .
<RawAttribute> (RAW) ::=
  RAW_UP ( « TextFold[Map[a.%n⟨<RawAttributeSynthesized_†‹a›>⟩, NameSetList[{#ND}SynthesizedNames]], %n⟨ | ⟩] » )
| RAW_DOWN ( « TextFold[Map[a.%n⟨<RawAttributeInherited_†‹a›>⟩, NameSetList[{#ND}InheritedNames]], %n⟨ | ⟩] » ) .

« TextFoldMap[JoinMappedTextMaps[d.PG-ProduceDerived[d], #Derived], %n⟨
⟩] »
/* TOKENS. */

%{
TOKEN_MGR_DECLS : { int nesting; int nestedState;} /* Used by all nesting constructs. */
%}

« PG-Lexical[#Declarations] »

//<META>
/* Tokens for Raw mode. */
token RAW_VARIABLE (RAW) ::= [a-z] [A-Za-z0-9_$-]* .
token RAW_META_VARIABLE (RAW) ::= [#] [A-Za-z0-9_$-]* .
token RAW_CONSTRUCTOR (RAW) ::= [A-Z] [A-Za-z0-9_$-]* .
token RAW_LPAREN (RAW) ::= '(' .
token RAW_RPAREN (RAW) ::= ')' .
token RAW_LBRACKET (RAW) ::= '[' .
token RAW_RBRACKET (RAW) ::= ']' .
token RAW_LBRACE (RAW) ::= '{' .
token RAW_RBRACE (RAW) ::= '}' .
token RAW_COMMA (RAW) ::= ',' .
token RAW_COLON (RAW) ::= ':' .
token RAW_UP (RAW) ::= \u2191 . // ↑
token RAW_DOWN (RAW) ::= \u2193 . // ↓
token RAW_NOT (RAW) ::= \u00ac . // ¬
%{
/* Nested concrete token. */
<RAW> MORE : { "\u27e6" { nesting = 0; nestedState = curLexState; } : RAW_CONCRETE }
<RAW_CONCRETE> MORE : { "\u27e6" { nesting = 1; } : NESTED_RAW_CONCRETE }
<NESTED_RAW_CONCRETE> MORE : { "\u27e6" { nesting++; } }
<NESTED_RAW_CONCRETE> MORE : { "\u27e7" { if (--nesting <= 0) SwitchTo(RAW_CONCRETE); } }
<RAW_CONCRETE> TOKEN : { <T_RAW_CONCRETE : "\u27e7"> { SwitchTo(nestedState); } }
<RAW_CONCRETE,NESTED_RAW_CONCRETE> MORE : { < ~[] > }
%}
skip (RAW) ::= [\ \t\n] .
//</META>
⟫
;

// Only include productions for tokens and sorts that have syntax.

{$String<!--SortName--> : SortEntry} ProductionNames[$List[$String]] :: $List[$String];
{#ND}ProductionNames[()] → () ;
{#ND}ProductionNames[(#1;#s)] → {#ND}ProductionNames2[$[{#ND}Get[SortEntry],#1,SE_NONE], #1, #s] ;

{$String<!--SortName--> : SortEntry} ProductionNames2[SortEntry, $String, $List[$String]] :: $List[$String];
{#ND}ProductionNames2[SE_NONE, #1, #s] → {#ND}ProductionNames[#s] ;
{#ND}ProductionNames2[SE_TOKEN[#SortName], #1, #s] → (#1 ; {#ND}ProductionNames[#s]) ;
{#ND}ProductionNames2[SE_ATTRIBUTE[#Kind, #Name, #AttributeForm, #AttributeOptions], #1, #s] → {#ND}ProductionNames[#s] ;
{#ND}ProductionNames2[SE_SORT[#Defines, #SortName, #Precs, #Wrapper], #1, #s] → {#ND}ProductionNames3[#Defines, #1, #s] ;

{$String<!--SortName--> : SortEntry} ProductionNames3[$List[Define], $String, $List[$String]] :: $List[$String];
-[Fresh[dummy::RawSortParam]]:
{#ND} ProductionNames3[(D_ABSTRACTION[a.#Define1[a]]; #Defines), #1, #s] → {#ND} ProductionNames3[(#Define1[dummy]; #Defines), #1, #s] ;
{#ND} ProductionNames3[(D_RULE[#Rule, #RuleSort, #IsData]; #Defines), #1, #s] → {#ND} ProductionNames3[#Defines, #1, #s] ;
{#ND} ProductionNames3[(D_FORM[#Form1, #Kind1]; #Defines), #1, #s] → {#ND} ProductionNames4[#Form1, #Defines, #1, #s] ;
{#ND} ProductionNames3[(D_NONE; #Defines), #1, #s] → {#ND} ProductionNames3[#Defines, #1, #s] ;
{#ND} ProductionNames3[(), #1, #s] → {#ND}ProductionNames[#s] ;

{$String<!--SortName--> : SortEntry} ProductionNames4[RawForm, $List[Define], $String, $List[$String]] :: $List[$String];
{#ND} ProductionNames4[RAW-FormParsedSorted[#Sort1, #ParsedForm1, #Prec1, #InheritedRefs], #Defines, #1, #s] → (#1; {#ND}ProductionNames[#s]) ;
{#ND} ProductionNames4[RAW-FormParsed[#ParsedForm1, #Prec1, #InheritedRefs], #Defines, #1, #s] → (#1; {#ND}ProductionNames[#s]) ;
{#ND} ProductionNames4[RAW-FormConstruction[#Constructor, #ScopeSortList, #InheritedRefs], #Defines, #1, #s] → {#ND} ProductionNames3[#Defines, #1, #s] ;


/////////////////////////////////////////////////////////////////////
// TEXT OF ALL PRODUCTIONS.
//
// Productions are extracted by sort and for each sort grouped by precedence,
// each group producing a PG production.

{$String<!--SortName--> : SortEntry} PG-Productions[NameSet] :: Text;
{#ND} PG-Productions[#SortNames] → {#ND} PG-Productions1[HasNames[#SortNames], #SortNames] ;

{$String<!--SortName--> : SortEntry} PG-Productions1[Boolean, NameSet] :: Text;
{#ND} PG-Productions1[B_TRUE , #SortNames] → %n⟪« {#ND} PG-Production[FirstName[#SortNames]] »« {#ND} PG-Productions[RemoveFirstName[#SortNames]] »⟫ ;
{#ND} PG-Productions1[B_FALSE, #SortNames] → %n⟪⟫ ;

{$String<!--SortName--> : SortEntry} PG-Production[$String] :: Text;
-[Data[#SortName]]:
{#ND} PG-Production[#SortName] 
→
{#ND} PG-Production1[$[{#ND}Get, #SortName, SE_NONE]]
;

{$String<!--SortName--> : SortEntry} PG-Production1[SortEntry] :: Text;

{#ND} PG-Production1[SE_NONE]
→
%n⟪⟫
;

{#ND; "$ParsePrefix" : #ParsePrefix}
PG-Production1[SE_TOKEN[#SortName]]
→
%n⟪
/* Productions for †«#SortName» token. */
<«ProductionName[#SortName]»> ::= « {#ND}PG-MetaHead[B_TRUE, #SortName, #SortName, B_FALSE, 0] »«TokenName[#SortName]»$ .
« {#ND}PG-MetaTail[B_TRUE, #SortName, #SortName] »

//<META>
/* Raw terms of †«#SortName» token sort. */
<Raw_†«#SortName»> (RAW) ::= (RAW_TOKEN_†«#SortName»)?  <RawPresorted_†«#SortName»> .
<RawSorted_†«#SortName»> (RAW) ::= RAW_TOKEN_†«#SortName» <RawPresorted_†«#SortName»> .
<RawPresorted_†«#SortName»> (RAW) ::=
  {RAW-VariableUseSorted} ({†«#SortName»}) ({RAW-RepeatSingle}) (RAW_VARIABLE!!!) <RawAttributes>
| {RAW-MetaApplicationSorted} ({†«#SortName»}) ({RAW-RepeatSingle}) (RAW_META_VARIABLE$) ( RAW_LBRACKET <RawTerms>  RAW_RBRACKET | {$Nil} ) <RawAttributes>
| {RAW-UnparsedSorted} ({†«#SortName»}) ({RAW-RepeatSingle}) (RAW_CONCRETE$:unconcrete) <RawAttributes>
.
token RAW_TOKEN_†«#SortName» (RAW) ::= "†«#SortName»" .
//</META>
⟫
;

{#ND} PG-Production1[SE_ATTRIBUTE[#Kind, #Name, #AttributeForm, #AttributeOptions]]
→
PG-Production-Attribute[#Kind, #Name, #AttributeForm, #AttributeOptions]
;

{#ND} PG-Production1[SE_SORT[#Defines, #SortName, #Precs, #Wrapper]]
→
%n⟪« {#ND} PG-Production-Defines[#Defines, #SortName, 0, ()] »« {#ND} PG-Production-RawDefines[#Defines, #SortName] »⟫
;

// Handle an attribute definition.

PG-Production-Attribute[RawAttributeKind, $String, RawAttributeForm, $List[RawAttributeOption]] :: Text;
PG-Production-Attribute[#Kind, #Name, #AttributeForm, #AttributeOptions]
→
%n⟪
//<META>
<RawAttribute« AttributeKindCategory[#Kind] »_†«#Name»> (RAW) ::= {RAW-Attribute} « AttributeKindIndicator[#Kind] » (RAW_TOKEN_†«#Name»$) « AttributeFormSyntax[#AttributeForm, #AttributeOptions] » .
token RAW_TOKEN_†«#Name» (RAW) ::= "†«#Name»" . 
//</META>
⟫
;

AttributeKindCategory[RawAttributeKind] :: Text ;
AttributeKindCategory[%rawAttributeKind⟪ ↑ ⟫] → %n⟪Synthesized⟫ ;
AttributeKindCategory[%rawAttributeKind⟪ ↓ ⟫] → %n⟪Inherited⟫ ;

AttributeKindIndicator[RawAttributeKind] :: Text ;
AttributeKindIndicator[%rawAttributeKind⟪ ↑ ⟫] → %n⟪({RAW-AttributeKindUp})⟫ ;
AttributeKindIndicator[%rawAttributeKind⟪ ↓ ⟫] → %n⟪({RAW-AttributeKindDown})⟫ ;

AttributeFormSyntax[RawAttributeForm, $List[RawAttributeOption]] :: Text ;
AttributeFormSyntax[%rawAttributeForm⟪ ( #Sort# ) ⟫, #AttributeOptions] → %n⟪RAW_LPAREN {RAW-AttributeValue} <Raw_†« SortName[#Sort#] »> RAW_RPAREN⟫ ;
AttributeFormSyntax[%rawAttributeForm⟪ { #Sort# } ⟫, #AttributeOptions] → %n⟪RAW_LBRACE {RAW-AttributeKey} <Raw_†« SortName[#Sort#] »> RAW_RBRACE⟫ ;
AttributeFormSyntax[%rawAttributeForm⟪ { #Sort1# : #Sort2# } ⟫, #AttributeOptions] → %n⟪RAW_LBRACE {RAW-AttributeKeyValue} <Raw_†« SortName[#Sort1#] »> RAW_COLON <Raw_†« SortName[#Sort2#] »> RAW_RBRACE⟫ ;

AttributeKindToken[RawAttributeKind] :: Text ;
AttributeKindToken[%rawAttributeKind⟪ ↑ ⟫] → %n⟪RAW_UP⟫ ;
AttributeKindToken[%rawAttributeKind⟪ ↓ ⟫] → %n⟪RAW_DOWN⟫ ;

// Handle a sort definition.

{$String<!--SortName--> : SortEntry} PG-Production-Defines[$List[Define], $String, $Numeric, $List[PFK_SORT]] :: Text;

// Helper for ParsedForm and FK.
PFK_SORT ::=( PFK[RawParsedForm, FormKind]; );

{#ND} PG-Production-Defines[(), #SortName, #Prec, ()]
→
%n⟪⟫
;

{#ND} PG-Production-Defines[(), #SortName, #Prec, (#PFK1;#PFKs)]
→
%n⟪
/* Productions for †«#SortName» sort with (highest) precedence †«$[FormatNumber,#Prec]». */
« {#ND} PG-Expand[(#PFK1;#PFKs), #SortName, #Prec, B_TRUE] »⟫
;

-[Fresh[dummy::RawSortParam]]:
{#ND} PG-Production-Defines[(D_ABSTRACTION[a.#Define1[a]]; #Defines), #SortName, #Prec, #PrecPFKs]
→
{#ND} PG-Production-Defines[(#Define1[dummy]; #Defines), #SortName, #Prec, #PrecPFKs]
;

{#ND} PG-Production-Defines[(D_RULE[#Rule, #RuleSort, #IsData]; #Defines), #SortName, #Prec, #PrecPFKs]
→
{#ND} PG-Production-Defines[#Defines, #SortName, #Prec, #PrecPFKs]
;

{#ND} PG-Production-Defines[(D_FORM[#Form1, #Kind1]; #Defines), #SortName, #Prec, #PrecPFKs]
→
{#ND} PG-Production-Defines2[#Form1, #Kind1, #Defines, #SortName, #Prec, #PrecPFKs]
;

{#ND} PG-Production-Defines[(D_SYNTHESIZES[#AttributeName1]; #Defines), #SortName, #Prec, #PrecPFKs]
→
{#ND} PG-Production-Defines[#Defines, #SortName, #Prec, #PrecPFKs]
;

{$String<!--SortName--> : SortEntry} PG-Production-Defines2[RawForm, FormKind, $List[Define], $String, $Numeric, $List[PFK_SORT]] :: Text;

{#ND} PG-Production-Defines2[RAW-FormParsedSorted[#Sort1, #ParsedForm1, #Prec1, #InheritedRefs], #Kind1, #Defines, #SortName, #Prec, #PrecPFKs]
→
{#ND} PG-Production-Defines3[#ParsedForm1, #Prec1, #Kind1, #Defines, #SortName, #Prec, #PrecPFKs]
;

{#ND} PG-Production-Defines2[RAW-FormParsed[#ParsedForm1, #Prec1, #InheritedRefs], #Kind1, #Defines, #SortName, #Prec, #PrecPFKs]
→
{#ND} PG-Production-Defines3[#ParsedForm1, #Prec1, #Kind1, #Defines, #SortName, #Prec, #PrecPFKs]
;

{#ND} PG-Production-Defines2[RAW-FormConstruction[#Constructor, #ScopeSortList, #InheritedRefs], #Kind1, #Defines, #SortName, #Prec, #PrecPFKs]
→
{#ND} PG-Production-Defines[#Defines, #SortName, #Prec, #PrecPFKs]
;

{$String<!--SortName--> : SortEntry} PG-Production-Defines3[RawParsedForm, $Numeric, FormKind, $List[Define], $String, $Numeric, $List[PFK_SORT]] :: Text;

-[Data[#Prec1,#Prec],Share[#ParsedForm1,#Kind1,#Defines]]:
{#ND} PG-Production-Defines3[#ParsedForm1, #Prec1, #Kind1, #Defines, #SortName, #Prec, ()]
→
$[If, $[NumericEqual,#Prec1,#Prec],
  {#ND} PG-Production-Defines[#Defines, #SortName, #Prec, (PFK[#ParsedForm1, #Kind1];)],
  %n⟪
<«ProductionNameWithPrec[#SortName,#Prec]»> ::= <«ProductionNameWithPrec[#SortName,#Prec1]»> .
« {#ND} PG-Production-Defines[#Defines, #SortName, #Prec1, (PFK[#ParsedForm1, #Kind1];)] »⟫]
;

-[Data[#Prec1,#Prec],Share[#ParsedForm1,#Kind1,#Defines,#PFK,#PFKs]]:
{#ND} PG-Production-Defines3[#ParsedForm1, #Prec1, #Kind1, #Defines, #SortName, #Prec, (#PFK;#PFKs)]
→
$[If, $[NumericEqual,#Prec1,#Prec],
  {#ND} PG-Production-Defines[#Defines, #SortName, #Prec, Append[(#PFK;#PFKs), (PFK[#ParsedForm1, #Kind1];)]],
  %n⟪/* Productions for †«#SortName» sort with precedence †«$[FormatNumber,#Prec]». */
« {#ND} PG-Expand[(#PFK;#PFKs), #SortName, #Prec, B_FALSE] »
« {#ND} PG-Production-Defines[#Defines, #SortName, #Prec1, (PFK[#ParsedForm1, #Kind1];)] »
⟫]
;

{$String<!--SortName--> : SortEntry} PG-Production-RawDefines[$List[Define], $String] :: Text;

{#ND; "$ParsePrefix" : #ParsePrefix}
PG-Production-RawDefines[#Defines, #SortName]
→
%n⟪
//<META>
/* Raw terms of †«#SortName» production sort. */
<Raw_†«#SortName»> (RAW) ::= (RAW_TOKEN_†«#SortName»)?  <RawPresorted_†«#SortName»> .
<RawSorted_†«#SortName»> (RAW) ::= RAW_TOKEN_†«#SortName» <RawPresorted_†«#SortName»> .
<RawPresorted_†«#SortName»> (RAW) ::=
  {RAW-VariableUseSorted} ({†«#SortName»}) ({RAW-RepeatSingle}) (RAW_VARIABLE!!!) <RawAttributes>
| {RAW-MetaApplicationSorted} ({†«#SortName»}) ({RAW-RepeatSingle}) (RAW_META_VARIABLE$) ( RAW_LBRACKET <RawTerms> RAW_RBRACKET | {$Nil} ) <RawAttributes>
| {RAW-ConstructionSorted} ({†«#SortName»}) ({RAW-RepeatSingle}) (RAW_CONSTRUCTOR$) ( RAW_LBRACKET <RawScopes> RAW_RBRACKET | RAW_LPAREN <RawTerms> RAW_RPAREN | {$Nil} ) <RawAttributes>
| {RAW-UnparsedSorted} ({†«#SortName»}) ({RAW-RepeatSingle}) (RAW_CONCRETE$:unconcrete) <RawAttributes>
« {#ND} PG-Production-RawDefines1[#Defines, #SortName] »
.
token RAW_TOKEN_†«#SortName» (RAW) ::= "†«#SortName»" .
« {#ND} PG-Production-RawDefinesTokens[#Defines, #SortName] »
//</META>

⟫;

{$String<!--SortName--> : SortEntry} PG-Production-RawDefines1[$List[Define], $String] :: Text;

-[Fresh[dummy::RawSortParam]]:
{#ND} PG-Production-RawDefines1[(D_ABSTRACTION[a.#Define1[a]]; #Defines), #SortName]
→
{#ND} PG-Production-RawDefines1[(#Define1[dummy]; #Defines), #SortName]
;

{#ND} PG-Production-RawDefines1[(D_RULE[#Rule, #RuleSort, #IsData]; #Defines), #SortName]
→
{#ND} PG-Production-RawDefines1[#Defines, #SortName]
;

{#ND} PG-Production-RawDefines1[(D_FORM[#Form1, #Kind1]; #Defines), #SortName]
→
%n⟪« {#ND} PG-Production-RawForm[#Form1, #Kind1, #SortName] »« {#ND} PG-Production-RawDefines1[#Defines, #SortName] »⟫
;

{#ND} PG-Production-RawDefines1[(D_SYNTHESIZES[#AttributeName1]; #Defines), #SortName]
→
{#ND} PG-Production-RawDefines1[#Defines, #SortName]
;

{#ND} PG-Production-RawDefines1[(), #SortName]
→
%n⟪⟫
;

{$String<!--SortName--> : SortEntry} PG-Production-RawForm[RawForm, FormKind, $String] :: Text;

{#ND} PG-Production-RawForm[RAW-FormParsedSorted[#Sort1, #ParsedForm1, #Prec1, #InheritedRefs], #Kind1, #SortName]
→
%n⟪⟫
;

{#ND} PG-Production-RawForm[RAW-FormParsed[#ParsedForm1, #Prec1, #InheritedRefs], #Kind1, #SortName]
→
%n⟪⟫
;

{#ND} PG-Production-RawForm[RAW-FormConstruction[#Constructor, #ScopeSortList, #InheritedRefs], #Kind1, #SortName]
→
%n⟪| RAW_TOKEN_†«#Constructor»$ « IfEmpty[#ScopeSortList, %n⟨( RAW_LPAREN RAW_RPAREN )? ⟩, %n⟨ RAW_LPAREN ‹ {#ND} PG-Production-RawScopeSortList[#ScopeSortList, #SortName, B_TRUE] › RAW_RPAREN ⟩] »
⟫;

{$String<!--SortName--> : SortEntry} PG-Production-RawScopeSortList[$List[RawScopeSort], $String, Boolean] :: Text;

{#ND} PG-Production-RawScopeSortList[(%rawScopeSort⟪ #Sort# #Repeat# [ #SubstituteSorts# ] ⟫ ; #ScopeSortList), #SortName, #first]
→
%n⟪« If[#first, %n⟨⟩, %n⟨ RAW_COMMA ⟩] »« {#ND} PG-Production-RawScopeSort[#Sort#, #SubstituteSorts#, #SortName] »« {#ND} PG-Production-RawScopeSortList[#ScopeSortList, #SortName, B_FALSE] »⟫
;  //note: ignores #Repeat because arguments to Raw terms cannot use repeat-forms...or should they?

-[Free[v::Text]]:
{#ND} PG-Production-RawScopeSortList[(%rawBindersScopeSort⟪ [ v : #Sort# ] #BindersScopeSort# ⟫ ; #ScopeSortList), #SortName, #first]
→
{#ND} PG-Production-RawScopeSortList[(#BindersScopeSort# ; #ScopeSortList), #SortName, #first]
;

-[Free[v::Text]]:
{#ND} PG-Production-RawScopeSortList[(%rawScopeSort⟪ [ v : #Sort# ] ⟫ ; #ScopeSortList), #SortName, #first]
→
$[Error, "There should not be binder subterm sorts."]
;

{#ND} PG-Production-RawScopeSortList[(), #SortName, #first] → %n⟪⟫ ;

{$String<!--SortName--> : SortEntry} PG-Production-RawScopeSort[RawSort, $List[RawSubstituteSort], $String] :: Text;

{#ND} PG-Production-RawScopeSort[#Sort#, #SubstituteSorts#, #SortName]
→
IfEmpty[#SubstituteSorts#,
  %n⟪<Raw_†«SortName[#Sort#]»>⟫,
  %n⟪« {#ND}PG-Production-RawScope[#SubstituteSorts#, %n⟨<Raw_†‹SortName[#Sort#]›>⟩, %n⟨⟩, %n⟨RAW_LBRACKET⟩, %n⟨[⟩] »⟫]  //start:[
;

{$String<!--SortName--> : SortEntry} PG-Production-RawScope[$List[RawSubstituteSort], Text, Text, Text, Text] :: Text;

-[Fresh[x::Text]]:
{#ND}PG-Production-RawScope[(#SubstituteSort ; #SubstituteSorts), #SortRef, #ScopedVars, #sep, #argsep]
→ 
%n⟪ «#sep» RAW_VARIABLE^«x» « {#ND}PG-Production-RawScope[#SubstituteSorts, #SortRef, %n⟨‹#ScopedVars›‹#argsep›‹x›⟩, %n⟨RAW_COMMA⟩, %n⟨¸⟩] »⟫
; 

{#ND}PG-Production-RawScope[(), #SortRef, #ScopedVars, #sep, #argsep] → %n⟪ RAW_RBRACKET « #SortRef »« #ScopedVars »]⟫ ;  //end:]

{$String<!--SortName--> : SortEntry} PG-Production-RawDefinesTokens[$List[Define], $String] :: Text;

-[Fresh[dummy::RawSortParam]]:
{#ND} PG-Production-RawDefinesTokens[(D_ABSTRACTION[a.#Define1[a]]; #Defines), #SortName]
→
{#ND} PG-Production-RawDefinesTokens[(#Define1[dummy]; #Defines), #SortName]
;

{#ND} PG-Production-RawDefinesTokens[(D_RULE[#Rule, #RuleSort, #IsData]; #Defines), #SortName]
→
{#ND} PG-Production-RawDefinesTokens[#Defines, #SortName]
;

{#ND} PG-Production-RawDefinesTokens[(D_FORM[#Form1, #Kind1]; #Defines), #SortName]
→
%n⟪« {#ND} PG-Production-RawFormToken[#Form1, #Kind1, #SortName] »« {#ND} PG-Production-RawDefinesTokens[#Defines, #SortName] »⟫
;

{#ND} PG-Production-RawDefinesTokens[(D_SYNTHESIZES[#AttributeName1]; #Defines), #SortName]
→
{#ND} PG-Production-RawDefinesTokens[#Defines, #SortName]
;

{#ND} PG-Production-RawDefinesTokens[(), #SortName]
→
%n⟪⟫
;

{$String<!--SortName--> : SortEntry} PG-Production-RawFormToken[RawForm, FormKind, $String] :: Text;
{#ND} PG-Production-RawFormToken[RAW-FormParsedSorted[#Sort1, #ParsedForm1, #Prec1, #InheritedRefs], #Kind1, #SortName] → %n⟪⟫ ;
{#ND} PG-Production-RawFormToken[RAW-FormParsed[#ParsedForm1, #Prec1, #InheritedRefs], #Kind1, #SortName] → %n⟪⟫ ;
{#ND} PG-Production-RawFormToken[RAW-FormConstruction[#Constructor, #ScopeSortList, #InheritedRefs], #Kind1, #SortName] → %n⟪token RAW_TOKEN_†«#Constructor» (RAW) ::= "†«#Constructor»" .
⟫;


/////////////////////////////////////////////////////////////////////
// TEXT OF SINGLE SORT+PRECEDENCE PRODUCTION EXPANSION.
//
// Emits the left recursion handler, if any, and the PG grammar production
// for the sort+precedence combination, with left factored buffering.

CONSUMPTION_SORT ::=( C_BUFFER[$String<!--SortName-->, $Numeric<!--precedence-->]; C_LEFTRECURSIVE[$String<!--SortName-->, $Numeric<!--precedence-->]; <!--C_INLINE;--> );
/// C_INLINE DISABLED.

{$String<!--SortName--> : SortEntry} PG-Expand[$List[PFK_SORT], $String, $Numeric, Boolean] :: Text;
{#ND} PG-Expand[#PrecPFKs, #SortName, #Prec, #Last?]
→
{#ND} PG-LeftRecursive[#PrecPFKs, #SortName, #Prec, #Last?, (), ()]
;

// Generate optional left recursion production helper, normal production, and optional meta-production.

{$String<!--SortName--> : SortEntry} PG-LeftRecursive[$List[PFK_SORT], $String, $Numeric, Boolean, $List[PFK_SORT], $List[PFK_SORT]] :: Text;
{$String<!--SortName--> : SortEntry} PG-LeftRecursive2[Boolean, PFK_SORT, $List[PFK_SORT], $String, $Numeric, Boolean, $List[PFK_SORT], $List[PFK_SORT]] :: Text;

{#ND} PG-LeftRecursive[(#PFK1; #PFKs), #SortName, #Prec, #Last?, #LeftRecursivePFKs, #OtherPFKs]
→
{#ND} PG-LeftRecursive2[PG-isLeftRecursive[#SortName, #Prec, #PFK1], #PFK1, #PFKs, #SortName, #Prec, #Last?, #LeftRecursivePFKs, #OtherPFKs]
;

{#ND} PG-LeftRecursive2[B_TRUE, #PFK1, #PFKs, #SortName, #Prec, #Last?, #LeftRecursivePFKs, #OtherPFKs]
→
{#ND} PG-LeftRecursive[#PFKs, #SortName, #Prec, #Last?, Append[#LeftRecursivePFKs, (PG-stripLeftRecursion[#PFK1];)], #OtherPFKs]
;

{#ND} PG-LeftRecursive2[B_FALSE, #PFK1, #PFKs, #SortName, #Prec, #Last?, #LeftRecursivePFKs, #OtherPFKs]
→
{#ND} PG-LeftRecursive[#PFKs, #SortName, #Prec, #Last?, #LeftRecursivePFKs, Append[#OtherPFKs, (#PFK1;)]]
;

{#ND} PG-LeftRecursive[(), #SortName, #Prec, #Last?, #LeftRecursivePFKs, #OtherPFKs]
→
IfEmpty[#LeftRecursivePFKs,
  // There is no left recursion -- use the plain expansion.
  {#ND} PG-Produce[#SortName, #Prec, #Last?, #OtherPFKs, C_BUFFER[#SortName, #Prec]],
  // There is left recursion...
  {#ND} PG-ProduceBody[#LeftRecursivePFKs, 2, (%n⟨#1⟩;), (%n⟨LR⟩;), C_LEFTRECURSIVE[#SortName, #Prec], in after .
    %n⟪/* Handle left recursion. */
<«ProductionNameWithPrec[#SortName,#Prec]»LR #1> ::= ⟦«in»
| {{#1}}⟧
.
« TextFoldMap[after, %n⟨
⟩] »
« {#ND} PG-Produce[#SortName, #Prec, #Last?, #OtherPFKs, C_LEFTRECURSIVE[#SortName, #Prec]] »⟫]]
;

{$String<!--SortName--> : SortEntry} PG-Produce[$String, $Numeric, Boolean, $List[PFK_SORT], CONSUMPTION_SORT] :: Text;

{#ND} PG-Produce[#SortName, #Prec, #Last?, #PFKs, C_LEFTRECURSIVE[#SortName9, #Prec9]]
→
{#ND} PG-ProduceBody[#PFKs, 1, (), (), C_LEFTRECURSIVE[#SortName9, #Prec9], in after .
  %n⟪
<«ProductionNameWithPrec[#SortName,#Prec]»> ::= ⟦« {#ND}PG-MetaHead[#Last?, #SortName, #SortName, B_TRUE, #Prec] »«in»⟧ .
« {#ND}PG-MetaTail[#Last?, #SortName, #SortName] »« TextFoldMap[after, %n⟨
⟩] »⟫]
;

-[Data[#consumer]]:
{#ND} PG-Produce[#SortName, #Prec, #Last?, #PFKs, $[NotMatch,C_LEFTRECURSIVE[#_SortName, #_Prec],#consumer]]
→
{#ND} PG-ProduceBody[#PFKs, 1, (), (), #consumer, in after .
  %n⟪
<«ProductionNameWithPrec[#SortName,#Prec]»> ::= ⟦« {#ND}PG-MetaHead[#Last?, #SortName, #SortName, B_FALSE, #Prec] »«in» .⟧ 
« {#ND}PG-MetaTail[#Last?, #SortName, #SortName] »« TextFoldMap[after, %n⟨
⟩] »⟫]
;

///PG-MetaHead[#dontcare, #SortName, #Name, #isLeftRecursive, #Prec] → %n⟪⟫ ;
///PG-MetaTail[#dontcare, #SortName, #Name] → %n⟪⟫ ;

{$String<!--SortName--> : SortEntry} PG-MetaHead[Boolean, $String, $String, Boolean, $Numeric] :: Text;

PG-MetaHead[B_FALSE, #SortName, #Name, #isLeftRecursive, #Prec] → %n⟪⟫ ;

-[Data[#SortName],Discard[#Prec]]:
{#ND; "$ParsePrefix" : #ParsePrefix}
PG-MetaHead[B_TRUE, #SortName, #Name, B_FALSE, #Prec] →
 %n⟪
 //<META>
   meta1_«TokenName[#Name] »:unconcrete
| meta2_«TokenName[#Name] »$$:[[unmeta(#,†«$[FormatNumber,$[Length,#SortName]]»)]]:{ [[ rawornaked("†«#ParsePrefix»RawPresorted_†«#SortName»") ]] }
| 
//</META>
⟫ ;

-[Data[#SortName]]:
{#ND; "$ParsePrefix" : #ParsePrefix}
PG-MetaHead[B_TRUE, #SortName, #Name, B_TRUE, #Prec] →
 %n⟪
 //<META>
   meta1_«TokenName[#Name]»$:unconcrete:#1 <« ProductionNameWithPrec[#SortName, #Prec] »LR #1>
| meta2_«TokenName[#Name]»$$:[[unmeta(#,†«$[FormatNumber,$[Length,#SortName]]»)]]:{ [[ rawornaked("†«#ParsePrefix»RawPresorted_†«#SortName»") ]] }:#1 <« ProductionNameWithPrec[#SortName, #Prec] »LR #1>
| 
//</META>
⟫ ;

PG-MetaTail[Boolean, $String, $String] :: Text;

PG-MetaTail[B_FALSE, #SortName, #Name] → %n⟪⟫ ;

-[Data[#SortName]]: PG-MetaTail[B_TRUE, #SortName, #Name] → %n⟪
//<META>
%{
/* Meta token for †«#SortName». */ 
TOKEN : { < T_meta1_«TokenName[#Name]» : ("\u27e8" (" ")* †« Stringify[#SortName] » (" ")* "\u27e9") > }
MORE : { < "\u27e8" (" ")* †« Stringify[#SortName] » (" ")* ~["\u27e8","\u27e9"] > { nesting = 0; nestedState = curLexState; } : IN_META_«TokenName[#Name]» }
<IN_META_«TokenName[#Name]»> MORE : { "\u27e8" { nesting = 1; } : IN_NESTED_META_«TokenName[#Name]» }
<IN_NESTED_META_«TokenName[#Name]»> MORE : { "\u27e8" { nesting++; } }
<IN_NESTED_META_«TokenName[#Name]»> MORE : { "\u27e9" { if (--nesting <= 0) SwitchTo(IN_META_«TokenName[#Name]»); } }
<IN_META_«TokenName[#Name]»> TOKEN : { < T_meta2_«TokenName[#Name]» : "\u27e9" > { SwitchTo(nestedState); } }
<IN_META_«TokenName[#Name]»,IN_NESTED_META_«TokenName[#Name]»> MORE : { < ~[] > }
%}
//</META>
⟫ ;

{$String<!--SortName--> : SortEntry} PG-ProduceBody[$List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

-[Data[#PFKs]]:
{#ND} PG-ProduceBody[#PFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
→
{#ND} PG-ProduceBody1[#PFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
;

// Pick branching kind.

{$String<!--SortName--> : SortEntry} PG-ProduceBody1[$List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

{#ND} PG-ProduceBody1[(), #n, #terms, #words, #consumer, in after . #[in,after]]
→
#[%n⟪⟫, EmptyTextMap]
;

{#ND} PG-ProduceBody1[(PFK[RAW-ParsedFormWord[#word, #ParsedForm], #Kind]; #Rest), #n, #terms, #words, #consumer, in after . #[in,after]]
→
{#ND} PG-ProduceBodyWord1[#Rest, (), #word, (PFK[#ParsedForm, #Kind];), #n, #terms, #words, #consumer, in after . #[in,after]]
;

{#ND} PG-ProduceBody1[(PFK[RAW-ParsedFormTerm[RAW-ScopeSortPrecRepeat[#ScopeSort, #Prec, #Repeat], #ParsedForm], #Kind]; #Rest), #n, #terms, #words, #consumer, in after . #[in,after]]
→
{#ND} PG-ProduceBodyTerm1[#Rest, (), #ScopeSort, #Prec, #Repeat, #Kind, (PFK[#ParsedForm, #Kind];), #n, #terms, #words, #consumer, in after . #[in,after]]
;

{#ND} PG-ProduceBody1[(PFK[RAW-ParsedFormSpace[#space, #ParsedForm], #Kind]; #Rest), #n, #terms, #words, #consumer, in after . #[in,after]]
→
{#ND} PG-ProduceBody1[(PFK[#ParsedForm, #Kind]; #Rest), #n, #terms, #words, #consumer, in after . #[in,after]]
;

{#ND} PG-ProduceBody1[(PFK[RAW-ParsedFormDone, #Kind]; #Rest), #n, #terms, #words, C_BUFFER[#SortName, #Prec], in after . #[in,after]]
→
{#ND} PG-ProduceBody2[#Rest, #n, #terms, #words, C_BUFFER[#SortName, #Prec], in after . #[in,after],
  PG-AttributeCollection[#Kind, #SortName, #Prec, ProductionConstruction[#SortName, #Prec, #Kind, #words, #terms], B_FALSE],
  PG-AttributeProduction[#Kind, #SortName, #Prec, B_FALSE]]
;

{#ND} PG-ProduceBody1[(PFK[RAW-ParsedFormDone, #Kind]; #Rest), #n, #terms, #words, C_LEFTRECURSIVE[#SortName, #Prec], in after . #[in,after]]
→
{#ND} PG-ProduceBody2[#Rest, #n, #terms, #words, C_LEFTRECURSIVE[#SortName, #Prec], in after . #[in,after],
  PG-AttributeCollection[#Kind, #SortName, #Prec, ProductionConstruction[#SortName, #Prec, #Kind, #words, #terms], B_TRUE],
  PG-AttributeProduction[#Kind, #SortName, #Prec, B_TRUE]]
;

{$String<!--SortName--> : SortEntry} PG-ProduceBody2[$List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text, Text, TextMapSort] :: Text;
-[Data[#in2,#after2]]:
{#ND} PG-ProduceBody2[#Rest, #n, #terms, #words, #consumer, in after . #[in,after], #in2, #after2]
→
{#ND} PG-ProduceBody1[#Rest, #n, #terms, #words, #consumer, in after . #[%n⟪« #in2 »«in»⟫, JoinTextMaps[#after2, after]]]
;

PG-AttributeCollection[FormKind, $String, $Numeric, Text, Boolean] :: Text;

PG-AttributeCollection[#Kind, #SortName, #Prec, #Construct, B_FALSE] → #Construct ;
PG-AttributeCollection[#Kind, #SortName, #Prec, #Construct, B_TRUE] → %n⟪<«ProductionNameWithPrec[#SortName,#Prec]»LR «#Construct»>⟫ ;

PG-AttributeProduction[FormKind, $String, $Numeric, Boolean] :: TextMapSort;
PG-AttributeProduction[#dontcare, #SortName, #Prec, #IsLeftRecursive]
→
EmptyTextMap //TODO: eliminate?
;

ProductionConstruction[$String, $Numeric, FormKind, $List[Text], $List[Text]] :: Text;

-[Data[#SortName,#Prec],Data[#words]]:
ProductionConstruction[#SortName, #Prec, FK_SCHEME[#Inh], #words, #terms]
→
%n⟪⟦ {{ «ProductionNameWithPrec[#SortName, #Prec]»« IfEmpty[#words, %n⟨EMPTY⟩, TextFold1[#words, %n⟨_⟩]] »« WrappedTextFold[#terms, %n⟨[⟩, %n⟨, ⟩, %n⟨]⟩] »}}⟧⟫
;

-[Data[#SortName,#Prec,#Kind],Data[#words]]:
ProductionConstruction[#SortName, #Prec, $[NotMatch,FK_SCHEME[#Inh],#Kind], #words, #terms]
→
IfAliasKind[#Kind, WrappedTextFold[#terms, %n⟨ {{⟩, %n⟨ ⟩, %n⟨}}⟩],
  %n⟪⟦ {{«ProductionNameWithPrec[#SortName, #Prec]»« IfEmpty[#words, %n⟨EMPTY⟩, TextFold1[#words, %n⟨_⟩]] »« WrappedTextFold[#terms, %n⟨[⟩, %n⟨, ⟩, %n⟨]⟩] »}}⟧⟫]
;

∀ a . IfAliasKind[FormKind, a, a] :: a;
IfAliasKind[FK_ALIAS, #1, #2] → #1 ;
IfAliasKind[FK_SYMBOL[#IsStatic], #1, #2] → #1 ;
-[Data[#Kind]]: IfAliasKind[$[NotMatch,FK_ALIAS,$[NotMatch,FK_SYMBOL[#IsStatic],#Kind]], #1, #2] → #2 ;

// (1) Constant Token Case: (a) collect productions starting with the constant token and ...

{$String<!--SortName--> : SortEntry} PG-ProduceBodyWord1[$List[PFK_SORT], $List[PFK_SORT], $String, $List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

-[Data[#word1,#word],Share[#ParsedForm1,#Kind1,#Rest,#wordPFKs,#n,#terms,#words,#consumer]]:
{#ND} PG-ProduceBodyWord1[(PFK[RAW-ParsedFormWord[#word1, #ParsedForm1], #Kind1]; #Rest), #Failed, #word, #wordPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
→
$[If, $[Equal, #word, #word1],
  {#ND} PG-ProduceBodyWord1[#Rest, #Failed, #word, Append[#wordPFKs, (PFK[#ParsedForm1, #Kind1];)], #n, #terms, #words, #consumer, in after . #[in,after]],
  {#ND} PG-ProduceBodyWord1[#Rest, Append[#Failed, (PFK[RAW-ParsedFormWord[#word1, #ParsedForm1], #Kind1];)], #word, #wordPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]]
;

{#ND} PG-ProduceBodyWord1[(PFK[RAW-ParsedFormTerm[#ScopeSortPrecRepeat1, #ParsedForm1], #Kind]; #Rest), #Failed, #word, #wordPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
→
{#ND} PG-ProduceBodyWord1[#Rest, Append[#Failed, (PFK[RAW-ParsedFormTerm[#ScopeSortPrecRepeat1, #ParsedForm1], #Kind];)], #word, #wordPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
;

{#ND} PG-ProduceBodyWord1[(PFK[RAW-ParsedFormSpace[#space1, #ParsedForm1], #Kind1]; #Rest), #Failed, #word, #wordPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
→
{#ND} PG-ProduceBodyWord1[(PFK[#ParsedForm1, #Kind1]; #Rest), #Failed, #word, #wordPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
;

{#ND} PG-ProduceBodyWord1[(PFK[RAW-ParsedFormDone, #Kind]; #Rest), #Failed, #word, #wordPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
→
{#ND} PG-ProduceBodyWord1[#Rest, Append[#Failed, (PFK[RAW-ParsedFormDone, #Kind];)], #word, #wordPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
;

{#ND} PG-ProduceBodyWord1[(), #Failed, #word, #wordPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
→
{#ND} PG-ProduceBodyWord2[#Failed, #word, #wordPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
;

// ... (b) emit constant token branch.

{$String<!--SortName--> : SortEntry} PG-ProduceBodyWord2[$List[PFK_SORT], $String, $List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

{#ND} PG-ProduceBodyWord2[(), #word, #wordPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
→
{#ND} PG-ProduceBody[#wordPFKs, #n, #terms, Append[#words, (%n⟨†‹$[Mangle,#word]›⟩;)], #consumer, in1 after1 . #[%n⟪« ProductionWord[#word] »⟦« in1 »⟧⟫, after1]]
;

{#ND} PG-ProduceBodyWord2[(#PFK1;#PFKs), #word, #wordPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
→
{#ND} PG-ProduceBody[#wordPFKs, #n, #terms, Append[#words, (%n⟨†‹$[Mangle,#word]›⟩;)], #consumer, in1 after1 .
  {#ND} PG-ProduceBody[(#PFK1;#PFKs), #n, #terms, #words, #consumer, in2 after2 .
    #[%n⟪(« ProductionWord[#word] »« in1 »
| « in2 »)⟫, JoinTextMaps[after1, after2]]]]
;

ProductionWord[$String] :: Text;
ProductionWord[#word] → %n⟪†« Stringify[#word] »⟫ ;

// (2) Common Nonterminal: (a) collect productions starting with the nonterminal and...

{$String : SortEntry} PG-ProduceBodyTerm1[
	$List[PFK_SORT], $List[PFK_SORT], RawScopeSort, $Numeric, RawRepeat, FormKind, $List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

{#ND} PG-ProduceBodyTerm1[(PFK[RAW-ParsedFormWord[#word1, #ParsedForm1], #Kind1]; #Rest), #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
→
{#ND} PG-ProduceBodyTerm1[#Rest, Append[#Failed, (PFK[RAW-ParsedFormWord[#word1, #ParsedForm1], #Kind1];)], #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
;

{#ND} PG-ProduceBodyTerm1[(PFK[RAW-ParsedFormTerm[RAW-ScopeSortPrecRepeat[#ScopeSort1, #Prec1, #Repeat1], #ParsedForm1], #Kind1]; #Rest), #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
→
{#ND} PG-ProduceBodyTerm1x[SameScopeSort[#ScopeSort1, #Prec1, #Repeat1, #ScopeSort, #Prec, #Repeat], #ScopeSort1, #Prec1, #Repeat1, #ParsedForm1, #Kind1, #Rest, #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
;

{#ND} PG-ProduceBodyTerm1[(PFK[RAW-ParsedFormSpace[#space1, #ParsedForm1], #Kind1]; #Rest), #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
→
{#ND} PG-ProduceBodyTerm1[(PFK[#ParsedForm1, #Kind1]; #Rest), #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
;

{#ND} PG-ProduceBodyTerm1[(PFK[RAW-ParsedFormDone, #Kind1]; #Rest), #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
→
{#ND} PG-ProduceBodyTerm1[#Rest, Append[#Failed, (PFK[RAW-ParsedFormDone, #Kind1];)], #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
;

{#ND} PG-ProduceBodyTerm1[(), #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
→
{#ND} PG-ProduceBodyTerm2[#Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
;

// ... helper to filter identical scope sorts...

{$String : SortEntry} PG-ProduceBodyTerm1x[Boolean, RawScopeSort, $Numeric, RawRepeat, RawParsedForm, FormKind,
	$List[PFK_SORT], $List[PFK_SORT], RawScopeSort, $Numeric, RawRepeat, FormKind, $List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

{#ND} PG-ProduceBodyTerm1x[B_FALSE, #ScopeSort1, #Prec1, #Repeat1, #ParsedForm1, #Kind1, #Rest, #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
→
{#ND} PG-ProduceBodyTerm1[#Rest, Append[#Failed, (PFK[RAW-ParsedFormTerm[RAW-ScopeSortPrecRepeat[#ScopeSort1, #Prec1, #Repeat1], #ParsedForm1], #Kind1];)], #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
;

{#ND} PG-ProduceBodyTerm1x[B_TRUE, #ScopeSort1, #Prec1, #Repeat1, #ParsedForm1, #Kind1, #Rest, #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
→
{#ND} PG-ProduceBodyTerm1[#Rest, #Failed, #ScopeSort, #Prec, #Repeat, #Kind, Append[#nonterminalPFKs, (PFK[#ParsedForm1, #Kind1];)], #n, #terms, #words, #consumer, in after . #[in,after]]
;

// ... (b) emit branch (with recursive nesting of tail).

{$String : SortEntry} PG-ProduceBodyTerm2[$List[PFK_SORT], RawScopeSort, $Numeric, RawRepeat, FormKind, $List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

{#ND} PG-ProduceBodyTerm2[(), #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
→
{#ND} PG-ProduceBodyTerm3[#ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in after . #[in, after]]
;

{#ND} PG-ProduceBodyTerm2[(#PFK1;#PFKs), #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
→
{#ND} PG-ProduceBodyTerm3[#ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in1 after1 .
  {#ND} PG-ProduceBody[(#PFK1;#PFKs), #n, #terms, #words, #consumer, in2 after2 .
    #[%n⟪(« in1 »
| « in2 »)⟫, JoinTextMaps[after1, after2]]]]
;

{$String : SortEntry} PG-ProduceBodyTerm3[RawScopeSort, $Numeric, RawRepeat, FormKind, $List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

-[Free[v::Text]]:
{#ND} PG-ProduceBodyTerm3[%rawScopeSort⟪ [ v : #Sort# ] ⟫, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
→
IfSingletonRepeat[#Repeat,
  {#ND} PG-ProduceBody[#nonterminalPFKs, #n, #terms,  Append[#words, (%n⟨†‹SortVar[#Sort#]›⟩;)], #consumer, in after .
    #[%n⟪⟦ <«ProductionNameWithPrec[SortName[#Sort#], #Prec]»>^«v» ⟦« in »⟧ ⟧⟫, after]],
  CookError["Cannot use repeat specification on binder"]]
;

{#ND} PG-ProduceBodyTerm3[%rawScopeSort⟪ #Sort# #Repeat# [ #SubstituteSorts# ] ⟫, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
→
{#ND} PG-ProduceBodyTerm4[#Sort#, #SubstituteSorts#, ProductionNameWithPrecRepeat[SortName[#Sort#], #Prec, NestedRepeat[#Repeat#, #Repeat]], #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in after . #[in,after]]
;

{$String : SortEntry} PG-ProduceBodyTerm4[RawSort, $List[RawSubstituteSort], Text, $Numeric, RawRepeat, FormKind, $List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

-[Data[#consumer]]:
{#ND} PG-ProduceBodyTerm4[#Sort#, #SubstituteSorts#, #ProductionName, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, <!--$[NotMatch,C_INLINE,-->#consumer<!--]-->, in after . #[in,after]]
→
{#ND} PG-ProduceBody[#nonterminalPFKs, $[Plus,#n,1],
  Append[#terms, (%n⟨†‹ SortMetaVar[#Sort#, #n] ›⟩;)],
  Append[#words, (%n⟨†‹ SortName[#Sort#] ›⟩;)],
  #consumer,
  in after .
    #[%n⟪⟦ <« #ProductionName »>«
           WrappedTextFold[Map[s.ExtractSubstitutedSort[s], #SubstituteSorts#], %n⟨[⟩, %n⟨,⟩, %n⟨]⟩]
	     »« VariableMarker[#Kind, %n⟨:†‹ SortMetaVar[#Sort#, #n] ›⟩] » ⟦« in »⟧ ⟧⟫,after]]
;

// TODO: Eliminate redundant repeat productions!

ExtractSubstitutedSort[RawSubstituteSort] :: Text;
-[Free[v1::Text]]:
ExtractSubstitutedSort[%rawSubstituteSort⟪ v1 : #Sort2# ⟫] → %n⟪«v1»⟫ ;

VariableMarker[FormKind, Text] :: Text;
-[Data[#Kind]]: VariableMarker[#Kind, #Other] → VariableMarker2[#Kind, #Other] ;

VariableMarker2[FormKind, Text] :: Text;
VariableMarker2[FK_SYMBOL[$False], #Other] → %n⟪!!!« #Other »⟫ ;
VariableMarker2[FK_SYMBOL[$True], #Other] → %n⟪!!« #Other »⟫ ;
VariableMarker2[$[NotMatch,FK_SYMBOL[#IsStatic],#Kind], #Other] → #Other ;

// HAND-CODED HACK to recognize and strip left recursive production (because Raw.pg cannot match parsed forms...). 

PG-isLeftRecursive[$String, $Numeric, PFK_SORT] :: Boolean;

PG-isLeftRecursive[#SortName, #Prec, PFK[RAW-ParsedFormSpace[#Space, #ParsedForm1], #Kind]]
→
PG-isLeftRecursive[#SortName, #Prec, PFK[#ParsedForm1, #Kind]]
;

PG-isLeftRecursive[#SortName, #Prec, PFK[RAW-ParsedFormWord[#Word, #ParsedForm1], #Kind]]
→
B_FALSE
;

-[Data[#Sort]]:
PG-isLeftRecursive[#SortName, #Prec, PFK[RAW-ParsedFormTerm[RAW-ScopeSortPrecRepeat[#Sort1, #Prec1, #Repeat1], #ParsedForm1], #Kind]]
→
$[If, $[NumericEqual,#Prec,#Prec1], PG-isLeftRecursive1[#SortName, #Sort1], B_FALSE]
;

PG-isLeftRecursive[#SortName, #Prec, PFK[RAW-ParsedFormDone, #Kind]]
→
B_FALSE
;

PG-isLeftRecursive1[$String, RawScopeSort] :: Boolean;

PG-isLeftRecursive1[#SortName,
  RAW-ScopeSort[
    RAW-Sort[RAW-SortName[#SortName1, #_1], '$Nil'],
    RAW-RepeatSingle,
    '$Nil']]
→
SameString[#SortName,#SortName1]
;

-[Data[#Kind]]:
PG-isLeftRecursive1[#SortName, $[NotMatch,
  RAW-ScopeSort[
    RAW-Sort[RAW-SortName[#SortName1, #_1], '$Nil'],
    RAW-RepeatSingle,
    '$Nil'],#_]]
→
B_FALSE
;

PG-stripLeftRecursion[PFK_SORT] :: PFK_SORT;
PG-stripLeftRecursion[PFK[RAW-ParsedFormSpace[#Space, #ParsedForm1], #Kind]]
→
PG-stripLeftRecursion[PFK[#ParsedForm1, #Kind]]
;
PG-stripLeftRecursion[
  PFK[
    RAW-ParsedFormTerm[
      RAW-ScopeSortPrecRepeat[
        RAW-ScopeSort[
          RAW-Sort[RAW-SortName[#SortName, #_], '$Nil'],
          RAW-RepeatSingle,
          '$Nil'],
        #Prec,
        #Repeat],
	  #ParsedForm],
    #Kind]]
→
PFK[#ParsedForm, #Kind]
;

/////////////////////////////////////////////////////////////////////
// Test if two ScopeSorts are the same.

SameScopeSort[RawScopeSort, $Numeric, RawRepeat, RawScopeSort, $Numeric, RawRepeat] :: Boolean;
SameScopeSort[#Sort1, #Prec1, #Repeat1, #Sort2, #Prec2, #Repeat2] → SameScopeSort2[#Sort1, #Sort2, #Prec1, #Repeat1, #Prec2, #Repeat2] ;

SameScopeSort2[RawScopeSort, RawScopeSort, $Numeric, RawRepeat, $Numeric, RawRepeat] :: Boolean;

SameScopeSort2[%rawScopeSort⟪ #Sort1# [ #SubstituteSorts1# ] ⟫, %rawScopeSort⟪ #Sort2# [ #SubstituteSorts2# ] ⟫, #Prec1, #Repeat1, #Prec2, #Repeat2]
→
And[SameSort[#Sort1#, #Sort2#], And[SamePrec[#Prec1, #Prec2], SubRepeat[#Repeat1, #Repeat2]]]
;
-[Free[v1::Text]]:
SameScopeSort2[%rawScopeSort⟪ [ v1 : #Sort1# ] ⟫                   , %rawScopeSort⟪ #Sort2# [ #SubstituteSorts2# ] ⟫, #P1, #R1, #P2, #R2] → B_FALSE ;
-[Free[v2::Text]]:
SameScopeSort2[%rawScopeSort⟪ #Sort1# [ #SubstituteSorts1# ] ⟫, %rawScopeSort⟪ [ v2 : #Sort2# ] ⟫, #P1, #R1, #P2, #R2] → B_FALSE ;
-[Free[v1::Text,v2::Text]]:
SameScopeSort2[%rawScopeSort⟪ [ v1 : #Sort1# ] ⟫                   , %rawScopeSort⟪ [ v2 : #Sort2# ] ⟫, #P1, #R1, #P2, #R2] → SameSort[#Sort1#, #Sort2#] ;

SameSort[RawSort, RawSort] :: Boolean;
-[Data[#1,#2]]: SameSort[#1, #2] → SameSort2[#1, #2] ;

SameSort2[RawSort, RawSort] :: Boolean;

-[Data[#SortName1#,#SortName2#]]:
SameSort2[%rawSort⟪ #SortName1# #MetaVariables1# #SimpleSorts1# ⟫, %rawSort⟪ #SortName2# #MetaVariables2# #SimpleSorts2# ⟫]
→
$[If, $[Equal, #SortName1#, #SortName2#], B_TRUE, B_FALSE]
;

SameSort2[$[NotMatch,%rawSort⟪ #SortName1# #MetaVariables1# #SimpleSorts1# ⟫,#1], #2]
→
B_FALSE
;

SameSort2[#1,$[NotMatch,%rawSort⟪ #SortName2# #MetaVariables2# #SimpleSorts2# ⟫,#2]]
→
B_FALSE
;

SamePrec[$Numeric, $Numeric] :: Boolean;
-[Data[#Prec1,#Prec2]]: SamePrec[#Prec1, #Prec2] → $[If, $[NumericEqual, #Prec1, #Prec2], B_TRUE, B_FALSE] ;

SubRepeat[RawRepeat, RawRepeat] :: Boolean;

SubRepeat-single: SubRepeat[%rawRepeat⟪ ⟫, #Repeat2] → B_TRUE ;

SubRepeat-maybe-single: SubRepeat[%rawRepeat⟪ ? ⟫, %rawRepeat⟪ ⟫] → B_FALSE;
SubRepeat-maybe-maybe: SubRepeat[%rawRepeat⟪ ? ⟫, %rawRepeat⟪ ? ⟫] → B_TRUE;
SubRepeat-maybe-many: SubRepeat[%rawRepeat⟪ ? ⟫, %rawRepeat⟪ * ⟫] → B_TRUE;
SubRepeat-maybe-some: SubRepeat[%rawRepeat⟪ ? ⟫, %rawRepeat⟪ + ⟫] → B_FALSE;
SubRepeat-maybe-somesep: SubRepeat[%rawRepeat⟪ ? ⟫, %rawRepeat⟪ + _ #RegExpLeaf2# ⟫] → B_FALSE;

SubRepeat-some-single: SubRepeat[%rawRepeat⟪ + ⟫, %rawRepeat⟪ ⟫] → B_FALSE;
SubRepeat-some-maybe: SubRepeat[%rawRepeat⟪ + ⟫, %rawRepeat⟪ ? ⟫] → B_FALSE;
SubRepeat-some-many: SubRepeat[%rawRepeat⟪ + ⟫, %rawRepeat⟪ * ⟫] → B_TRUE;
SubRepeat-some-some: SubRepeat[%rawRepeat⟪ + ⟫, %rawRepeat⟪ + ⟫] → B_TRUE;
SubRepeat-some-somesep: SubRepeat[%rawRepeat⟪ + ⟫, %rawRepeat⟪ + _ #RegExpLeaf2# ⟫] → B_FALSE;

SubRepeat-many-many: SubRepeat[%rawRepeat⟪ * ⟫, %rawRepeat⟪ * ⟫] → B_TRUE ;
SubRepeat-many-other[Data[#_]]: SubRepeat[%rawRepeat⟪ * ⟫, $[NotMatch,%rawRepeat⟪ * ⟫,#_]] → B_FALSE;

SubRepeat-somesep-single: SubRepeat[%rawRepeat⟪ + _ #RegExpLeaf1# ⟫, %rawRepeat⟪ ⟫] → B_FALSE;
SubRepeat-somesep-maybe: SubRepeat[%rawRepeat⟪ + _ #RegExpLeaf1# ⟫, %rawRepeat⟪ ? ⟫] → B_FALSE;
SubRepeat-somesep-many: SubRepeat[%rawRepeat⟪ + _ #RegExpLeaf1# ⟫, %rawRepeat⟪ * ⟫] → B_FALSE;
SubRepeat-somesep-some: SubRepeat[%rawRepeat⟪ + _ #RegExpLeaf1# ⟫, %rawRepeat⟪ + ⟫] → B_FALSE;

SubRepeat-somesep-string-string: SubRepeat[%rawRepeat⟪ + _ #String1# ⟫, %rawRepeat⟪ + _ #String2# ⟫] → SameString[UnString[#String1#], UnString[#String2#]] ;
SubRepeat-somesep-string-word: SubRepeat[%rawRepeat⟪ + _ #String1# ⟫, %rawRepeat⟪ + _ #Word2# ⟫] → SameString[UnString[#String1#], #Word2#] ;
SubRepeat-somesep-word-string: SubRepeat[%rawRepeat⟪ + _ #Word1# ⟫, %rawRepeat⟪ + _ #String2# ⟫] → SameString[#Word1#, UnString[#String2#]] ;
SubRepeat-somesep-word-word: SubRepeat[%rawRepeat⟪ + _ #Word1# ⟫, %rawRepeat⟪ + _ #Word2# ⟫] → SameString[#Word1#, #Word2#] ;


/////////////////////////////////////////////////////////////////////
// TEXT LIST OF REPEAT-DERIVED DECLARATIONS.

PG-ProduceDerived[DERIVED_SORT] :: TextMapSort;
PG-ProduceDerived[DERIVED[#SortName, #Prec, #Repeat]] → PG-ProduceRepeat[#Repeat, #SortName, #Prec, ProductionNameWithPrecRepeat[#SortName, #Prec, #Repeat]] ; 

PG-ProduceRepeat[RawRepeat, $String, $Numeric, Text] :: TextMapSort;

PG-ProduceRepeat[%rawRepeat⟪ ⟫, #s, #p, #name] → EmptyTextMap ;

-[Data[#s]]:
PG-ProduceRepeat[%rawRepeat⟪ ? ⟫, #s, #p, #name]
→
SingletonTextMap[TextToString[#name], %n⟪
<«#name»> ::= «
  PG-MetaHead[B_TRUE, $[:,#s,"?"], TextToString[#name], B_FALSE, 0]
»( <«ProductionNameWithPrec[#s, #p]»>:#1 {{ $Cons[#1,$Nil] }} | {{ $Nil }} ).
« PG-MetaTail[B_TRUE, $[:,#s,"?"], TextToString[#name]] »⟫]
;

-[Data[#s]]:
PG-ProduceRepeat[%rawRepeat⟪ * ⟫, #s, #p, #name]
→
SingletonTextMap[TextToString[#name], %n⟪
<«#name»> ::= «
  PG-MetaHead[B_TRUE, $[:,#s,"*"], TextToString[#name], B_FALSE, 0]
»( <«ProductionNameWithPrec[#s, #p]»>:#1 <«#name»>:#2 {{ $Cons[#1,#2] }} | {{ $Nil }} ).
« PG-MetaTail[B_TRUE, $[:,#s,"*"], TextToString[#name]] »⟫]
;

-[Data[#s]]:
PG-ProduceRepeat[%rawRepeat⟪ + ⟫, #s, #p, #name]
→
SingletonTextMap[TextToString[#name], %n⟪
<«#name»> ::= «
  PG-MetaHead[B_TRUE, $[:,#s,"+"], TextToString[#name], B_FALSE, 0]
» <«ProductionNameWithPrec[#s, #p]»>:#1 ( <«#name»>:#2 {{ $Cons[#1,#2] }} | {{ $Cons[#1,$Nil] }} ) .
« PG-MetaTail[B_TRUE, $[:,#s,"+"], TextToString[#name]] »⟫]
;

-[Data[#s]]:
PG-ProduceRepeat[%rawRepeat⟪ + _ #RegExpLeaf# ⟫, #s, #p, #name]
→
SingletonTextMap[TextToString[#name], %n⟪
<«#name»> ::= «
  PG-MetaHead[B_TRUE, RegExpLeafSuffix[#RegExpLeaf#, $[:,#s,"+_"]], TextToString[#name], B_FALSE, 0]
» <«ProductionNameWithPrec[#s, #p]»>:#1 ( « PG-InlineRegExpSimple[#RegExpLeaf#, ""] » <«#name»>:#2 {{ $Cons[#1,#2] }} | {{ $Cons[#1,$Nil] }} ) .
« PG-MetaTail[B_TRUE, RegExpLeafSuffix[#RegExpLeaf#, $[:,#s,"+_"]], TextToString[#name]] »⟫]
;


/////////////////////////////////////////////////////////////////////
// TEXT LIST OF LEXICAL DECLARATIONS.

PG-Lexical[$List[RawDeclaration]] :: Text ;
PG-Lexical[#Declarations] → PG-Lexical2[#Declarations, B_FALSE, hasskip.PG-Lexical2Tail[hasskip]] ;

PG-Lexical2[$List[RawDeclaration], Boolean, ha::Boolean.Text] :: Text ;

Lexical-module:
PG-Lexical2[%rawDeclarations⟪ module #ModuleName2# { #Declarations2# } ; #Declarations# ⟫, #hasSkip, hasskip.#[hasskip]]
→
PG-Lexical2[#Declarations2#, #hasSkip, hasskip.PG-Lexical2[#Declarations#, hasskip, hasskip2.#[hasskip2]]]
;

Lexical-space:
PG-Lexical2[%rawDeclarations⟪ space #RegExp# ; #Declarations# ⟫, #hasSkip, hasskip.#[hasskip]]
→
%n⟪skip ::= ' ' | ⟦« PG-InlineRegExp[#RegExp#, "space$"] »⟧ .
« PG-DeclareRegExp[#RegExp#, "space$"] »« PG-Lexical2[#Declarations#, B_TRUE, hasskip.#[hasskip]] »⟫
;

Lexical-token:
PG-Lexical2[%rawDeclarations⟪ token #SortName# | #RegExp# ; #Declarations# ⟫, #hasSkip, hasskip.#[hasskip]]
→
%n⟪token «TokenName[#SortName#]» ::= ⟦« PG-InlineRegExp[#RegExp#, #SortName#] »⟧ .
« PG-DeclareRegExp[#RegExp#, #SortName#] »« PG-Lexical2[#Declarations#, #hasSkip, hasskip.#[hasskip]] »⟫
;

Lexical-fragment:
PG-Lexical2[%rawDeclarations⟪ fragment #FragmentName# | #RegExp# ; #Declarations# ⟫, #hasSkip, hasskip.#[hasskip]]
→
%n⟪token fragment «TokenName[#FragmentName#]» ::= ⟦« PG-InlineRegExp[#RegExp#, #FragmentName#] »⟧ . 
« PG-DeclareRegExp[#RegExp#, #FragmentName#] »« PG-Lexical2[#Declarations#, #hasSkip, hasskip.#[hasskip]] »⟫
;

Lexical-attribute:
PG-Lexical2[%rawDeclarations⟪ attribute #AttributeKind# #AttributeName# #AttributeForm# #AttributeOptions# ; #Declarations# ⟫, #hasSkip, hasskip.#[hasskip]]
→
PG-Lexical2[#Declarations#, #hasSkip, hasskip.#[hasskip]]
;

Lexical-sort:
PG-Lexical2[%rawDeclarations⟪ sort #SortName# #Repeat# #SortAbstraction# ; #Declarations# ⟫, #hasSkip, hasskip.#[hasskip]]
→
PG-Lexical2[#Declarations#, #hasSkip, hasskip.#[hasskip]]
;

Lexical-text:
PG-Lexical2[%rawDeclarations⟪ text #SortAlternatives# ; #Declarations# ⟫, #hasSkip, hasskip.#[hasskip]]
→
PG-Lexical2[#Declarations#, #hasSkip, hasskip.#[hasskip]]
;

Lexical-alternatives:
PG-Lexical2[%rawDeclarations⟪ #SortAlternatives# ; #Declarations# ⟫, #hasSkip, hasskip.#[hasskip]]
→
PG-Lexical2[#Declarations#, #hasSkip, hasskip.#[hasskip]]
;

Lexical-rule:
PG-Lexical2[%rawDeclarations⟪ rule #Rule# ; #Declarations# ⟫, #hasSkip, hasskip.#[hasskip]]
→
PG-Lexical2[#Declarations#, #hasSkip, hasskip.#[hasskip]]
;

Lexical-nest:
PG-Lexical2[%rawDeclarations⟪ { #Declarations2# } #Declarations# ⟫, #hasSkip, hasskip.#[hasskip]]
→
PG-Lexical2[#Declarations2#, #hasSkip, hasskip.PG-Lexical2[#Declarations#, hasskip, hasskip2.#[hasskip2]]]
;

Lexcial-done:
PG-Lexical2[%rawDeclarations⟪ ⟫, #hasSkip, hasskip.#[hasskip]]
→
#[#hasSkip]
;

PG-Lexical2Tail[Boolean] :: Text;
PG-Lexical2Tail[B_TRUE] → %n⟪⟫ ;
PG-Lexical2Tail[B_FALSE] → %n⟪skip ::= " " .
⟫ ;


/////////////////////////////////////////////////////////////////////
// INLINE TEXT OF REGULAR EXPRESSION.

PG-InlineRegExp[$List[RawRegExpChoice], $String<!--identifier-->] :: Text ;
PG-InlineRegExp[(#RegExpChoice; #RegExp), #id]
→
%n⟪⟦« PG-InlineRegExpChoice[#RegExpChoice, #id] »⟧ « PG-InlineRegExp2[#RegExp, #id] »⟫
;
PG-InlineRegExp2[$List[RawRegExpChoice], $String<!--identifier-->] :: Text ;
PG-InlineRegExp2[(#RegExpChoice; #RegExp), #id]
→
%n⟪| ⟦« PG-InlineRegExpChoice[#RegExpChoice, #id] »⟧ « PG-InlineRegExp2[#RegExp, #id] »⟫
;
PG-InlineRegExp2[(), #id]
→
%n⟪⟫
;

PG-InlineRegExpChoice[RawRegExpChoice, $String] :: Text;

PG-InlineRegExpChoice[%rawRegExpChoice⟪ nested #RegExpSimple1# #RegExpSimple2# ⟫, #id]
→
%n⟪NESTED_«TokenName[#id]»⟫
;
PG-InlineRegExpChoice[%rawRegExpChoice⟪ #RegExpUnits# ⟫, #id]
→
PG-InlineRegExpUnits[#RegExpUnits#, #id]
;

PG-InlineRegExpUnits[$List[RawRegExpUnit], $String] :: Text;

PG-InlineRegExpUnits[%rawRegExpUnits⟪ #RegExpUnit# #RegExpUnits# ⟫, #id]
→
%n⟪« PG-InlineRegExpUnit[#RegExpUnit#, #id] » « PG-InlineRegExpUnits[#RegExpUnits#, #id] »⟫
;
PG-InlineRegExpUnits[%rawRegExpUnits⟪ ⟫, #id]
→
%n⟪⟫
;

PG-InlineRegExpUnit[RawRegExpUnit, $String] :: Text;

PG-InlineRegExpUnit[%rawRegExpUnit⟪ #RegExpSimple# ⟫, #id]
→
PG-InlineRegExpSimple[#RegExpSimple#, #id]
;

PG-InlineRegExpUnit[%rawRegExpUnit⟪ #RegExpSimple# ? ⟫, #id]
→
%n⟪( « PG-InlineRegExpSimple[#RegExpSimple#, #id] » )?⟫
;

PG-InlineRegExpUnit[%rawRegExpUnit⟪ #RegExpSimple# * ⟫, #id]
→
%n⟪( « PG-InlineRegExpSimple[#RegExpSimple#, #id] » )*⟫
;

PG-InlineRegExpUnit[%rawRegExpUnit⟪ #RegExpSimple# + ⟫, #id]
→
%n⟪( « PG-InlineRegExpSimple[#RegExpSimple#, #id] » )+⟫
;

PG-InlineRegExpUnit[%rawRegExpUnit⟪ #RegExpSimple# + _ #RegExpLeaf# ⟫, #id]
→
%n⟪( « PG-InlineRegExpSimple[#RegExpSimple#, #id] » ( « PG-InlineRegExpSimple[#RegExpLeaf#, #id] » « PG-InlineRegExpSimple[#RegExpSimple#, #id] » )* )⟫
;

PG-InlineRegExpSimple[RawRegExpSimple, $String] :: Text;

PG-InlineRegExpSimple[%rawRegExpSimple⟪ #String# ⟫, #id]
→
%n⟪†«#String#»⟫ // TODO: manually process (here and above)!
;

PG-InlineRegExpSimple[%rawRegExpSimple⟪ #Word# ⟫, #id]
→
%n⟪†« Stringify[#Word#] »⟫ // TODO: manually process (here and above)!
;

PG-InlineRegExpSimple[%rawRegExpSimple⟪ #FragmentRef# ⟫, #id]
→
%n⟪«TokenName[#FragmentRef#]»⟫
;

PG-InlineRegExpSimple[%rawRegExpSimple⟪ . ⟫, #id]
→
PG-InlineRegExpSimple[%rawRegExpSimple⟪ [^\n\r\f] ⟫, #id]
;

PG-InlineRegExpSimple[%rawRegExpSimple⟪ #RegExpClass# ⟫, #id]
→
PG-InlineRegExpClass1[#RegExpClass#, #id]
;

PG-InlineRegExpSimple[%rawRegExpSimple⟪ ( #RegExp# ) ⟫, #id]
→
%n⟪( « PG-InlineRegExp[#RegExp#, #id] » )⟫
;

PG-InlineRegExpClass1[RawRegExpClass, $String] :: Text;

PG-InlineRegExpClass1[RAW-RegExpClassNot[#RegExpClass], #id]
→
%n⟪~[« PG-InlineRegExpClass2[#RegExpClass, #id, %n⟨⟩] »]⟫
;

PG-InlineRegExpClass1[$[NotMatch,RAW-RegExpClassNot[#_],#RegExpClass], #id]
→
%n⟪[« PG-InlineRegExpClass2[#RegExpClass, #id, %n⟨⟩] »]⟫
;

PG-InlineRegExpClass2[RawRegExpClass, $String, Text] :: Text;

PG-InlineRegExpClass2[RAW-RegExpClassChar[#Char, #RegExpClass], #id, #sep]
→
%n⟪«#sep»« PG-InlineRegExpRangeChar[#Char, #id] »« PG-InlineRegExpClass2[#RegExpClass, #id, %n⟨,⟩] »⟫
;

PG-InlineRegExpClass2[RAW-RegExpClassRange[#lo, #hi, #RegExpClass], #id, #sep]
→
%n⟪«#sep»« PG-InlineRegExpRangeChar[#lo, #id] »-« PG-InlineRegExpRangeChar[#hi, #id] »« PG-InlineRegExpClass2[#RegExpClass, #id, %n⟨,⟩] »⟫
;

PG-InlineRegExpClass2[RAW-RegExpClassDone, #id, #sep]
→
%n⟪⟫
;
PG-InlineRegExpRangeChar[$String, $String] :: Text;
-[Data[#RegExpRangeStartChar#]]:
PG-InlineRegExpRangeChar[#RegExpRangeStartChar#, #id]
→
$[If, $[Equal,#RegExpRangeStartChar#,"'"], %n⟪"'"⟫, %n⟪'†« #RegExpRangeStartChar# »'⟫]
;


/////////////////////////////////////////////////////////////////////
// RESIDUAL DECLARATIONS FROM REGULAR EXPRESSION.

PG-DeclareRegExp[$List[RawRegExpChoice], $String<!--identifier-->] :: Text ;
PG-DeclareRegExp[(#RegExpChoice; #RegExp), #id]
→
%n⟪« PG-DeclareRegExpChoice[#RegExpChoice, #id] »« PG-DeclareRegExp[#RegExp, #id] »⟫
;
PG-DeclareRegExp[(), #id]
→
%n⟪⟫
;

PG-DeclareRegExpChoice[RawRegExpChoice, $String] :: Text;
PG-DeclareRegExpChoice[%rawRegExpChoice⟪ nested #RegExpSimple1# #RegExpSimple2# ⟫, #id]
→
%n⟪
%{
/* token †«#id». */
MORE : { < « PG-InlineRegExpSimple[#RegExpSimple1#, #id] » > { nesting = 0; nestedState = curLexState; } : IN_«TokenName[#id]» }
<IN_«TokenName[#id]»> MORE : { < « PG-InlineRegExpSimple[#RegExpSimple1#, #id] » > { nesting = 1; } : IN_NESTED_«TokenName[#id]» }
<IN_NESTED_«TokenName[#id]»> MORE : { < « PG-InlineRegExpSimple[#RegExpSimple1#, #id] » > { nesting++; } }
<IN_NESTED_«TokenName[#id]»> MORE : { < « PG-InlineRegExpSimple[#RegExpSimple2#, #id] » > { if (--nesting <= 0) SwitchTo(IN_«TokenName[#id]»); } }
<IN_«TokenName[#id]»> †« $[If,$[Equal,#id,"space$"],"SKIP","TOKEN"] » : { < T_NESTED_«TokenName[#id]» : « PG-InlineRegExpSimple[#RegExpSimple2#, #id] » > { SwitchTo(nestedState); } }
<IN_«TokenName[#id]»,IN_NESTED_«TokenName[#id]»> MORE : { < ~[] > }
%}
⟫
;
PG-DeclareRegExpChoice[%rawRegExpChoice⟪ #RegExpUnits# ⟫, #id]
→
PG-DeclareRegExpUnits[#RegExpUnits#, #id]
;

PG-DeclareRegExpUnits[$List[RawRegExpUnit], $String] :: Text;
PG-DeclareRegExpUnits[%rawRegExpUnits⟪ #RegExpUnit# #RegExpUnits# ⟫, #id]
→
%n⟪« PG-DeclareRegExpUnit[#RegExpUnit#, #id] »« PG-DeclareRegExpUnits[#RegExpUnits#, #id] »⟫
;
PG-DeclareRegExpUnits[%rawRegExpUnits⟪ ⟫, #id]
→
%n⟪⟫
;

PG-DeclareRegExpUnit[RawRegExpUnit, $String] :: Text;
PG-DeclareRegExpUnit[%rawRegExpUnit⟪ #RegExpSimple# ⟫, #id] → PG-DeclareRegExpSimple[#RegExpSimple#, #id] ;
PG-DeclareRegExpUnit[%rawRegExpUnit⟪ #RegExpSimple# ? ⟫, #id] → PG-DeclareRegExpSimple[#RegExpSimple#, #id] ;
PG-DeclareRegExpUnit[%rawRegExpUnit⟪ #RegExpSimple# * ⟫, #id] → PG-DeclareRegExpSimple[#RegExpSimple#, #id] ;
PG-DeclareRegExpUnit[%rawRegExpUnit⟪ #RegExpSimple# + ⟫, #id] → PG-DeclareRegExpSimple[#RegExpSimple#, #id] ;
PG-DeclareRegExpUnit[%rawRegExpUnit⟪ #RegExpSimple# + _ #RegExpLeaf# ⟫, #id] → %n⟪« PG-DeclareRegExpSimple[#RegExpSimple#, #id] »« PG-DeclareRegExpSimple[#RegExpLeaf#, #id] »⟫ ;

PG-DeclareRegExpSimple[RawRegExpSimple, $String] :: Text;
PG-DeclareRegExpSimple[%rawRegExpSimple⟪ #String# ⟫, #id] → %n⟪⟫ ;
PG-DeclareRegExpSimple[%rawRegExpSimple⟪ #Word# ⟫, #id] → %n⟪⟫ ;
PG-DeclareRegExpSimple[%rawRegExpSimple⟪ #FragmentRef# ⟫, #id] → %n⟪⟫ ;
PG-DeclareRegExpSimple[%rawRegExpSimple⟪ . ⟫, #id] → %n⟪⟫ ;
PG-DeclareRegExpSimple[%rawRegExpSimple⟪ #RegExpClass# ⟫, #id] → %n⟪⟫ ;
PG-DeclareRegExpSimple[%rawRegExpSimple⟪ ( #RegExp# ) ⟫, #id] → PG-DeclareRegExp[#RegExp#, #id] ;

)]
