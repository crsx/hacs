//// HxRaw.pg: GRAMMAR FOR .hx RAW HACS FILES.
//// Copyright © 2012,2014 Kristoffer H. Rose <krisrose@rcsx.org>

class org.crsx.hacs.HxRaw :
%%%HXNONTERMINALS%%%
 <Term>, <NotVariableTerm>, <Attributes>, <Attribute>, <AttributeValue>, <Scopes>, <Scope>, <Terms>

prefix %%%PREFIX%%%

declarations
%{
static String hacspre(String s) {return "%%%PREFIX%%%"+net.sf.crsx.util.Util.quoteJavaIdentifierPart(s);} // prefix for constructors
static String unwrap(String s) {return s.substring(1, s.length()-1);}
static String unpp(String s) {return "\001"+s.substring(1, s.length()-1)+"\001";}
static String checkModuleString(String s) throws ParseException {if (java.util.regex.Pattern.matches("[\"]([a-z0-9]+[.])*[A-Z][A-Za-z0-9]*[\"]", s)) return s; else throw new ParseException("Illegal module name "+s);}

private String storedSort = "";
String unmeta(String s) {if (System.getenv("meta") == null) return s.substring(1, s.length()-1); else return /*TODO: reparse as storedSort meta-term.*/ null;}
%}


//// HACS-INTERNAL META RAW SYNTAX.

// Guillemets ("French quotes") used for embedded  CRSX terms (for sort hacks???).
<Embedded> (*) ::= Embedded$$:unwrap .
token Embedded (*) ::= '«' (~['«','»'])* '»' .

// Meta-variables #SortN# can be used in hx syntax. 
meta[<SortParam>]  ::=  '#<PRODUCTION_NAME>' ( (DIGIT)* | '_' (DIGIT | UPPER | LOWER)* ) '#' , '⦃', '⦄', '∥' .
inject[<Embedded>]  ::=  '%<PRODUCTION_NAME>', '', '' .


////////////////////////////////////////////////////////////////////////
%%%HXPREPRODUCTIONS%%%
////////////////////////////////////////////////////////////////////////


//// RAW TERMS.

<Term> ::=
  <Variable>!!!:#v ( {Special}:hacspre {{#v}} CONCRETE$$:unwrap:{n} | {VariableUse}:hacspre {{#v}} <Attributes>)
| <NotVariableTerm>
.

<NotVariableTerm> ::=
  <Constructor>:#C
  <Repeat>:#R
  ( {UnparsedSorted}:hacspre {{#C}} {{#R}} (CONCRETE$:unmeta) <Attributes>
  | {MetaApplicationSorted}:hacspre {{#C}} {{#R}} <MetaVariable> ( LBRACKET (<Terms> | {$Nil}) RBRACKET | {$Nil} ) <Attributes>
  | {ConstructionSorted}:hacspre {{#C}} {{#R}} <Constructor> ( LPAREN (<Scopes> | {$Nil}) RPAREN
                                                        | LBRACKET (<Scopes> | {$Nil}) RBRACKET
                                                        | {$Nil}                                ) <Attributes>
  | {VariableUseSorted}:hacspre {{#C}} {{#R}} <Variable>!!! <Attributes>
  | {LiteralSorted}:hacspre {{#C}} {{#R}} <Literal> <Attributes>
  | {Construction}:hacspre {{#C}} ( LPAREN (<Scopes> | {$Nil}) RPAREN
                             | LBRACKET (<Scopes> | {$Nil}) RBRACKET
                             | {$Nil}                                ) <Attributes>
  )
| {Literal}:hacspre <Literal> <Attributes>
| {Unparsed}:hacspre (CONCRETE$:unmeta) <Attributes>
| {MetaApplication}:hacspre <MetaVariable> ( LBRACKET (<Terms> | {$Nil}) RBRACKET | {$Nil} ) <Attributes>
.

<Scopes> ::= {$Cons} <Scope> (COMMA <Scopes> | {$Nil}) .
<Scope> ::=
  {Scope}:hacspre ({$Nil}) <NotVariableTerm>
| <Variable>!!!:#v ({Scope}:hacspre ({$Cons} {{#v}} <Variables>) DOT <Term> | {Scope}:hacspre ({$Nil}) ({VariableUse}:hacspre {{#v}}))
| {Scope}:hacspre LBRACKET (<VariableList> | {$Nil}) RBRACKET <Term>
.

<Variables> ::= {$Cons} <Variable>!!! <Variables> | {$Nil} .
<VariableList> ::= {$Cons} <Variable>!!! ( COMMA <VariableList> | {$Nil} ) .

<Terms> ::= {$Cons} <Term> (COMMA <Terms> | {$Nil}) .

<Attributes> ::= ( {$Cons} <Attribute> <Attributes> | {$Nil} ).
<Attribute> ::=
  {Attribute}:hacspre <AttributeKind> <AttributeName> <AttributeValue>
.

<AttributeValue> ::= 
  {AttributeValue}:hacspre LPAREN <Term> RPAREN
| LBRACE ( <Term>:# ( {AttributeKeyValue}:hacspre {{#}} COLON <Term> RBRACE
                    | {AttributeKey}:hacspre {{#}} RBRACE )
         | {AttributeNotKey}:hacspre NOT <Term> RBRACE )
.

////////////////////////////////////////////////////////////////////////
%%%HXPOSTPRODUCTIONS%%%
////////////////////////////////////////////////////////////////////////
