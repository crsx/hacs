// CookPG: RULES FOR CONVERTING HX HACS FORMAT TO PG FORMAT.
//
// Reads the HACS (.hx) file as "Hx" term.
// Emits a CRSX3 ParserGenerator grammar (.pg as text) for the user's terms.
//
// Units:
// 1. Top level (PG)
// 2. Resolve imports (PG-ResolveImports).
// 3. Declaration maps (PG-MapDeclarations).
// 4. Text of all non-terminal productions (PG-Productions).

// 15. PG-Lexical: Text of Lexical Declarations.
// 16. Text naming conventions.

// x. Helpers.


PG[(

// Sorts for generated terms.
$CheckGrammar["org.crsx.hacs.HxRaw"];
///$Use["org/crsx/hacs/HxRaw-sorts.crs"];

// Syntax and sorts of text (%n⟪...⟫).
$CheckGrammar["net.sf.crsx.text.Text"];
$Use["net/sf/crsx/text/Text.crs"];

// Standard prelude.
$Use["org/crsx/hacs/Prelude.crs"];

// Insert options automatically.
$Lax;


/////////////////////////////////////////////////////////////////////
// 1. PG: TOP LEVEL
//
// Convert HACS tree to Text of .pg parser.
//
// PG1: Extract declarations from HACS hx term with all modules inlined.
// PG2: Generate actual text of .pg grammar.

PG[HxModule] :: Text;
PG[%rawHxModule⟦ module #HxModuleName# { #HxDeclarations# } ⟧]
→
PG1[#HxModuleName#, PG-ResolveImports[#HxDeclarations#, #HxModuleName#]]
;

PG1[$String<!--ModuleName-->, $List[HxDeclaration]] :: Text;
PG1[#ModuleName, #Declarations]
→
PG2[{} PG-MapDeclarations[#Declarations, #ModuleName], #Declarations, #ModuleName]
;

PG2[DeclarationMap, $List[HxDeclaration], $String<!--ModuleName-->] :: Text ;
-[Data[#Declarations]]:
PG2[{#DM}DM, #Declarations, #ModuleName]
→
%n⟪/* PG Grammar for HACS module †« #ModuleName ». */


/* INTERFACE. */

class /***PG: †« PG-ClassName[#ModuleName] »Parser***/ /***METAPG: †« PG-ClassName[#ModuleName] »Meta***/ :
/***METAPG: %%%HXNONTERMINALS%%%***/
<†« {#DM}PG-MainSymbol »>« MapTextWrap[n.%n⟨<†‹n›>⟩, {#DM}PG-NonMainSymbols, %n⟨,¶⟩, %n⟨,¶⟩, %n⟨⟩] »

prefix "†« PG-Prefix[#ModuleName] »"

/***METAPG: declarations ***/
/***METAPG: %{ ***/
/***METAPG: String hxpre(String s) {return "%%%PREFIX%%%" + s;} ***/
/***METAPG: String unconcrete(String s) {return s.substring(1, s.length()-1).trim();} ***/
/***METAPG: %} ***/

%{
TOKEN_MGR_DECLS : { int nesting; int nestedState;} /* Used by all nesting constructs. */
%}

/***METASORTS: /* META-TERM SORTS. */ ***/
/***METASORTS: ***/
/***METASORTS: †« PG-QN[#ModuleName, "NodeSort", "Term"] » ::= (⟦ ***/
« FoldNamesWhen[ok n t.PG-then-ConstructionSortCaseText[ok, #ModuleName, n, t], {#DM}PG-AllSortNames, %n⟨⟩] »⟧
/***METASORTS: ); ***/
/***METASORTS: †« PG-QN[#ModuleName, "NodeSort", "Scope"] » ::= (⟦ ***/
/***METASORTS: †« PG-QN[#ModuleName, "Tag", "Binder"] »[binder :: †« PG-QN[#ModuleName, "NodeSort", "Term"] » . †« PG-QN[#ModuleName, "NodeSort", "Scope"] »]; ***/
/***METASORTS: †« PG-QN[#ModuleName, "Tag", "Subterm"]»[†« PG-QN[#ModuleName, "NodeSort", "Term"] »]; ⟧ ***/
/***METASORTS: ); ***/

/***METAPG: ////////////////////////////////////////////////////////////////////////***/
/***METAPG: %%%HXPREPRODUCTIONS%%%***/
/***METAPG: ////////////////////////////////////////////////////////////////////////***/


/* /***METAPG:USER EMBEDDED***/ GRAMMAR. */
« {#DM}PG-Productions[#ModuleName] »

/***METAPG: <Term> ::= TODO; ***/
« FoldNamesWhen[ok n t.PG-then-ConstructionAlternative[ok, #ModuleName, n, t], {#DM}PG-AllSortNames, %n⟨⟩] »


/***METAPG: ////////////////////////////////////////////////////////////////////////***/
/***METAPG: %%%HXPOSTPRODUCTIONS%%%***/
/***METAPG: ////////////////////////////////////////////////////////////////////////***/


/* TOKENS. */

« PG-Lexical[#Declarations, #ModuleName] »
⟫
;

PG-then-ConstructionSortCaseText[OK, #ModuleName, #Name, #rest]
→
%n⟪/***METASORTS: †« PG-QN[#ModuleName, "Node", #Name] »[†« PG-QN[#ModuleName, "TagSort", #Name] », $List[†« PG-QN[#ModuleName, "NodeSort", "Scope"] »]]; ***/
« #rest»⟫
;

PG-then-ConstructionAlternative[OK, #ModuleName, #Name, #rest]
→
%n⟪/***METAPG: "†«#Name»" <†« PG-QN[#ModuleName, "Term", #Name] »[†« PG-QN[#ModuleName, "TagSort", #Name] », $List[†« PG-QN[#ModuleName, "NodeSort", "Scope"] »]]; ***/
« #rest»⟫
;

// ALTERNATE TOP LEVEL:

PG-GetModuleName[HxModule] :: Text;
PG-GetModuleName[%rawHxModule⟦ module #HxModuleName# { #HxDeclarations# } ⟧]
→
%n⟪†«$[Replace,#HxModuleName#,"\"",""]»⟫
;





/////////////////////////////////////////////////////////////////////
// 2. PG-ResolveImports: RESOLVE IMPORTS.
//
// Echo full list of declarations with all imported modules inlined. 
// TODO: Alias MyPrefix$Symbol with ImportedPrefix$Symbol for the imported names.

PG-ResolveImports[$List[HxDeclaration], $String] :: $List[HxDeclaration];

Resolve-Import:
PG-ResolveImports[%rawHxDeclarations⟪ import #HxModuleName# ( #HxSortNames# ) ; #HxDeclarations# ⟫, #ModuleName]
→
PG-ResolveImports[%rawHxDeclarations⟪ %HxEmbeddedModule« $[ParseURL, "hxEmbeddedModule", $[Replace,#HxModuleName#,"\"",""]] » ; #HxDeclarations# ⟫, #ModuleName]
;

Resolve-Module:
PG-ResolveImports[%rawHxDeclarations⟪ module #HxModuleName2# { #HxDeclarations2# } ; #HxDeclarations# ⟫, #ModuleName]
→
%rawHxDeclarations⟪
  module #HxModuleName2# { %HxDeclarations« PG-ResolveImports[#HxDeclarations2#, #HxModuleName2#] » } ;
  %HxDeclarations« PG-ResolveImports[#HxDeclarations#, #ModuleName] »
⟫
;

Resolve-Space:
PG-ResolveImports[%rawHxDeclarations⟪ space #HxRegExp# ; #HxDeclarations# ⟫, #ModuleName]
→
%rawHxDeclarations⟪ space #HxRegExp# ; %HxDeclarations« PG-ResolveImports[#HxDeclarations#, #ModuleName] » ⟫
;

Resolve-Token:
PG-ResolveImports[%rawHxDeclarations⟪ token #HxSortName# | #HxRegExp# ; #HxDeclarations# ⟫, #ModuleName]
→
%rawHxDeclarations⟪ token #HxSortName# | #HxRegExp# ; %HxDeclarations« PG-ResolveImports[#HxDeclarations#, #ModuleName] » ⟫
;

Resolve-Fragment:
PG-ResolveImports[%rawHxDeclarations⟪ fragment #HxFragmentName# | #HxRegExp# ; #HxDeclarations# ⟫, #ModuleName]
→
%rawHxDeclarations⟪ fragment #HxFragmentName# | #HxRegExp# ; %HxDeclarations« PG-ResolveImports[#HxDeclarations#, #ModuleName] » ⟫
;

Resolve-Attribute:
PG-ResolveImports[%rawHxDeclarations⟪ attribute #HxAttributeKind# #HxAttributeName# #HxAttributeForm# #HxAttributeOptions# ; #HxDeclarations# ⟫, #ModuleName]
→
%rawHxDeclarations⟪ attribute #HxAttributeKind# #HxAttributeName# #HxAttributeForm# #HxAttributeOptions# ; %HxDeclarations« PG-ResolveImports[#HxDeclarations#, #ModuleName] » ⟫
;

Resolve-Sort:
PG-ResolveImports[%rawHxDeclarations⟪ sort #HxSortName# #HxRepeat# #HxSortAbstraction# ; #HxDeclarations# ⟫, #ModuleName]
→
%rawHxDeclarations⟪ sort #HxSortName# #HxRepeat# #HxSortAbstraction# ; %HxDeclarations« PG-ResolveImports[#HxDeclarations#, #ModuleName] » ⟫
;

Resolve-Main-Sort:
PG-ResolveImports[%rawHxDeclarations⟪ main sort #HxSortName# #HxRepeat# #HxSortAbstraction# ; #HxDeclarations# ⟫, #ModuleName]
→
%rawHxDeclarations⟪ main sort #HxSortName# #HxRepeat# #HxSortAbstraction# ; %HxDeclarations« PG-ResolveImports[#HxDeclarations#, #ModuleName] » ⟫
;

Resolve-NakedAlternative:
PG-ResolveImports[%rawHxDeclarations⟪ #HxSortAlternatives# ; #HxDeclarations# ⟫, #ModuleName]
→
%rawHxDeclarations⟪ #HxSortAlternatives# ; %HxDeclarations« PG-ResolveImports[#HxDeclarations#, #ModuleName] » ⟫
;

ResolveRule:
PG-ResolveImports[%rawHxDeclarations⟪ rule #HxRule# ; #HxDeclarations# ⟫, #ModuleName]
→
%rawHxDeclarations⟪ rule #HxRule# ; %HxDeclarations« PG-ResolveImports[#HxDeclarations#, #ModuleName] » ⟫
;

ResolveNesting:
PG-ResolveImports[%rawHxDeclarations⟪ { #HxDeclarations1# } #HxDeclarations2# ⟫, #ModuleName]
→
%rawHxDeclarations⟪ { %HxDeclarations« PG-ResolveImports[#HxDeclarations1#, #ModuleName] » } %HxDeclarations« PG-ResolveImports[#HxDeclarations2#, #ModuleName] » ⟫
;

ResolveDone:
PG-ResolveImports[%rawHxDeclarations⟪ ⟫, #ModuleName]
→
%rawHxDeclarations⟪ ⟫
;


/////////////////////////////////////////////////////////////////////
// 3. DECLARATION MAPS (PG-MapDeclarations)
//
// Contains all declarations of tokens, attributes, sorts, and some extras,
// needed for grammar generation.

// Data sort for completed map.

{$String<!--Name--> : DeclarationMapEntry}
DeclarationMap ::=( DM; );

DeclarationMapEntry ::=(
 DME_TOKEN[$String<!--SortName-->];
 DME_ATTRIBUTE[HxAttributeKind, $String<!--AttributeName-->, HxAttributeForm, $List[HxAttributeOption]];
 DME_SORT[$List[Define], $String<!--FullSortName-->, NameSet<!--precs-->, Wrapper, Boolean<!--IsMainSort-->];
 DME_NONE;
 DME_ALIAS[HxSort];
 DME_STRING[$String];
 DME_NAMES[NameSet];
);

Wrapper ::=( NO_WRAPPER; WRAPPER[HxParsedForm]; );

{$String : $StringEntrySort}
Define ::=(
 D_ABSTRACTION[a::HxSortParam . Define];
 D_FORM[HxForm, FormKind];
 D_SYNTHESIZES[$String<!--AttributeName-->];
 D_RULE[HxRule, $String<!--sort-->, Boolean<!--IsDataEquivalence?-->];
 D_NONE;
);

FormKind ::=( FK_DATA[$List[$String]<!--Tags-->]; FK_SCHEME[NameSet<!--inherits-->]; FK_SYMBOL[$Boolean<!--IsStatic-->, $tring<!--token-->]; FK_SUGAR[HxTerm]; FK_ALIAS; );

// Extract all names.

{$String<!--SortName--> : DeclarationMapEntry} PG-AllSortNames :: NameSet;
{#DM; "$AllSortNames" : DME_NAMES[#Names]} PG-AllSortNames → #Names ;

// Extract main sort name.

{$String<!--SortName--> : DeclarationMapEntry} PG-MainSymbol :: $String ;
{#DM}PG-MainSymbol → {#DM}PG-MainSymbol1[NameSetList[{#DM}PG-AllSortNames], ""] ;

{$String<!--SortName--> : DeclarationMapEntry} PG-MainSymbol1[$List[$String], $String] :: $String ;
{#DM}PG-MainSymbol1[(), #main] → #main ;
-[Data[#n]]: {#DM}PG-MainSymbol1[(#n; #ns), #main] → {#DM}PG-MainSymbol2[$[{#DM}Get, #n, DME_NONE], #ns, #main] ;

{$String<!--SortName--> : DeclarationMapEntry} PG-MainSymbol2[DeclarationMapEntry, $List[$String]] :: $String ;
{#DM}PG-MainSymbol2[DME_SORT[#Defines, #Name, #Precs, #Wrapper, B_TRUE], #ns, #main] → #Name ;
-[Fallback]: {#DM}PG-MainSymbol2[#entry, #ns, #main] → {#DM}PG-MainSymbol1[#ns, #main] ;

// Extract all non-main symbols.

{$String<!--SortName--> : DeclarationMapEntry} PG-NonMainSymbols :: $List[$String] ;
{#DM}PG-NonMainSymbols → {#DM}PG-NonMainSymbols1[NameSetList[{#DM}PG-AllSortNames], {#DM}PG-MainSymbol, ()] ;

{$String<!--SortName--> : DeclarationMapEntry} PG-NonMainSymbols1[$List[$String], $String<!--main-->, NameSet] :: $List[$String] ;
{#DM}PG-NonMainSymbols1[(), #main, #accumulated] → #accumulated ;
-[Data[#n]]: {#DM}PG-NonMainSymbols1[(#n; #ns), #main, #accumulated] → {#DM}PG-NonMainSymbols2[$[{#DM}Get, #n, DME_NONE], #ns, #main, #accumulated] ;

{$String<!--SortName--> : DeclarationMapEntry} PG-NonMainSymbols2[DeclarationMapEntry, $List[$String], $String, NameSet] :: $List[$String] ;
{#DM}PG-NonMainSymbols2[DME_SORT[#Defines, #Name, #Precs, #Wrapper, #IsMain], #ns, #main, #accumulated]
→
If[SameString[#main, #Name],
  {#DM}PG-NonMainSymbols1[#ns, #main, #accumulated],
  (#Name; {#DM}PG-NonMainSymbols1[#ns, #main, #accumulated])
]
;
{#DM}PG-NonMainSymbols2[DME_TOKEN[#Name], #ns, #main, #accumulated]
→
(#Name; {#DM}PG-NonMainSymbols1[#ns, #main, #accumulated])
;
-[Fallback]:
{#DM}PG-NonMainSymbols2[#entry, #ns, #main, #accumulated]
→
{#DM}PG-NonMainSymbols1[#ns, #main, #accumulated]
;

// Extract token for symbol sorts...TODO: add sorts and complete patterns.

PG-ExtractSymbolFormToken[Hx_M_FormParsedSorted[#SortName, #ParsedForm, #prec, #InhRefs]] → PG-ExtractSymbolParsedFormToken[#ParsedForm];
PG-ExtractSymbolFormToken[Hx_M_FormParsed[#ParsedForm, #prec, #InhRefs]] → PG-ExtractSymbolParsedFormToken[#ParsedForm];

PG-ExtractSymbolParsedFormToken[Hx_M_ParsedFormSpace[#sp, #ParsedForm]] → PG-ExtractSymbolParsedFormToken[#ParsedForm];
PG-ExtractSymbolParsedFormToken[Hx_M_ParsedFormTerm[%rawHxScopeSortPrecRepeat⟪ #HxSortName# #HxFormPrec# #HxRepeat# ⟫, #ParsedForm]] → #HxSortName# ;

-[Data[#SortName]]:
{#DM}PG-SymbolSortTokenName[#SortName]
→
PG-SymbolSortTokenName2[$[{#DM}Get,#SortName,DME_NONE]]
;

PG-SymbolSortTokenName2[DME_SORT[(D_FORM[#Form, FK_SYMBOL[#static, #TokenName]];), #Name, #Precs, #Wrapper, #IsMain]] → #TokenName ;
PG-SymbolSortTokenName2[$[NotMatch,DME_SORT[(D_FORM[#Form, FK_SYMBOL[#static, #TokenName]];), #Name, #Precs, #Wrapper, #IsMain], #_]] → "" ;

// Start mapping...

PG-MapDeclarations[$List[HxDeclaration], $String<!--ModuleName-->] :: DeclarationMap ;
PG-MapDeclarations[#Declarations, #ModuleName]
→
{}
PG-MapDeclarations1[#Declarations, #ModuleName, "", NoNames, ok¹ s ss.PG-Finish[ss]] // data without required environment!
;

// Process declarations.

{$String<!--SortName--> : DeclarationMapEntry}
PG-MapDeclarations1[$List[HxDeclaration], $String<!--ModuleName-->, $String<!--LastSortName-->, NameSet<!--Names-->,
                    ok¹::Ok s::$String<!--SortName--> ss::NameSet<!--SortNames--> . DeclarationMap] :: DeclarationMap ;

{#DM}
PG-MapDeclarations1[%rawHxDeclarations⟪ module #HxModuleName2# { #HxDeclarations2# } ; #HxDeclarations# ⟫, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
→
{#DM}
PG-MapDeclarations1[#HxDeclarations2# , #HxModuleName2#, "", #Names, ok¹ s ss.PG-then-Declarations1[ok¹, #HxDeclarations#, #ModuleName, #LastSortName, ss, ok2¹ s2 ss2.#[ok2¹,s2,ss2]]]
;

Declarations-space:
{#DM}
PG-MapDeclarations1[%rawHxDeclarations⟪ space #HxRegExp# ; #HxDeclarations# ⟫, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
→
{#DM}
PG-MapDeclarations1[#HxDeclarations#, #ModuleName, "", #Names, ok¹ s ss.#[ok¹,s,ss]]
;

Declarations-token[Data[#SortName]]:
{#DM}
PG-MapDeclarations1[%rawHxDeclarations⟪ token #HxSortName# | #HxRegExp# ; #HxDeclarations# ⟫, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
→
{#DM; #HxSortName# : DME_TOKEN[#HxSortName#]}
PG-MapDeclarations1[#HxDeclarations#, #ModuleName, "", AddName[#Names, #HxSortName#], ok¹ s ss.#[ok¹,s,ss]]
;
/// {#DM}
/// PG-MapDeclarationsInsertToken[PG-QN[#ModuleName, "NodeSort", #HxSortName#], #HxDeclarations#, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
/// ;
///     // Local helper to compute qualified token name and insert declaration.
///     -[Data[#QualifiedName]]:
///     {#DM}PG-MapDeclarationsInsertToken[#QualifiedName, #Declarations, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
///     →
///     {#DM; #QualifiedName : DME_TOKEN[#QualifiedName]}
///     PG-MapDeclarations1[#Declarations, #ModuleName, "", AddName[#Names, #QualifiedName], ok¹ s ss.#[ok¹,s,ss]]
///     ;

Declarations-fragment:
{#DM}
PG-MapDeclarations1[%rawHxDeclarations⟪ fragment #HxFragmentName# | #HxRegExp# ; #HxDeclarations# ⟫, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
→
{#DM}
PG-MapDeclarations1[#HxDeclarations#, #ModuleName, "", #Names, ok¹ s ss.#[ok¹,s,ss]]
;

Declarations-attribute[Data[#HxAttributeName#,#HxAttributeForm#]]:
{#DM}
PG-MapDeclarations1[%rawHxDeclarations⟪ attribute #HxAttributeKind# #HxAttributeName# #HxAttributeForm# #HxAttributeOptions# ; #HxDeclarations# ⟫, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
→
{#DM; #HxAttributeName# : DME_ATTRIBUTE[#HxAttributeKind#, #HxAttributeName#, #HxAttributeForm#, #HxAttributeOptions#]}
PG-MapDeclarations1[#HxDeclarations#, #ModuleName, "", AddName[#Names, #HxAttributeName#], ok¹ s ss.#[ok¹,s,ss]]
;
/// {#DM}
/// PG-MapDeclarationsInsertAttribute[PG-QN[#ModuleName, "Attribute" #HxAttributeName#], #HxAttributeKind#, #HxAttributeForm#, #HxAttributeOptions#, #HxDeclarations#, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
/// ;
///     // Local helper to compute qualified attribute name and insert declaration.
///     -[Data[#QualifiedName]]:
///     {#DM}PG-MapDeclarationsInsertAttribute[#QualifiedName, #AttributeKind, #AttributeForm, #AttributeOptions, #Declarations, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
///     →
///     {#DM; #QualifiedName : DME_ATTRIBUTE[#AttributeKind, #QualifiedName, #AttributeForm, #AttributeOptions]}
///     PG-MapDeclarations1[#Declarations, #ModuleName, "", AddName[#Names, #QualifiedName], ok¹ s ss.#[ok¹,s,ss]]
///     ;

Declarations-sort:
{#DM}
PG-MapDeclarations1[%rawHxDeclarations⟪ sort #HxSortName# #HxRepeat# #HxSortAbstraction# ; #HxDeclarations# ⟫, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
→
{#DM}
PG-SortAbstraction[#HxSortAbstraction#, B_FALSE, #ModuleName, PG-SortNameWithRepeat1[#HxSortName#, #HxRepeat#], #Names, ok¹ s ss.PG-then-Declarations1[ok¹, #HxDeclarations#, #ModuleName, s, ss, ok2¹ s2 ss2.#[ok2¹,s2,ss2]]]
;
/// {#DM}
/// PG-MapDeclarationsInsertSort[PG-QN[#ModuleName, "NodeSort", #HxSortName#], #HxRepeat#, #HxSortAbstraction#, #HxDeclarations#, B_TRUE, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
/// ;
///     // Local helper to compute qualified sort name and insert declaration.
///     -[Data[#QualifiedName]]:
///     {#DM}PG-MapDeclarationsInsertSort[#QualifiedName, #Repeat, #SortAbstraction, #Declarations, #IsMain, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
///     →
///     {#DM}
///     PG-SortAbstraction[#SortAbstraction, #IsMain, #ModuleName, PG-SortNameWithRepeat1[#QualifiedName, #Repeat], #Names, ok¹ s ss.PG-then-Declarations1[ok¹, #Declarations, #ModuleName, s, ss, ok2¹ s2 ss2.#[ok2¹,s2,ss2]]]
///     ;

Declarations-main-sort:
{#DM}
PG-MapDeclarations1[%rawHxDeclarations⟪ main sort #HxSortName# #HxRepeat# #HxSortAbstraction# ; #HxDeclarations# ⟫, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
→
{#DM}
PG-SortAbstraction[#HxSortAbstraction#, B_TRUE, #ModuleName, PG-SortNameWithRepeat1[#HxSortName#, #HxRepeat#], #Names, ok¹ s ss.PG-then-Declarations1[ok¹, #HxDeclarations#, #ModuleName, s, ss, ok2¹ s2 ss2.#[ok2¹,s2,ss2]]]
;
/// {#DM}
/// PG-MapDeclarationsInsertSort[PG-QN[#ModuleName, "NodeSort", #HxSortName#], #HxRepeat#, #HxSortAbstraction#, #HxDeclarations#, B_FALSE, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
/// ;

Declarations-alternatives:
{#DM}
PG-MapDeclarations1[%rawHxDeclarations⟪ #HxSortAlternatives# ; #HxDeclarations# ⟫, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
→
{#DM}
PG-SortAlternatives[#HxSortAlternatives#, #ModuleName, #LastSortName, #Names, ok¹ s ss.PG-then-Declarations1[ok¹, #HxDeclarations#, #ModuleName, s, ss, ok2¹ s2 ss2.#[ok2¹,s2,ss2]]]
;

Declarations-rule:
{#DM}
PG-MapDeclarations1[%rawHxDeclarations⟪ rule #HxRule# ; #HxDeclarations# ⟫, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
→
{#DM}
PG-InsertDefine[D_RULE[#HxRule#, PG-RuleTopSort[#HxRule#, #LastSortName], B_FALSE], B_BALSE<!--NotMain-->, #ModuleName, PG-RuleTopSort[#HxRule#, #LastSortName], #Names, ok¹ s ss.PG-then-Declarations1[ok¹, #HxDeclarations#, #ModuleName, s, ss, ok2¹ s2 ss2.#[ok2¹,s2,ss2]]]
;

    // Local helper to extract sort of rule.
    //
    PG-RuleTopSort[HxRule, $String<!--FallBackName-->] :: $String;
    PG-RuleTopSort[%rawHxRule⟪ #HxPriority# [ #HxOptions# ] #HxNotVariableTerm# → #HxTerm# ⟫, #FallBack]
    →
    PG-TermTopSort[#HxNotVariableTerm#, #FallBack]
    ;
    //
    PG-TermTopSort[HxTerm, $String<!--FallBackName-->] :: $String;
    -[Free[v::Text]]:
    PG-TermTopSort[%rawHxTerm⟪ v #HxAttributes# ⟫, #FallbackSortName] → PG-CheckString[#FallbackSortName] ;
    -[Free[v::Text]]:
    PG-TermTopSort[%rawHxTerm⟪ #HxConstructor1# #HxRepeat1# v #HxAttributes# ⟫, #FallbackSortName] → PG-SortRepeatString[#HxConstructor1#, #HxRepeat1#] ;
    PG-TermTopSort[Hx_M_Unparsed[#Unparsed, #Attributes], #FallbackSortName] → PG-CheckString[#FallbackSortName] ;
    PG-TermTopSort[Hx_M_UnparsedSorted[#SortName, #Repeat, #Unparsed, #HxAttributes#], #FallbackSortName] → #SortName ;
    PG-TermTopSort[%rawHxTerm⟪ #HxConstructor# ( #HxScopes# ) #HxAttributes# ⟫, #FallbackSortName] → PG-CheckString[#FallbackSortName] ;
    PG-TermTopSort[%rawHxTerm⟪ #HxConstructor1# #HxRepeat1# #HxConstructor2# ( #HxScopes# ) #HxAttributes# ⟫, #FallbackSortName] → PG-SortRepeatString[#HxConstructor1#, #HxRepeat1#] ;
    PG-TermTopSort[%rawHxTerm⟪ #HxMetaVariable# [ #HxTerms# ] #HxAttributes# ⟫, #FallbackSortName] → PG-CheckString[#FallbackSortName] ;
    PG-TermTopSort[%rawHxTerm⟪ #HxConstructor1# #HxRepeat1# #HxMetaVariable# [ #HxTerms# ] #HxAttributes# ⟫, #FallbackSortName] → PG-SortRepeatString[#HxConstructor1#, #HxRepeat1#] ;
    PG-TermTopSort[%rawHxTerm⟪ #HxLiteral# #HxAttributes# ⟫, #FallbackSortName] → PG-CheckString[#FallbackSortName] ;
    PG-TermTopSort[Hx_M_Special[#v, #Concrete], #FallbackSortName] → PG-CheckString[#FallbackSortName] ;
    //
    PG-CheckString[$String] :: $String;
    PG-CheckString[#String] → #String ; //$[IfEmpty, #String, CookError[$[:,"Impossible HACS component ",#String]], #String] ;
    //
    PG-SortRepeatString[$String, HxRepeat] :: $String;
    -[Data[#SortName]]: PG-SortRepeatString[#SortName, #Repeat] → $[IfEmpty, #SortName, "", PG-SortRepeatString2[#SortName, #Repeat]] ;
    PG-SortRepeatString2[$String, HxRepeat] :: $String;
    PG-SortRepeatString2[#SortName, %rawHxRepeat⟪ ⟫] → #SortName ;
    PG-SortRepeatString2[#SortName, %rawHxRepeat⟪ ? ⟫] → $[:,#SortName,"?"] ;
    PG-SortRepeatString2[#SortName, %rawHxRepeat⟪ * ⟫] → $[:,#SortName,"*"] ;
    PG-SortRepeatString2[#SortName, %rawHxRepeat⟪ + ⟫] → $[:,#SortName,"+"] ;
    PG-SortRepeatString2[#SortName, %rawHxRepeat⟪ + _ #HxRegExpLeaf# ⟫] → PG-RegExpLeafSuffix[#HxRegExpLeaf#, $[:,#SortName,"+_"]] ;
    //    
    PG-RegExpLeafSuffix[HxRegExpSimple, $String] :: $String;
    -[Data[#HxString#]]: PG-RegExpLeafSuffix[%rawHxRegExpLeaf⟪ #HxString# ⟫, #prefix] → $[:,#prefix,#HxString#] ;
    -[Data[#HxWord#]]:   PG-RegExpLeafSuffix[%rawHxRegExpLeaf⟪ #HxWord# ⟫,   #prefix] → $[:,#prefix,#HxWord#] ;
    //
    PG-RegExpLeafWord[HxRegExpSimple] :: $String;
    -[Data[#HxString#]]: PG-RegExpLeafWord[%rawHxRegExpLeaf⟪ #HxString# ⟫] → $[Rescape, #HxString#] ;
    -[Data[#HxWord#]]:   PG-RegExpLeafWord[%rawHxRegExpLeaf⟪ #HxWord# ⟫] → #HxWord# ;

Declarations-local:
{#DM}
PG-MapDeclarations1[%rawHxDeclarations⟪ { #HxDeclarations2# } #HxDeclarations# ⟫, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
→
{#DM}
PG-MapDeclarations1[#HxDeclarations2# , #ModuleName, #LastSortName, #Names, ok¹ s ss.PG-then-Declarations1[ok¹, #HxDeclarations#, #ModuleName, #LastSortName, ss, ok2¹ s2 ss2.#[ok2¹,s2,ss2]]]
;

Declarations-none:
{#DM}
PG-MapDeclarations1[%rawHxDeclarations⟪ ⟫, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
→
{#DM}
#[OK, #LastSortName, #Names]
;

// Delayed variant.
{$String<!--SortName--> : DeclarationMapEntry}
PG-then-Declarations1[Ok, $List[HxDeclaration], $String<!--ModuleName-->, $String<!--LastSortName-->, NameSet<!--SortNames-->,
                      ok¹::Ok s::$String<!--SortName--> ss::NameSet<!--SortNames--> . DeclarationMap] :: DeclarationMap ;
//
{#DM}
PG-then-Declarations1[OK, #Declaration*, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
→
{#DM}
PG-MapDeclarations1[#Declaration*, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
;

// Sort declarations factor any leading parameters over all declarations.

{$String<!--SortName--> : DeclarationMapEntry}
PG-SortAbstraction[HxSortAbstraction, Boolean<!--IsMain-->, $String<!--ModuleName-->, $String<!--SortName-->, NameSet<!--SortNames-->,
                   ok¹::Ok s::$String<!--SortName--> ss::NameSet<!--SortNames--> . DeclarationMap] :: DeclarationMap ;

{#DM}
PG-SortAbstraction[#SortAbstraction, #IsMain, #ModuleName, #Name, #Names, ok¹ s ss.#[ok¹, s, ss]]
→
{#DM}
PG-InsertDefines[PG-SortAbstractionDefines[#SortAbstraction], #IsMain, #ModuleName, #Name, #Names, ok¹ s ss.#[ok¹, s, ss]]
;
{$String<!--SortName--> : DeclarationMapEntry}
PG-SortAlternatives[$List[HxSortAlternative], $String<!--ModuleName-->, $String<!--SortName-->, NameSet<!--SortNames-->,
                   ok¹::Ok s::$String<!--SortName--> ss::NameSet<!--SortNames--> . DeclarationMap] :: DeclarationMap ;

{#DM}
PG-SortAlternatives[(), #ModuleName, #Name, #Names, ok¹ s ss.#[ok¹, s, ss]]
→
{#DM}
#[OK, #Name, #Names]
;

-[Data[#Name]]:
{#DM}
PG-SortAlternatives[(#sa;#sas), #ModuleName, #Name, #Names, ok¹ s ss.#[ok¹, s, ss]]
→
$[IfEmpty, #Name, PG-SortAlternatives-Error,
  {#DM}PG-InsertDefines[PG-SortAlternativesDefines[(#sa;#sas)], B_FALSE, #ModuleName, #Name, #Names, ok¹ s ss.#[ok¹, s, ss]]]
;
PG-SortAlternatives-Error :: DeclarationMap;
PG-SortAlternatives-Error → $[Error,"Error: cannot process stand-alone SortAlternatives with no current sort."];

PG-SortAbstractionDefines[HxSortAbstraction] :: $List[Define] ;
PG-SortAbstractionDefines[%rawHxSortAbstraction⟪ #HxSortAlternatives# ⟫] → PG-SortAlternativesDefines[#HxSortAlternatives#] ;
PG-SortAbstractionDefines[%rawHxSortAbstraction⟪ a #HxSortAbstraction#⦃a⦄  ⟫] → PG-SortAbstractionDefines2[a.PG-SortAbstractionDefines[#HxSortAbstraction#[a]]] ;

PG-SortAbstractionDefines2[a::HxSortParam.$List[Define]] :: $List[Define] ;
PG-SortAbstractionDefines2[a.$Nil] → () ;
PG-SortAbstractionDefines2[a.$Cons[#Define[a], #Defines[a]]] → ( D_ABSTRACTION[a.#Define[a]] ; PG-SortAbstractionDefines2[a.#Defines[a]] ) ;

PG-SortAlternativesDefines[$List[HxSortAlternative]] :: $List[Define] ;
PG-SortAlternativesDefines[%rawHxSortAlternatives⟪ ⟫] → () ;
PG-SortAlternativesDefines[%rawHxSortAlternatives⟪ #HxSortAlternative# #HxSortAlternatives# ⟫]
→
( PG-SortAlternativeDefine[#HxSortAlternative#] ; PG-SortAlternativesDefines[#HxSortAlternatives#] )
; 

PG-SortAlternativeDefine[HxSortAlternative] :: Define ;

PG-SortAlternativeDefine[{#LOC} %rawHxSortAlternative⟪ | scheme #HxForm#         ⟫] → {#LOC} D_FORM[#HxForm#, FK_SCHEME[PG-FormInheritedAttributes[#HxForm#]]] ;
PG-SortAlternativeDefine[{#LOC} %rawHxSortAlternative⟪ | data #HxForm# #HxTagging# ⟫] → {#LOC} D_FORM[#HxForm#, FK_DATA[#HxTagging#]];
PG-SortAlternativeDefine[{#LOC} %rawHxSortAlternative⟪ | symbol #HxForm#         ⟫] → {#LOC} D_FORM[#HxForm#, FK_SYMBOL[$False, PG-ExtractSymbolFormToken[#HxForm#]]];
PG-SortAlternativeDefine[{#LOC} %rawHxSortAlternative⟪ | static symbol #HxForm#  ⟫] → {#LOC} D_FORM[#HxForm#, FK_SYMBOL[$True, PG-ExtractSymbolFormToken[#HxForm#]]];
PG-SortAlternativeDefine[{#LOC} %rawHxSortAlternative⟪ | sugar #HxForm# → #HxTerm# ⟫] → {#LOC} D_FORM[#HxForm#, FK_SUGAR[#HxTerm#]] ;

PG-SortAlternativeDefine[{#LOC} %rawHxSortAlternative⟪ | ↑ #HxAttributeName# ⟫] → {#LOC} D_SYNTHESIZES[#HxAttributeName#] ;

    // Local helper to extract list of attributes from Form.
    //
    PG-FormInheritedAttributes[HxForm] :: NameSet;
    PG-FormInheritedAttributes[Hx_M_FormParsedSorted[#Name, #ParsedForm, #Prec, #InheritedRefs]] → PG-InheritedRefsList[#InheritedRefs] ;
    PG-FormInheritedAttributes[Hx_M_FormParsed[#ParsedForm, #Prec, #InheritedRefs]] → PG-InheritedRefsList[#InheritedRefs] ;
    PG-FormInheritedAttributes[Hx_M_FormConstruction[#Constructor, #ScopeSorts, #InheritedRefs]] → PG-InheritedRefsList[#InheritedRefs] ;
    //
    PG-InheritedRefsList[$List[HxInheritedRef]] :: NameSet;
    PG-InheritedRefsList[()] → NoNames ;
    PG-InheritedRefsList[(%rawHxInheritedRef⟪ ↓ #HxAttributeName1# ⟫; #refs)]
    →
    AddName[PG-InheritedRefsList[#refs], #HxAttributeName1#]
    ;

// Finish by inserting all precedence links. 

{$String<!--SortName--> : DeclarationMapEntry} PG-Finish[NameSet] :: DeclarationMap;
{#DM} PG-Finish[#Names] → {#DM} PG-Finish0[#Names, #Names] ;

// Process all sort names.

{$String<!--SortName--> : DeclarationMapEntry} PG-Finish0[NameSet, NameSet] :: DeclarationMap;
{#DM} PG-Finish0[#RestNames, #Names] → {#DM} PG-Finish1[HasNames[#RestNames], #RestNames, #Names] ;

{$String<!--SortName--> : DeclarationMapEntry} PG-Finish1[Boolean, NameSet, NameSet] :: DeclarationMap;
{#DM} PG-Finish1[B_FALSE, #RestNames, #Names] → {#DM} PG-Finish9[#Names, {#DM} InheritedNames, {#DM} InheritedMapNames, {#DM} SynthesizedNames, {#DM} SynthesizedMapNames] ;
{#DM} PG-Finish1[B_TRUE, #RestNames, #Names] → {#DM} PG-Finish2[FirstName[#RestNames], RemoveFirstName[#RestNames], #Names] ;

{$String<!--SortName--> : DeclarationMapEntry} PG-Finish2[$String, NameSet, NameSet] :: DeclarationMap;
-[Data[#Name]]: {#DM} PG-Finish2[#Name, #RestNames, #Names] → {#DM} PG-Finish3[$[{#DM}Get[DeclarationMapEntry], #Name, DME_NONE], #RestNames, #Names] ;

{$String<!--SortName--> : DeclarationMapEntry} PG-Finish3[DeclarationMapEntry, NameSet, NameSet] :: DeclarationMap;

{#DM} PG-Finish3[DME_NONE, #RestNames, #Names]
→
{#DM} PG-Finish0[#RestNames, #Names]
;

{#DM} PG-Finish3[DME_TOKEN[#Name], #RestNames, #Names]
→
{#DM} PG-Finish0[#RestNames, #Names]
;

{#DM} PG-Finish3[DME_ATTRIBUTE[#AttributeKind1, #AttributeName1, #AttributeForm1, #AttributeOptions1], #RestNames, #Names]
→
{#DM} PG-Finish0[#RestNames, #Names]
;

{#DM} PG-Finish3[DME_SORT[#Defines1, #Name1, #Precs1, #Wrapper1, #IsMain], #RestNames, #Names]
→
{#DM} PG-Finish4[#Precs1, 0, #Name1, #RestNames, #Names]
;

// Find largest precedences.

{$String<!--SortName--> : DeclarationMapEntry} PG-Finish4[NameSet, $Numeric, $String, NameSet, NameSet] :: DeclarationMap;
-[Data[#Precs]]:
{#DM} PG-Finish4[#Precs, #MaxPrec, #Name, #RestNames, #Names]
→
{#DM} PG-Finish5[HasNames[#Precs], #Precs, #MaxPrec, #Name, #RestNames, #Names]
;

{$String<!--SortName--> : DeclarationMapEntry} PG-Finish5[Boolean, NameSet, $Numeric, $String, NameSet, NameSet] :: DeclarationMap;

{#DM} PG-Finish5[B_FALSE, #Precs, #MaxPrec, #Name, #RestNames, #Names]
→
// Got the highest used precedence!
{#DM} PG-Finish7[#MaxPrec, #Name, #RestNames, #Names]
;

{#DM} PG-Finish5[B_TRUE, #Precs, #MaxPrec, #Name, #RestNames, #Names]
→
{#DM} PG-Finish6[FirstName[#Precs], RemoveFirstName[#Precs], #MaxPrec, #Name, #RestNames, #Names]
;

{$String<!--SortName--> : DeclarationMapEntry} PG-Finish6[$String, NameSet, $Numeric, $String, NameSet, NameSet] :: DeclarationMap;
-[Data[#Prec,#Precs,#MaxPrec]]:
{#DM} PG-Finish6[#Prec, #Precs, #MaxPrec, #Name, #RestNames, #Names]
→
{#DM} PG-Finish4[#Precs, $[If, $[GreaterThan, $[Decimal,#Prec], #MaxPrec], $[Decimal,#Prec], #MaxPrec], #Name, #RestNames, #Names]
;

// Add links for all precedences from max down to 0.

{$String<!--SortName--> : DeclarationMapEntry} PG-Finish7[$Numeric, $String, NameSet, NameSet] :: DeclarationMap;

-[Data[#Prec,#Name],Share[#RestNames,#Names]]:
{#DM} PG-Finish7[#Prec, #Name, #RestNames, #Names]
→
$[If, $[GreaterThan,#Prec,0],
  {#DM} PG-InsertDefine[PG-LinkDefine[#Name, #Prec], B_FALSE, "", #Name, #Names,
	ok¹ s ss.PG-then-Finish7[ok¹, $[Minus,#Prec,1], s, #RestNames, ss]],
  {#DM} PG-Finish0[#RestNames, #Names]]
;

{$String<!--SortName--> : DeclarationMapEntry} PG-then-Finish7[Ok, $Numeric, $String, NameSet, NameSet] :: DeclarationMap;
{#DM} PG-then-Finish7[OK, #Prec, #Name, #RestNames, #Names]
→
{#DM} PG-Finish7[#Prec, #Name, #RestNames, #Names]
;

{$String<!--SortName--> : DeclarationMapEntry} PG-Finish9[NameSet, NameSet, NameSet, NameSet, NameSet] :: DeclarationMap;
{#DM} PG-Finish9[#Names, #InheritedNames, #InheritedMapNames, #SynthesizedNames, #SynthesizedMapNames]
→
{#DM; "$AllSortNames" : DME_NAMES[#Names];
      "$AllInheritedNames" : DME_NAMES[#InheritedNames];
      "$AllInheritedMapNames" : DME_NAMES[#InheritedMapNames];
      "$AllSynthesizedNames" : DME_NAMES[#SynthesizedNames];
      "$AllSynthesizedMapNames" : DME_NAMES[#SynthesizedMapNames]}
DM[#Names]
;

PG-LinkDefine[$String, $Numeric] :: Define;
-[Data[#Name,#Prec]]:
PG-LinkDefine[#Name, #Prec]
→
// NOTE: hand-crafted!
{}
D_FORM[
  Hx_M_FormParsedSorted[
    #Name,
    Hx_M_ParsedFormTerm[
      Hx_M_ScopeSortPrecRepeat[  
        Hx_M_ScopeSort[Hx_M_Sort[Hx_M_SortName[#Name, '$Nil'], '$Nil'], Hx_M_RepeatSingle, '$Nil'],
        #Prec,
        Hx_M_RepeatSingle],
      Hx_M_ParsedFormDone],
    $[Minus,#Prec,1],
    ()],
  FK_ALIAS]
;

// Insert single define: get existing list (if any) and insert in proper sorted place.

{$String<!--SortName--> : DeclarationMapEntry}
PG-InsertDefine[Define<!--new-->, Boolean<!--IsMain-->, $String<!--ModuleName-->, $String<!--SortName-->, NameSet<!--SortNames-->,
                ok¹::Ok s::$String<!--SortName--> ss::NameSet<!--SortNames--> . DeclarationMap] :: DeclarationMap ;

-[Data[#Name],Share[#Define,#]]:
{#DM}
PG-InsertDefine[#Define, #IsMain, #ModuleName, #Name, #Names, ok¹ s ss.#[ok¹, s, ss]]
→
{#DM}
PG-InsertDefine1[$[{#DM}Get[DeclarationMapEntry], #Name, DME_NONE], #Define, #IsMain, #ModuleName, #Name, #Names, ok¹ s ss.#[ok¹, s, ss]]
;

{$String<!--SortName--> : DeclarationMapEntry}
PG-InsertDefine1[DeclarationMapEntry<!--existing-->, Define<!--new-->, Boolean<!--IsMain-->, $String<!--ModuleName-->, $String<!--SortName-->, NameSet<!--SortNames-->,
                 ok¹::Ok s::$String<!--SortName--> ss::NameSet<!--SortNames--> . DeclarationMap] :: DeclarationMap ;

{#DM}
PG-InsertDefine1[DME_SORT[#existingDefines1, #Name1, #Precs1, #Wrapper1, #IsMain1], #newDefine, #IsMain, #ModuleName, #Name, #Names, ok¹ s ss.#[ok¹, s, ss]]
→
{#DM}
PG-InsertDefine4[
	PG-InsertDefine2[#existingDefines1, #newDefine],
	AddNameNumber[#Precs1, PG-DefinePrec[#newDefine]],
	#Name1,
	#Names,
	PG-DefineWrapper[#newDefine, #Name, #Wrapper1],
	Or[#IsMain1, #IsMain],
	ok¹ s ss.#[ok¹, s, ss]]
;
//
{#DM}
PG-InsertDefine1[DME_NONE<!--not found-->, #newDefine, #IsMain, #ModuleName, #Name, #Names, ok¹ s ss.#[ok¹, s, ss]]
→
{#DM}
PG-InsertDefine1b[#Name, #Names, #newDefine, AddNameNumber[NoNames, PG-DefinePrec[#newDefine]], PG-DefineWrapper[#newDefine, #Name, NO_WRAPPER], #IsMain, ok¹ s ss.#[ok¹, s, ss]]
;

{$String<!--SortName--> : DeclarationMapEntry}
PG-InsertDefine1b[$String<!--SortName-->, NameSet<!--SortNames-->, Define, NameSet<!--Precs-->, Wrapper, Boolean<!--IsMain-->,
                ok¹::Ok s::$String<!--SortName--> ss::NameSet<!--SortNames--> . DeclarationMap] :: DeclarationMap ;
-[Data[#newDefine,#Name,#Precs,#Wrapper]]:
{#DM}
PG-InsertDefine1b[#Name, #Names, #newDefine, #Precs, #Wrapper, #IsMain, ok¹ s ss.#[ok¹, s, ss]]
→
{#DM; #Name : DME_SORT[(#newDefine;), #Name, #Precs, #Wrapper, #IsMain]}
#[OK, #Name, AddName[#Names, #Name]]
;

PG-InsertDefine2[$List[Define]<!--existing-->, Define<!--new-->] :: $List[Define]<!--merged-->;
//
PG-InsertDefine2[(), #newDefine] → (#newDefine;) ;
//
PG-InsertDefine2[(#Define1; #Defines), #newDefine]
→
PG-InsertDefine3[PG-DefineLessEqual[#newDefine, #Define1], #newDefine, #Define1, #Defines]
;

PG-InsertDefine3[Boolean<!--new goes before old-->, Define<!--new-->, Define<!--old-->, $List[Define]<!--old rest-->] :: $List[Define]<!--merged-->;
//,
PG-InsertDefine3[B_TRUE , #newDefine, #Define1, #Defines] → (#newDefine; #Define1; #Defines) ;
PG-InsertDefine3[B_FALSE, #newDefine, #Define1, #Defines] → (#Define1; PG-InsertDefine2[#Defines, #newDefine]) ;

{$String<!--SortName--> : DeclarationMapEntry}
PG-InsertDefine4[$List[Define], NameSet<!--precs-->, $String<!--SortName-->, NameSet<!--SortNames-->, Wrapper, Boolean<!--IsMain-->,
                 ok¹::Ok s::$String<!--SortName--> ss::NameSet<!--SortNames--> . DeclarationMap] :: DeclarationMap ;
//
-[Data[#Defines,#Name,#Precs,#Wrapper]]:
{#DM}
PG-InsertDefine4[#Defines, #Precs, #Name, #Names, #Wrapper, #IsMain, ok¹ s ss.#[ok¹, s, ss]]
→
{#DM; #Name : DME_SORT[#Defines, #Name, #Precs, #Wrapper, #IsMain]}
#[OK, #Name, #Names]
;

// Insert list of defines.

{$String<!--SortName--> : DeclarationMapEntry}
PG-InsertDefines[$List[Define], Boolean<!--IsMain-->, $String<!--ModuleName-->, $String<!--SortName-->, NameSet<!--SortNames-->,
                 ok¹::Ok s::$String<!--SortName--> ss::NameSet<!--SortNames--> . DeclarationMap] :: DeclarationMap ;

{#DM}
PG-InsertDefines[(), #IsMain, #ModuleName, #Name, #Names, ok¹ s ss.#[ok¹,s,ss]]
→
{#DM}
#[OK, #Name, #Names]
;

{#DM}
PG-InsertDefines[(#Define ; #Defines), #IsMain, #ModuleName, #Name, #Names, ok¹ s ss.#[ok¹,s,ss]]
→
{#DM}
PG-InsertDefine[#Define, #IsMain, #ModuleName, #Name, #Names,
	ok1¹ s1 ss1.PG-then-InsertDefines[ok1¹, #Defines, #IsMain, #ModuleName, s1, ss1, ok2¹ s2 ss2.#[ok2¹,s2,ss2]]]
;

{$String<!--SortName--> : DeclarationMapEntry}
PG-then-InsertDefines[Ok, Boolean<!--IsMain-->, $String<!--ModuleName-->, $List[Define], $String<!--SortName-->, NameSet<!--SortNames-->,
                      ok¹::Ok s::$String<!--SortName--> ss::NameSet<!--SortNames--> . DeclarationMap] :: DeclarationMap ;

{#DM}
PG-then-InsertDefines[OK, #Defines, #IsMain, #ModuleName, #Name, #Names, ok¹ s ss.#[ok¹,s,ss]]
→
{#DM}
PG-InsertDefines[#Defines, #IsMain, #ModuleName, #Name, #Names, ok¹ s ss.#[ok¹,s,ss]]
;

// Compare of defines.

PG-DefineLessEqual[Define, Define] :: Boolean ;

//-[Discard[#Define1, #Define2]]: PG-DefineLessEqual[#Define1, #Define2] → B_FALSE ;

// Compare (1) Basic constructs are in order Abstraction/Form-Rule-Attribute.

DLE-Abstraction-Rule     : PG-DefineLessEqual[D_ABSTRACTION[a.#D1[a]], D_RULE[#R2, #S2, #D2]] → B_TRUE ;
DLE-Rule-Abstraction     : PG-DefineLessEqual[D_RULE[#R1, #S1, #D1], D_ABSTRACTION[a.#D2[a]]] → B_FALSE ;
                         
DLE-Synthesizes-Rule: PG-DefineLessEqual[D_SYNTHESIZES[#A1], D_RULE[#R2, #S2, #D2]] → B_TRUE ;
DLE-Rule-Synthesizes: PG-DefineLessEqual[D_RULE[#R1, #S1, #D1], D_SYNTHESIZES[#A2]] → B_FALSE ;
                         
DLE-Form-Rule            : PG-DefineLessEqual[D_FORM[#F1, #K1], D_RULE[#R2, #S2, #D2]] → B_TRUE ;
DLE-Rule-Form            : PG-DefineLessEqual[D_RULE[#R1, #S1, #D1], D_FORM[#F2, #K2]] → B_FALSE ;

DLE-Abstraction-Synthesizes     : PG-DefineLessEqual[D_ABSTRACTION[a.#D1[a]], D_SYNTHESIZES[#A2]] → B_TRUE ;
DLE-Synthesizes-Abstraction     : PG-DefineLessEqual[D_SYNTHESIZES[#A1], D_ABSTRACTION[a.#D2[a]]] → B_FALSE ;

DLE-Abstraction-Form: PG-DefineLessEqual[D_ABSTRACTION[a.#D1[a]], D_FORM[#F2, #K2]] → B_TRUE ;
DLE-Form-Abstraction: PG-DefineLessEqual[D_FORM[#F1, #K1], D_ABSTRACTION[a.#D2[a]]] → B_FALSE ;

DLE-Form-Synthesizes: PG-DefineLessEqual[D_FORM[#F1, #K1], D_SYNTHESIZES[#A2]] → B_TRUE ;
DLE-Synthesizes-Form: PG-DefineLessEqual[D_SYNTHESIZES[#A1], D_FORM[#F2, #K2]] → B_FALSE ;

// Compare (2) Abstractions traversed in parallel.

PG-DefineLessEqual[D_ABSTRACTION[a.#Define1[a]], D_ABSTRACTION[a.#Define2[a]]]
→
PG-DefineLessEqual2[a.PG-DefineLessEqual[#Define1[a], #Define2[a]]]
;
PG-DefineLessEqual2[a::HxSortParam.Boolean] :: Boolean ;
PG-DefineLessEqual2[a.B_TRUE] → B_TRUE ;
PG-DefineLessEqual2[a.B_FALSE] → B_FALSE ;

// Compare (3) Forms sorted by precedence-tokens.

DLE-Form-Form: PG-DefineLessEqual[D_FORM[#F1, #FK1], D_FORM[#F2, #FK2]] → PG-FormLess[#F1, #F2] ;

    // Local helper to compare forms.
    //
    PG-FormLess[HxForm, HxForm] :: Boolean ;
    //    
    -[Data[#Prec1,#Prec2]]:
    PG-FormLess[Hx_M_FormParsedSorted[#Name1, #ParsedForm1, #Prec1, #InheritedRefs1], Hx_M_FormParsedSorted[#Name2, #ParsedForm2, #Prec2, #InheritedRefs2]]
    →
    $[If, $[NumericEqual, #Prec1, #Prec2], PG-ParsedFormLess[#ParsedForm1, #ParsedForm2], $[If, $[LessThan, #Prec1, #Prec2], B_TRUE, B_FALSE]]
    ;
    //
    -[Data[#Prec1,#Prec2]]:
    PG-FormLess[Hx_M_FormParsed[#ParsedForm1, #Prec1, #InheritedRefs1], Hx_M_FormParsedSorted[#Name2, #ParsedForm2, #Prec2, #InheritedRefs2]]
    →
    $[If, $[NumericEqual, #Prec1, #Prec2], PG-ParsedFormLess[#ParsedForm1, #ParsedForm2], $[If, $[LessThan, #Prec1, #Prec2], B_TRUE, B_FALSE]]
    ;
    //
    -[Data[#Prec1,#Prec2]]:
    PG-FormLess[Hx_M_FormParsedSorted[#Name1, #ParsedForm1, #Prec1, #InheritedRefs1], Hx_M_FormParsed[#ParsedForm2, #Prec2, #InheritedRefs2]]
    →
    $[If, $[NumericEqual, #Prec1, #Prec2], PG-ParsedFormLess[#ParsedForm1, #ParsedForm2], $[If, $[LessThan, #Prec1, #Prec2], B_TRUE, B_FALSE]]
    ;
    //
    -[Data[#Prec1,#Prec2]]:
    PG-FormLess[Hx_M_FormParsed[#ParsedForm1, #Prec1, #InheritedRefs1], Hx_M_FormParsed[#ParsedForm2, #Prec2, #InheritedRefs2]]
    →
    $[If, $[NumericEqual, #Prec1, #Prec2], PG-ParsedFormLess[#ParsedForm1, #ParsedForm2], $[If, $[LessThan, #Prec1, #Prec2], B_TRUE, B_FALSE]]
    ;
    //
    PG-FormLess[Hx_M_FormConstruction[#Constructor1, #ScopeSorts1, #InheritedRefs1], #Form2] → B_FALSE ;
    //
    PG-FormLess[Hx_M_FormParsedSorted[#Name1, #ParsedForm1, #Prec1, #InheritedRefs1], Hx_M_FormConstruction[#Constructor2, #ScopeSorts2, #InheritedRefs2]] → B_TRUE;
    PG-FormLess[Hx_M_FormParsed[#ParsedForm1, #Prec1, #InheritedRefs1], Hx_M_FormConstruction[#Constructor2, #ScopeSorts2, #InheritedRefs2]] → B_TRUE ;

    PG-ParsedFormLess[HxParsedForm, HxParsedForm] :: Boolean ;
    //
    PG-ParsedFormLess[Hx_M_ParsedFormDone, #PF2] → B_FALSE ;
    PG-ParsedFormLess[#PF1, Hx_M_ParsedFormDone] → B_TRUE ;
    //
    PG-ParsedFormLess[Hx_M_ParsedFormWord[#W1, #PF1], Hx_M_ParsedFormTerm[#SSPR2, #PF2]] → B_TRUE ;
    PG-ParsedFormLess[Hx_M_ParsedFormTerm[#SSPR1, #PF1], Hx_M_ParsedFormWord[#W2, #PF2]] → B_FALSE ;
    //
    -[Data[#W1,#W2]]:
    PG-ParsedFormLess[Hx_M_ParsedFormWord[#W1, #PF1], Hx_M_ParsedFormWord[#W2, #PF2]]
    →
    $[If, $[Equal, #W1, #W2], PG-ParsedFormLess[#PF1, #PF2], $[If, $[StringLessThan, #W1, #W2], B_TRUE, B_FALSE]]
    ;
    //
    PG-ParsedFormLess[Hx_M_ParsedFormTerm[#SSPR1, #PF1], Hx_M_ParsedFormTerm[#SSPR2, #PF2]]
    → 
    PG-ParsedFormLess[#PF1, #PF2] // to ensure short come last!
    ;
    //
    PG-ParsedFormLess[Hx_M_ParsedFormSpace[#S1, #PF1], #PF2] → PG-ParsedFormLess[#PF1, #PF2] ; 
    -[Data[#PF1]]: PG-ParsedFormLess[$[NotMatch,Hx_M_ParsedFormSpace[#S1, #_], #PF1], Hx_M_ParsedFormSpace[#W2, #PF2]] → PG-ParsedFormLess[#PF1, #PF2] ;
    //
    ///PG-ParsedFormLess[Hx_M_ParsedFormAttribute[#K1, #N1, #PF1], Hx_M_ParsedFormAttribute[#K2, #N2, #PF2]]
    ///→
    ///PG-ParsedFormLess[#PF1, #PF2] // to ensure short come last!
    ///;

// Compare (4) Rules are not sorted.

DLE-Rule-Rule: PG-DefineLessEqual[D_RULE[#R1, #S1, #D1], D_RULE[#R2, #S2, #D2]] → B_FALSE ;
DLE-Syntesizes-Synthesizes: PG-DefineLessEqual[D_SYNTHESIZES[#A1], D_SYNTHESIZES[#A2]] → B_FALSE ;

// Precedence extraction.

PG-DefinePrec[Define] :: $Numeric;
-[Fresh[dummy::HxSortParam]] : PG-DefinePrec[D_ABSTRACTION[a.#Define[a]]] → PG-DefinePrec[#Define[dummy]] ;
PG-DefinePrec[D_FORM[Hx_M_FormParsedSorted[#Name, #ParsedForm, #Precedence, #InheritedRefs], #Kind]] → #Precedence ;
PG-DefinePrec[D_FORM[Hx_M_FormParsed[#ParsedForm, #Precedence, #InheritedRefs], #Kind]] → #Precedence ;
PG-DefinePrec[D_FORM[Hx_M_FormConstruction[#Constructor, #ScopeSorts, #InheritedRefs], #Kind]] → 0 ;
PG-DefinePrec[D_SYNTHESIZES[#AttributeName]] → 0 ;
PG-DefinePrec[D_RULE[#Rule, #SortName, #IsData]] → 0 ;

// Wrapper extraction.

PG-DefineWrapper[Define, $String<!--SortName-->, Wrapper] :: Wrapper ;
-[Fresh[dummy::HxSortParam]] : PG-DefineWrapper[D_ABSTRACTION[a.#Define[a]], #Name, #Wrapper] → PG-DefineWrapper[#Define[dummy], #Name, #Wrapper] ;
PG-DefineWrapper[D_FORM[Hx_M_FormParsedSorted[#Name, #ParsedForm, #Prec, #InheritedRefs], #Kind], #Name, #Wrapper] → PG-DefineWrapperForm[#ParsedForm, #Prec, #Kind, #Name, #Wrapper] ;
PG-DefineWrapper[D_FORM[Hx_M_FormParsed[#ParsedForm, #Prec, #InheritedRefs], #Kind], #Name, #Wrapper] → PG-DefineWrapperForm[#ParsedForm, #Prec, #Kind, #Name, #Wrapper] ;

PG-DefineWrapper[D_FORM[Hx_M_FormConstruction[#Constructor, #ScopeSorts, #InheritedRefs], #Kind], #Name, #Wrapper] →  #Wrapper ;
PG-DefineWrapper[D_SYNTHESIZES[#AttributeName], #Name, #Wrapper] → #Wrapper ;
PG-DefineWrapper[D_RULE[#Rule, #SortName, #IsData], #Name, #Wrapper] → #Wrapper ;

PG-DefineWrapperForm[HxParsedForm, $Numeric, FormKind, $String<!--SortName-->, Wrapper] :: Wrapper ;
PG-DefineWrapperForm[#ParsedForm, #Prec, FK_SUGAR[#Term], #Name, #OldWrapper] → PG-DefineWrapperSugar[#ParsedForm, $False<!--NotCandidate-->, #ParsedForm, #Prec, #Term, #Name, #OldWrapper] ;
PG-DefineWrapperForm[#ParsedForm, #Prec, $[NotMatch,FK_SUGAR[#Term],#Kind], #Name, #OldWrapper] → #OldWrapper ;

PG-DefineWrapperSugar[HxParsedForm, $Boolean<!--IsCandidate-->, HxParsedForm, $Numeric<!--Prec-->, HxTerm, $String<!--SortName-->, Wrapper] :: Wrapper ;

-[Data[#Prec1,#Prec]]:
PG-DefineWrapperSugar[Hx_M_ParsedFormTerm[Hx_M_ScopeSortPrecRepeat[#ScopeSort1, #Prec1, #Repeat1], #ParsedForm1], #Candidate, #TopParsedForm, #TopPrec, #TopTerm, #Name, #OldWrapper]
→
$[If, #Candidate,
  #OldWrapper, // not a candidate anyway (has at least two nonterminals)
  $[If, $[LessThan, #TopPrec, #Prec1],
    #OldWrapper, // not a candidate anyway (inner has higher precedence than outer)
    PG-DefineWrapperSugar[#ParsedForm1, $True, #TopParsedForm, #TopPrec, #TopTerm, #Name, #OldWrapper]
]];
// TODO: include #Name in comparison. 

PG-DefineWrapperSugar[Hx_M_ParsedFormWord[#Word, #ParsedForm], #Candidate, #TopParsedForm, #TopPrec, #TopTerm, #Name, #OldWrapper]
→
PG-DefineWrapperSugar[#ParsedForm, #Candidate, #TopParsedForm, #TopPrec, #TopTerm, #Name, #OldWrapper]
;

PG-DefineWrapperSugar[Hx_M_ParsedFormSpace[#Space, #ParsedForm], #Candidate, #TopParsedForm, #TopPrec, #TopTerm, #Name, #OldWrapper]
→
PG-DefineWrapperSugar[#ParsedForm, #Candidate, #TopParsedForm, #TopPrec, #TopTerm, #Name, #OldWrapper]
;

PG-DefineWrapperSugar[Hx_M_ParsedFormDone, $False, #TopParsedForm, #TopPrec, #TopTerm, #Name, #OldWrapper] → #OldWrapper ;
PG-DefineWrapperSugar[Hx_M_ParsedFormDone, $True,  #TopParsedForm, #TopPrec, #TopTerm, #Name, #OldWrapper] → WRAPPER[#TopParsedForm] ;


/////////////////////////////////////////////////////////////////////
// 4. TEXT OF ALL PG NON-TERMINAL PRODUCTIONS.
//
// Productions are extracted by sort and for each sort grouped by precedence,
// each group producing a PG production.

// Iterate through all productions.

{$String<!--SortName--> : DeclarationMapEntry} PG-Productions[$String<!--ModuleName-->] :: Text;
{#DM; "$AllSortNames" : DME_NAMES[#Names]} PG-Productions[#ModuleName] → {#DM} PG-Productions0[#ModuleName, #Names] ;

{$String<!--SortName--> : DeclarationMapEntry} PG-Productions0[$String<!--ModuleName-->, NameSet] :: Text;
{#DM} PG-Productions0[#ModuleName, #Names] → {#DM} PG-Productions1[HasNames[#Names], #ModuleName, #Names] ;

{$String<!--SortName--> : DeclarationMapEntry} PG-Productions1[Boolean, $String<!--ModuleName-->, NameSet] :: Text;
{#DM} PG-Productions1[B_TRUE , #ModuleName, #Names] → %n⟪« {#DM} PG-Production[#ModuleName, FirstName[#Names]] »« {#DM} PG-Productions0[#ModuleName, RemoveFirstName[#Names]] »⟫ ;
{#DM} PG-Productions1[B_FALSE, #ModuleName, #Names] → %n⟪⟫ ;

// Emit text for one production.

{$String<!--Name--> : DeclarationMapEntry} PG-Production[$String<!--ModuleName-->, $String<!--Name-->] :: Text;
-[Data[#Name]]:
{#DM} PG-Production[#ModuleName, #Name] 
→
{#DM} PG-Production1[#ModuleName, $[{#DM}Get, #Name, DME_NONE]]
;

{$String<!--SortName--> : DeclarationMapEntry} PG-Production1[$String<!--ModuleName-->, DeclarationMapEntry] :: Text;

{#DM} PG-Production1[#ModuleName, DME_NONE]
→
%n⟪⟫
;

{#DM}
PG-Production1[#ModuleName, DME_TOKEN[#SortName]]
→
%n⟪

/* Productions for †«#SortName» token. */

«PG-GenerateNonterminalDeclaration[PG-ProductionNameText[#SortName], %n⟨‹ {#DM}PG-MetaHead[B_TRUE, #ModuleName, #SortName, #SortName, B_FALSE, 0]›(‹PG-TokenNameText[#SortName]›$)⟩]»
« {#DM}PG-MetaTail[B_TRUE, #SortName, #SortName] »
/***METAPG: /* Hx terms of †«#SortName» token sort. */ ***/
/***METAPG: <USER_†«#SortName»> (Hx) ::= (HX_TOKEN_†«#SortName»)?  <USER_Presorted_†«#SortName»> . ***/
/***METAPG: <USER_Sorted_†«#SortName»> (Hx) ::= HX_TOKEN_†«#SortName» <USER_Presorted_†«#SortName»> . ***/
/***METAPG: <USER_Presorted_†«#SortName»> (Hx) ::= ***/
/***METAPG:   {Hx_M_VariableUseSorted} ({†«#SortName»}) ({Hx_M_RepeatSingle}) (HX_VARIABLE!!!) <USER_Attributes> ***/
/***METAPG: | {Hx_M_MetaApplicationSorted} ({†«#SortName»}) ({Hx_M_RepeatSingle}) (HX_META_VARIABLE$) ( HX_LBRACKET <USER_Terms>  HX_RBRACKET | {$Nil} ) <USER_Attributes> ***/
/***METAPG: | {Hx_M_UnparsedSorted} ({†«#SortName»}) ({Hx_M_RepeatSingle}) (HX_CONCRETE$:unconcrete) <USER_Attributes> ***/
/***METAPG: . ***/
/***METAPG: token HX_TOKEN_†«#SortName» (Hx) ::= "†«#SortName»" . ***/
⟫
;

PG-GenerateNonterminalDeclaration[Text, Text] → Text;
PG-GenerateNonterminalDeclaration[#Name, #Alternatives] → %n⟪<«#Name»> /***METAPG:(USER)***/ ::= ⟦«#Alternatives»⟧ .⟫ ;
//TODO: use for all production declarations.

{#DM} PG-Production1[#ModuleName, DME_ATTRIBUTE[#Kind, #Name, #AttributeForm, #AttributeOptions]]
→
PG-Production-Attribute[#ModuleName, #Kind, #Name, #AttributeForm, #AttributeOptions]
;

    // Handle an attribute definition.

    PG-Production-Attribute[$String<!--ModuleName-->, HxAttributeKind, $String, HxAttributeForm, $List[HxAttributeOption]] :: Text;
    PG-Production-Attribute[#ModuleName, #Kind, #Name, #AttributeForm, #AttributeOptions]
    →
    %n⟪
    /***METAPG: <USER_Attribute« AttributeKindCategory[#Kind] »_†«#Name»> (Hx) ::= {Hx_M_Attribute} « AttributeKindIndicator[#Kind] » (HX_TOKEN_†«#Name»$) « AttributeFormSyntax[#ModuleName, #AttributeForm, #AttributeOptions] » . ***/
    /***METAPG: token HX_TOKEN_†«#Name» (Hx) ::= "†«#Name»" .  ***/
    ⟫
    ;

    AttributeKindCategory[HxAttributeKind] :: Text ;
    AttributeKindCategory[%rawHxAttributeKind⟪ ↑ ⟫] → %n⟪Synthesized⟫ ;
    AttributeKindCategory[%rawHxAttributeKind⟪ ↓ ⟫] → %n⟪Inherited⟫ ;

    AttributeKindIndicator[HxAttributeKind] :: Text ;
    AttributeKindIndicator[%rawHxAttributeKind⟪ ↑ ⟫] → %n⟪({Hx_M_AttributeKindUp})⟫ ;
    AttributeKindIndicator[%rawHxAttributeKind⟪ ↓ ⟫] → %n⟪({Hx_M_AttributeKindDown})⟫ ;

    AttributeFormSyntax[$String<!--ModuleName-->, HxAttributeForm, $List[HxAttributeOption]] :: Text ;
    AttributeFormSyntax[#ModuleName, %rawHxAttributeForm⟪ ( #HxSort# ) ⟫, #AttributeOptions] → %n⟪HX_LPAREN {Hx_M_AttributeValue} <USER_†« PG-SortName[#HxSort#] »> HX_RPAREN⟫ ;
    AttributeFormSyntax[#ModuleName, %rawHxAttributeForm⟪ { #HxSort# } ⟫, #AttributeOptions] → %n⟪HX_LBRACE {Hx_M_AttributeKey} <USER_†« PG-SortName[#HxSort#] »> HX_RBRACE⟫ ;
    AttributeFormSyntax[#ModuleName, %rawHxAttributeForm⟪ { #HxSort1# : #HxSort2# } ⟫, #AttributeOptions] → %n⟪HX_LBRACE {Hx_M_AttributeKeyValue} <USER_†« PG-SortName[#HxSort1#] »> HX_COLON <USER_†« PG-SortName[#HxSort2#] »> HX_RBRACE⟫ ;

    AttributeKindToken[HxAttributeKind] :: Text ;
    AttributeKindToken[%rawHxAttributeKind⟪ ↑ ⟫] → %n⟪HX_UP⟫ ;
    AttributeKindToken[%rawHxAttributeKind⟪ ↓ ⟫] → %n⟪HX_DOWN⟫ ;

{#DM} PG-Production1[#ModuleName, DME_SORT[#Defines, #SortName, #Precs, #Wrapper, #IsMain]]
→
%n⟪« {#DM} PG-Production-Defines[#ModuleName, #Defines, #SortName, 0, ()] »« {#DM} PG-Production-HxDefines[#ModuleName, #Defines, #SortName] »⟫
;

// Handle a sort definition.

{$String<!--SortName--> : DeclarationMapEntry} PG-Production-Defines[$List[Define], $String, $Numeric, $List[PFK_SORT]] :: Text;

// Helper for ParsedForm and FK.
PFK_SORT ::=( PFK[HxParsedForm, FormKind]; );

{#DM} PG-Production-Defines[#ModuleName, (), #SortName, #Prec, ()]
→
%n⟪⟫
;

{#DM} PG-Production-Defines[#ModuleName, (), #SortName, #Prec, (#PFK1;#PFKs)]
→
%n⟪

/* Productions for †«#SortName» sort with (highest) precedence †«$[FormatNumber,#Prec]». */
« {#DM} PG-Expand[#ModuleName, (#PFK1;#PFKs), #SortName, #Prec, B_TRUE] »⟫
;

-[Fresh[dummy::HxSortParam]]:
{#DM} PG-Production-Defines[#ModuleName, (D_ABSTRACTION[a.#Define1[a]]; #Defines), #SortName, #Prec, #PrecPFKs]
→
{#DM} PG-Production-Defines[#ModuleName, (#Define1[dummy]; #Defines), #SortName, #Prec, #PrecPFKs]
;

{#DM} PG-Production-Defines[#ModuleName, (D_RULE[#Rule, #RuleSort, #IsData]; #Defines), #SortName, #Prec, #PrecPFKs]
→
{#DM} PG-Production-Defines[#ModuleName, #Defines, #SortName, #Prec, #PrecPFKs]
;

{#DM} PG-Production-Defines[#ModuleName, (D_FORM[#Form1, #Kind1]; #Defines), #SortName, #Prec, #PrecPFKs]
→
{#DM} PG-Production-Defines2[#ModuleName, #Form1, #Kind1, #Defines, #SortName, #Prec, #PrecPFKs]
;

{#DM} PG-Production-Defines[#ModuleName, (D_SYNTHESIZES[#AttributeName1]; #Defines), #SortName, #Prec, #PrecPFKs]
→
{#DM} PG-Production-Defines[#ModuleName, #Defines, #SortName, #Prec, #PrecPFKs]
;

{$String<!--SortName--> : DeclarationMapEntry} PG-Production-Defines2[HxForm, FormKind, $List[Define], $String, $Numeric, $List[PFK_SORT]] :: Text;

{#DM} PG-Production-Defines2[#ModuleName, Hx_M_FormParsedSorted[#Sort1, #ParsedForm1, #Prec1, #InheritedRefs], #Kind1, #Defines, #SortName, #Prec, #PrecPFKs]
→
{#DM} PG-Production-Defines3[#ModuleName, #ParsedForm1, #Prec1, #Kind1, #Defines, #SortName, #Prec, #PrecPFKs]
;

{#DM} PG-Production-Defines2[#ModuleName, Hx_M_FormParsed[#ParsedForm1, #Prec1, #InheritedRefs], #Kind1, #Defines, #SortName, #Prec, #PrecPFKs]
→
{#DM} PG-Production-Defines3[#ModuleName, #ParsedForm1, #Prec1, #Kind1, #Defines, #SortName, #Prec, #PrecPFKs]
;

{#DM} PG-Production-Defines2[#ModuleName, Hx_M_FormConstruction[#Constructor, #ScopeSortList, #InheritedRefs], #Kind1, #Defines, #SortName, #Prec, #PrecPFKs]
→
{#DM} PG-Production-Defines[#ModuleName, #Defines, #SortName, #Prec, #PrecPFKs]
;

{$String<!--SortName--> : DeclarationMapEntry} PG-Production-Defines3[HxParsedForm, $Numeric, FormKind, $List[Define], $String, $Numeric, $List[PFK_SORT]] :: Text;

-[Data[#Prec1,#Prec],Share[#ParsedForm1,#Kind1,#Defines]]:
{#DM} PG-Production-Defines3[#ModuleName, #ParsedForm1, #Prec1, #Kind1, #Defines, #SortName, #Prec, ()]
→
$[If, $[NumericEqual,#Prec1,#Prec],
  {#DM} PG-Production-Defines[#ModuleName, #Defines, #SortName, #Prec, (PFK[#ParsedForm1, #Kind1];)],
  %n⟪
<«PG-ProductionNameWithPrecText[#SortName,#Prec]»> /***METAPG:(USER)***/ ::= <«PG-ProductionNameWithPrecText[#SortName,#Prec1]»> .
« {#DM} PG-Production-Defines[#ModuleName, #Defines, #SortName, #Prec1, (PFK[#ParsedForm1, #Kind1];)] »⟫]
;

-[Data[#Prec1,#Prec],Share[#ParsedForm1,#Kind1,#Defines,#PFK,#PFKs]]:
{#DM} PG-Production-Defines3[#ModuleName, #ParsedForm1, #Prec1, #Kind1, #Defines, #SortName, #Prec, (#PFK;#PFKs)]
→
$[If, $[NumericEqual,#Prec1,#Prec],
  {#DM} PG-Production-Defines[#ModuleName, #Defines, #SortName, #Prec, Append[(#PFK;#PFKs), (PFK[#ParsedForm1, #Kind1];)]],
  %n⟪/* Productions for †«#SortName» sort with precedence †«$[FormatNumber,#Prec]». */
« {#DM} PG-Expand[#ModuleName, (#PFK;#PFKs), #SortName, #Prec, B_FALSE] »
« {#DM} PG-Production-Defines[#ModuleName, #Defines, #SortName, #Prec1, (PFK[#ParsedForm1, #Kind1];)] »
⟫]
;

{$String<!--SortName--> : DeclarationMapEntry} PG-Production-HxDefines[$String<!--<ModuleName-->, $List[Define], $String] :: Text;

{#DM}
PG-Production-HxDefines[#ModuleName, #Defines, #SortName]
→
%n⟪
/***METAPG: /* Hx terms of †«#SortName» production sort. */ ***/
/***METAPG: <USER_†«#SortName»> (Hx) ::= (HX_TOKEN_†«#SortName»)?  <USER_Presorted_†«#SortName»> . ***/
/***METAPG: <USER_Sorted_†«#SortName»> (Hx) ::= HX_TOKEN_†«#SortName» <USER_Presorted_†«#SortName»> . ***/
/***METAPG: <USER_Presorted_†«#SortName»> (Hx) ::= ***/
/***METAPG:   {Hx_M_VariableUseSorted} ({†«#SortName»}) ({Hx_M_RepeatSingle}) (HX_VARIABLE!!!) <USER_Attributes> ***/
/***METAPG: | {Hx_M_MetaApplicationSorted} ({†«#SortName»}) ({Hx_M_RepeatSingle}) (HX_META_VARIABLE$) ( HX_LBRACKET <USER_Terms> HX_RBRACKET | {$Nil} ) <USER_Attributes> ***/
/***METAPG: | {Hx_M_ConstructionSorted} ({†«#SortName»}) ({Hx_M_RepeatSingle}) (HX_CONSTRUCTOR$) ( HX_LBRACKET <USER_Scopes> HX_RBRACKET | HX_LPAREN <USER_Terms> HX_RPAREN | {$Nil} ) <USER_Attributes> ***/
/***METAPG: | {Hx_M_UnparsedSorted} ({†«#SortName»}) ({Hx_M_RepeatSingle}) (HX_CONCRETE$:unconcrete) <USER_Attributes> ***/
/***METAPG: « {#DM} PG-Production-HxDefines1[#ModuleName, #Defines, #SortName] » ***/
/***METAPG: . ***/
/***METAPG: token HX_TOKEN_†«#SortName» (Hx) ::= "†«#SortName»" . ***/
/***METAPG: « {#DM} PG-Production-HxDefinesTokens[#ModuleName, #Defines, #SortName] » ***/

⟫;

{$String<!--SortName--> : DeclarationMapEntry} PG-Production-HxDefines1[$String<!--ModuleName-->, $List[Define], $String] :: Text;

-[Fresh[dummy::HxSortParam]]:
{#DM} PG-Production-HxDefines1[#ModuleName, (D_ABSTRACTION[a.#Define1[a]]; #Defines), #SortName]
→
{#DM} PG-Production-HxDefines1[#ModuleName, (#Define1[dummy]; #Defines), #SortName]
;

{#DM} PG-Production-HxDefines1[#ModuleName, (D_RULE[#Rule, #RuleSort, #IsData]; #Defines), #SortName]
→
{#DM} PG-Production-HxDefines1[#ModuleName, #Defines, #SortName]
;

{#DM} PG-Production-HxDefines1[#ModuleName, (D_FORM[#Form1, #Kind1]; #Defines), #SortName]
→
%n⟪« {#DM} PG-Production-HxForm[#ModuleName, #Form1, #Kind1, #SortName] »« {#DM} PG-Production-HxDefines1[#ModuleName, #Defines, #SortName] »⟫
;

{#DM} PG-Production-HxDefines1[#ModuleName, (D_SYNTHESIZES[#AttributeName1]; #Defines), #SortName]
→
{#DM} PG-Production-HxDefines1[#ModuleName, #Defines, #SortName]
;

{#DM} PG-Production-HxDefines1[#ModuleName, (), #SortName]
→
%n⟪⟫
;

{$String<!--SortName--> : DeclarationMapEntry} PG-Production-HxForm[HxForm, FormKind, $String] :: Text;

{#DM} PG-Production-HxForm[#ModuleName, Hx_M_FormParsedSorted[#Sort1, #ParsedForm1, #Prec1, #InheritedRefs], #Kind1, #SortName]
→
%n⟪⟫
;

{#DM} PG-Production-HxForm[#ModuleName, Hx_M_FormParsed[#ParsedForm1, #Prec1, #InheritedRefs], #Kind1, #SortName]
→
%n⟪⟫
;

{#DM} PG-Production-HxForm[#ModuleName, Hx_M_FormConstruction[#Constructor, #ScopeSortList, #InheritedRefs], #Kind1, #SortName]
→
%n⟪| HX_TOKEN_†«#Constructor»$ « IfEmpty[#ScopeSortList, %n⟨( HX_LPAREN HX_RPAREN )? ⟩, %n⟨ HX_LPAREN ‹ {#DM} PG-Production-HxScopeSortList[#ModuleName, #ScopeSortList, #SortName, B_TRUE] › HX_RPAREN ⟩] »
⟫;

{$String<!--SortName--> : DeclarationMapEntry} PG-Production-HxScopeSortList[$List[HxScopeSort], $String, Boolean] :: Text;

{#DM} PG-Production-HxScopeSortList[#ModuleName, (%rawHxScopeSort⟪ #HxSort# #HxRepeat# [ #HxSubstituteSorts# ] ⟫ ; #ScopeSortList), #SortName, #first]
→
%n⟪« If[#first, %n⟨⟩, %n⟨ HX_COMMA ⟩] »« {#DM} PG-Production-HxScopeSort[#ModuleName, #HxSort#, #HxSubstituteSorts#, #SortName] »« {#DM} PG-Production-HxScopeSortList[#ModuleName, #ScopeSortList, #SortName, B_FALSE] »⟫
;  //note: ignores #Repeat because arguments to Hx terms cannot use repeat-forms...or should they?

-[Free[v::Text]]:
{#DM} PG-Production-HxScopeSortList[#ModuleName, (%rawHxBindersScopeSort⟪ [ v : #HxSort# ] #HxBindersScopeSort# ⟫ ; #ScopeSortList), #SortName, #first]
→
{#DM} PG-Production-HxScopeSortList[#ModuleName, (#HxBindersScopeSort# ; #ScopeSortList), #SortName, #first]
;

-[Free[v::Text]]:
{#DM} PG-Production-HxScopeSortList[#ModuleName, (%rawHxScopeSort⟪ [ v : #HxSort# ] ⟫ ; #ScopeSortList), #SortName, #first]
→
$[Error, "There should not be binder subterm sorts."]
;

{#DM} PG-Production-HxScopeSortList[#ModuleName, (), #SortName, #first] → %n⟪⟫ ;

{$String<!--SortName--> : DeclarationMapEntry} PG-Production-HxScopeSort[HxSort, $List[HxSubstituteSort], $String] :: Text;

{#DM} PG-Production-HxScopeSort[#ModuleName, #HxSort#, #HxSubstituteSorts#, #SortName]
→
IfEmpty[#HxSubstituteSorts#,
  %n⟪<USER_†«PG-SortName[#HxSort#]»>⟫,
  %n⟪« {#DM}PG-Production-HxScope[#ModuleName, #HxSubstituteSorts#, %n⟨<USER_†‹PG-SortName[#HxSort#]›>⟩, %n⟨⟩, %n⟨HX_LBRACKET⟩, %n⟨[⟩] »⟫]  //start:[
;

{$String<!--SortName--> : DeclarationMapEntry} PG-Production-HxScope[$List[HxSubstituteSort], Text, Text, Text, Text] :: Text;

-[Fresh[x::Text]]:
{#DM}PG-Production-HxScope[#ModuleName, (#SubstituteSort ; #SubstituteSorts), #SortRef, #ScopedVars, #sep, #argsep]
→ 
%n⟪ «#sep» HX_VARIABLE^«x» « {#DM}PG-Production-HxScope[#ModuleName, #SubstituteSorts, #SortRef, %n⟨‹#ScopedVars›‹#argsep›‹x›⟩, %n⟨HX_COMMA⟩, %n⟨¸⟩] »⟫
; 

{#DM}PG-Production-HxScope[#ModuleName, (), #SortRef, #ScopedVars, #sep, #argsep] → %n⟪ HX_RBRACKET « #SortRef »« #ScopedVars »]⟫ ;  //end:]

{$String<!--SortName--> : DeclarationMapEntry} PG-Production-HxDefinesTokens[#ModuleName, $List[Define], $String] :: Text;

-[Fresh[dummy::HxSortParam]]:
{#DM} PG-Production-HxDefinesTokens[#ModuleName, (D_ABSTRACTION[a.#Define1[a]]; #Defines), #SortName]
→
{#DM} PG-Production-HxDefinesTokens[#ModuleName, (#Define1[dummy]; #Defines), #SortName]
;

{#DM} PG-Production-HxDefinesTokens[#ModuleName, (D_RULE[#Rule, #RuleSort, #IsData]; #Defines), #SortName]
→
{#DM} PG-Production-HxDefinesTokens[#ModuleName, #Defines, #SortName]
;

{#DM} PG-Production-HxDefinesTokens[#ModuleName, (D_FORM[#Form1, #Kind1]; #Defines), #SortName]
→
%n⟪« {#DM} PG-Production-HxFormToken[#ModuleName, #Form1, #Kind1, #SortName] »« {#DM} PG-Production-HxDefinesTokens[#ModuleName, #Defines, #SortName] »⟫
;

{#DM} PG-Production-HxDefinesTokens[#ModuleName, (D_SYNTHESIZES[#AttributeName1]; #Defines), #SortName]
→
{#DM} PG-Production-HxDefinesTokens[#ModuleName, #Defines, #SortName]
;

{#DM} PG-Production-HxDefinesTokens[#ModuleName, (), #SortName]
→
%n⟪⟫
;

{$String<!--SortName--> : DeclarationMapEntry} PG-Production-HxFormToken[HxForm, FormKind, $String] :: Text;
{#DM} PG-Production-HxFormToken[#ModuleName, Hx_M_FormParsedSorted[#Sort1, #ParsedForm1, #Prec1, #InheritedRefs], #Kind1, #SortName] → %n⟪⟫ ;
{#DM} PG-Production-HxFormToken[#ModuleName, Hx_M_FormParsed[#ParsedForm1, #Prec1, #InheritedRefs], #Kind1, #SortName] → %n⟪⟫ ;
{#DM} PG-Production-HxFormToken[#ModuleName, Hx_M_FormConstruction[#Constructor, #ScopeSortList, #InheritedRefs], #Kind1, #SortName] → %n⟪token HX_TOKEN_†«#Constructor» (Hx) ::= "†«#Constructor»" .
⟫;


// Meta-definitions for sorts.

{$String<!--SortName--> : DeclarationMapEntry} PG-MetaHead[Boolean, $String<!--ModuleName-->, $String, $String, Boolean, $Numeric] :: Text;

PG-MetaHead[B_FALSE, #ModuleName, #SortName, #Name, #isLeftRecursive, #Prec] → %n⟪⟫ ;

-[Data[#SortName],Discard[#Prec]]:
{#DM}
PG-MetaHead[B_TRUE, #ModuleName, #SortName, #Name, B_FALSE, #Prec] →
 %n⟪
/***METAPG: meta_« PG-TokenNameText[#Name] »:unconcrete:{%%%PREFIX%%%HxTerm} | ***/
⟫ ;

-[Data[#SortName]]:
{#DM}
PG-MetaHead[B_TRUE, #ModuleName, #SortName, #Name, B_TRUE, #Prec] →
 %n⟪
/***METAPG: meta_« PG-TokenNameText[#Name] »:unconcrete:{%%%PREFIX%%%HxTerm}:#1 <« PG-ProductionNameWithPrecText[#SortName, #Prec] »LR #1> | ***/
⟫ ;


PG-MetaTail[Boolean, $String, $String] :: Text;

PG-MetaTail[B_FALSE, #SortName, #Name] → %n⟪⟫ ;

-[Data[#SortName]]: PG-MetaTail[B_TRUE, #SortName, #Name] → %n⟪
/***METAPG: %{ ***/
/***METAPG: /* Meta token for embedded user †«#SortName». */  ***/
/***METAPG: <USER> MORE : { < "\u27e8" (" ")* †« Stringify[#SortName] » (" ")* ~["\u27e8","\u27e9"] > { nesting = 0; nestedState = curLexState; } : USER_IN_META_«PG-TokenNameText[#Name]» } ***/
/***METAPG: <USER_IN_META_«PG-TokenNameText[#Name]»> MORE : { "\u27e8" { nesting = 1; } : USER_IN_NESTED_META_«PG-TokenNameText[#Name]» } ***/
/***METAPG: <USER_IN_NESTED_META_«PG-TokenNameText[#Name]»> MORE : { "\u27e8" { nesting++; } } ***/
/***METAPG: <USER_IN_NESTED_META_«PG-TokenNameText[#Name]»> MORE : { "\u27e9" { if (--nesting <= 0) SwitchTo(USER_IN_META_«PG-TokenNameText[#Name]»); } } ***/
/***METAPG: <USER_IN_META_«PG-TokenNameText[#Name]»> TOKEN : { < T_meta_«PG-TokenNameText[#Name]» : "\u27e9" > { SwitchTo(nestedState); } } ***/
/***METAPG: <USER_IN_META_«PG-TokenNameText[#Name]»,USER_IN_NESTED_META_«PG-TokenNameText[#Name]»> MORE : { < ~[] > } ***/
/***METAPG: %} ***/
⟫ ;



// Text of single sort+precedence production expansion.
//
// Emits the left recursion handler, if any, and the PG grammar production
// for the sort+precedence combination, with left factored buffering.

CONSUMPTION_SORT ::=( C_BUFFER[$String<!--SortName-->, $Numeric<!--precedence-->]; C_LEFTRECURSIVE[$String<!--SortName-->, $Numeric<!--precedence-->]; <!--C_INLINE;--> );
/// C_INLINE DISABLED.

{$String<!--SortName--> : DeclarationMapEntry} PG-Expand[$List[PFK_SORT], $String, $Numeric, Boolean<!--Last-->] :: Text;
{#DM} PG-Expand[#ModuleName, #PrecPFKs, #SortName, #Prec, #Last?]
→
{#DM} PG-LeftRecursive[#ModuleName, #PrecPFKs, #SortName, #Prec, #Last?, (), ()]
;

// Generate optional left recursion production helper, normal production, and optional meta-production.

{$String<!--SortName--> : DeclarationMapEntry} PG-LeftRecursive[$List[PFK_SORT], $String, $Numeric, Boolean, $List[PFK_SORT], $List[PFK_SORT]] :: Text;
{$String<!--SortName--> : DeclarationMapEntry} PG-LeftRecursive2[Boolean, PFK_SORT, $List[PFK_SORT], $String, $Numeric, Boolean, $List[PFK_SORT], $List[PFK_SORT]] :: Text;

{#DM} PG-LeftRecursive[#ModuleName, (#PFK1; #PFKs), #SortName, #Prec, #Last?, #LeftRecursivePFKs, #OtherPFKs]
→
{#DM} PG-LeftRecursive2[#ModuleName, PG-isLeftRecursive[#SortName, #Prec, #PFK1], #PFK1, #PFKs, #SortName, #Prec, #Last?, #LeftRecursivePFKs, #OtherPFKs]
;

    // HAND-CODED HACK to recognize and strip left recursive production (because Hx.pg cannot match parsed forms...). 

    PG-isLeftRecursive[$String, $Numeric, PFK_SORT] :: Boolean;

    PG-isLeftRecursive[#SortName, #Prec, PFK[Hx_M_ParsedFormSpace[#Space, #ParsedForm1], #Kind]]
    →
    PG-isLeftRecursive[#SortName, #Prec, PFK[#ParsedForm1, #Kind]]
    ;

    PG-isLeftRecursive[#SortName, #Prec, PFK[Hx_M_ParsedFormWord[#Word, #ParsedForm1], #Kind]]
    →
    B_FALSE
    ;

    -[Data[#Sort]]:
    PG-isLeftRecursive[#SortName, #Prec, PFK[Hx_M_ParsedFormTerm[Hx_M_ScopeSortPrecRepeat[#Sort1, #Prec1, #Repeat1], #ParsedForm1], #Kind]]
    →
    $[If, $[NumericEqual,#Prec,#Prec1], PG-isLeftRecursive1[#SortName, #Sort1], B_FALSE]
    ;

    PG-isLeftRecursive[#SortName, #Prec, PFK[Hx_M_ParsedFormDone, #Kind]]
    →
    B_FALSE
    ;

    PG-isLeftRecursive1[$String, HxScopeSort] :: Boolean;

    PG-isLeftRecursive1[#SortName,
      Hx_M_ScopeSort[
	Hx_M_Sort[Hx_M_SortName[#SortName1, #_1], '$Nil'],
	Hx_M_RepeatSingle,
	'$Nil']]
    →
    SameString[#SortName,#SortName1]
    ;

    -[Data[#Kind]]:
    PG-isLeftRecursive1[#SortName, $[NotMatch,
      Hx_M_ScopeSort[
	Hx_M_Sort[Hx_M_SortName[#SortName1, #_1], '$Nil'],
	Hx_M_RepeatSingle,
	'$Nil'],#_]]
    →
    B_FALSE
    ;

    PG-stripLeftRecursion[PFK_SORT] :: PFK_SORT;
    PG-stripLeftRecursion[PFK[Hx_M_ParsedFormSpace[#Space, #ParsedForm1], #Kind]]
    →
    PG-stripLeftRecursion[PFK[#ParsedForm1, #Kind]]
    ;
    PG-stripLeftRecursion[
      PFK[
	Hx_M_ParsedFormTerm[
	  Hx_M_ScopeSortPrecRepeat[
	    Hx_M_ScopeSort[
	      Hx_M_Sort[Hx_M_SortName[#SortName, #_], '$Nil'],
	      Hx_M_RepeatSingle,
	      '$Nil'],
	    #Prec,
	    #Repeat],
	      #ParsedForm],
	#Kind]]
    →
    PFK[#ParsedForm, #Kind]
    ;





{#DM} PG-LeftRecursive2[#ModuleName, B_TRUE, #PFK1, #PFKs, #SortName, #Prec, #Last?, #LeftRecursivePFKs, #OtherPFKs]
→
{#DM} PG-LeftRecursive[#ModuleName, #PFKs, #SortName, #Prec, #Last?, Append[#LeftRecursivePFKs, (PG-stripLeftRecursion[#PFK1];)], #OtherPFKs]
;

{#DM} PG-LeftRecursive2[#ModuleName, B_FALSE, #PFK1, #PFKs, #SortName, #Prec, #Last?, #LeftRecursivePFKs, #OtherPFKs]
→
{#DM} PG-LeftRecursive[#ModuleName, #PFKs, #SortName, #Prec, #Last?, #LeftRecursivePFKs, Append[#OtherPFKs, (#PFK1;)]]
;

{#DM} PG-LeftRecursive[#ModuleName, (), #SortName, #Prec, #Last?, #LeftRecursivePFKs, #OtherPFKs]
→
IfEmpty[#LeftRecursivePFKs,
  // There is no left recursion -- use the plain expansion.
  {#DM} PG-Produce[#ModuleName, #SortName, #Prec, #Last?, #OtherPFKs, C_BUFFER[#SortName, #Prec]],
  // There is left recursion...
  {#DM} PG-ProduceBody[#ModuleName, #SortName, #LeftRecursivePFKs, 2, (%n⟨#1⟩;), (%n⟨LR⟩;), C_LEFTRECURSIVE[#SortName, #Prec], in funs tags after .
    %n⟪/* Handle left recursion. */
<«PG-ProductionNameWithPrecText[#SortName, #Prec]»LR #1> /***METAPG:(USER)***/ ::= ⟦«in»
| {{#1}}⟧
.
/***SORTS: †«PG-QN[#ModuleName, "NodeSort", #SortName]» ::= ( «tags» ); ***/

«funs»
« TextJoinMap[after, %n⟨
⟩] »
« {#DM} PG-Produce[#ModuleName, #SortName, #Prec, #Last?, #OtherPFKs, C_LEFTRECURSIVE[#SortName, #Prec]] »⟫]]
;

{$String<!--SortName--> : DeclarationMapEntry} PG-Produce[$String<!--ModuleName-->, $String<!--SortName-->, $Numeric<!--Prec-->, Boolean<!--Last?-->, $List[PFK_SORT], CONSUMPTION_SORT] :: Text;

{#DM} PG-Produce[#ModuleName, #SortName, #Prec, #Last?, #PFKs, C_LEFTRECURSIVE[#SortName9, #Prec9]]
→
{#DM} PG-ProduceBody[#ModuleName, #SortName, #PFKs, 1, (), (), C_LEFTRECURSIVE[#SortName9, #Prec9], in funs tags after .
  %n⟪
<«PG-ProductionNameWithPrecText[#SortName, #Prec]»> /***METAPG:(USER)***/ ::= ⟦« {#DM}PG-MetaHead[#Last?, #ModuleName, #SortName, #SortName, B_TRUE, #Prec] »«in»⟧ .

/***SORTS: †«PG-QN[#ModuleName, "NodeSort", #SortName]» ::= ( «tags» ); ***/
«funs»
« {#DM}PG-MetaTail[#Last?, #SortName, #SortName] »« TextJoinMap[after, %n⟨
⟩] »⟫]
;

-[Data[#consumer]]:
{#DM} PG-Produce[#ModuleName, #SortName, #Prec, #Last?, #PFKs, $[NotMatch,C_LEFTRECURSIVE[#_SortName, #_Prec],#consumer]]
→
{#DM} PG-ProduceBody[#ModuleName, #SortName, #PFKs, 1, (), (), #consumer, in funs tags after .
  %n⟪
<«PG-ProductionNameWithPrecText[#SortName,#Prec]»> /***METAPG:(USER)***/ ::= ⟦« {#DM}PG-MetaHead[#Last?, #ModuleName, #SortName, #SortName, B_FALSE, #Prec] »«in» .⟧ 

« PG-TagSortDeclaration[#ModuleName, #SortName, funs, tags] »
« {#DM}PG-MetaTail[#Last?, #SortName, #SortName] »« TextJoinMap[after, %n⟨
⟩] »⟫]
;


PG-TagSortDeclaration[#ModuleName, #SortName, #funs, #tags]
→
%n⟪
/***SORTS: †«PG-QN[#ModuleName, "TagSort", #SortName]» ::= ( « #tags » ); ***/
«#funs»⟫
;

///PG-MetaHead[#dontcare, #SortName, #Name, #isLeftRecursive, #Prec] → %n⟪⟫ ;
///PG-MetaTail[#dontcare, #SortName, #Name] → %n⟪⟫ ;


{$String<!--SortName--> : DeclarationMapEntry} PG-ProduceBody[$String<!--ModuleName-->, $String<!--HostSort-->, $List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

-[Data[#PFKs]]:
{#DM} PG-ProduceBody[#ModuleName, #SortName, #PFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBody1[#ModuleName, #SortName, #PFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

// Pick branching kind.

{$String<!--SortName--> : DeclarationMapEntry} PG-ProduceBody1[$String<!--ModuleName-->, $String<!--HostSort-->, $List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

{#DM} PG-ProduceBody1[#ModuleName, #SortName, (), #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
#[%n⟪⟫, %n⟪⟫, %n⟪⟫, EmptyTextMap]
;

{#DM} PG-ProduceBody1[#ModuleName, #SortName, (PFK[Hx_M_ParsedFormWord[#word, #ParsedForm], #Kind]; #Rest), #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyWord1[#ModuleName, #SortName, #Rest, (), #word, (PFK[#ParsedForm, #Kind];), #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{#DM} PG-ProduceBody1[#ModuleName, #SortName, (PFK[Hx_M_ParsedFormTerm[Hx_M_ScopeSortPrecRepeat[#ScopeSort, #Prec, #Repeat], #ParsedForm], #Kind]; #Rest), #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyTerm1[#ModuleName, #SortName, #Rest, (), #ScopeSort, #Prec, #Repeat, #Kind, (PFK[#ParsedForm, #Kind];), #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{#DM} PG-ProduceBody1[#ModuleName, #SortName, (PFK[Hx_M_ParsedFormSpace[#space, #ParsedForm], #Kind]; #Rest), #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBody1[#ModuleName, #SortName, (PFK[#ParsedForm, #Kind]; #Rest), #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{#DM} PG-ProduceBody1[#ModuleName, #SortName, (PFK[Hx_M_ParsedFormDone, #Kind]; #Rest), #n, #terms, #words, C_BUFFER[#SortName, #Prec], in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBody2[#ModuleName, #SortName, #Rest, #n, #terms, #words, C_BUFFER[#SortName, #Prec], in funs tags after . #[in,funs,tags,after],
  PG-AttributeCollection[#ModuleName, #Kind, #SortName, #Prec, PG-ProductionConstructionText[#ModuleName, #SortName, #Prec, #Kind, #words, #terms], B_FALSE],
  PG-ProductionSortFunsText[#ModuleName, #SortName, #Prec, #Kind, #words, #terms],
  PG-ProductionSortTagsText[#ModuleName, #SortName, #Prec, #Kind, #words, #terms],
  PG-AttributeProduction[#ModuleName, #Kind, #SortName, #Prec, B_FALSE]]
;

{#DM} PG-ProduceBody1[#ModuleName, #SortName, (PFK[Hx_M_ParsedFormDone, #Kind]; #Rest), #n, #terms, #words, C_LEFTRECURSIVE[#SortName, #Prec], in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBody2[#ModuleName, #SortName, #Rest, #n, #terms, #words, C_LEFTRECURSIVE[#SortName, #Prec], in funs tags after . #[in,funs,tags,after],
  PG-AttributeCollection[#ModuleName, #Kind, #SortName, #Prec, PG-ProductionConstructionText[#ModuleName, #SortName, #Prec, #Kind, #words, #terms], B_TRUE],
  PG-ProductionSortFunsText[#ModuleName, #SortName, #Prec, #Kind, #words, #terms],
  PG-ProductionSortTagsText[#ModuleName, #SortName, #Prec, #Kind, #words, #terms],
  PG-AttributeProduction[#ModuleName, #Kind, #SortName, #Prec, B_TRUE]]
;

{$String<!--SortName--> : DeclarationMapEntry} PG-ProduceBody2[$String<!--ModuleName-->, $String<!--HostSort-->, $List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text, Text, TextMapSort] :: Text;
-[Data[#in2,#sort2,#after2]]:
{#DM} PG-ProduceBody2[#ModuleName, #SortName, #Rest, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after], #in2, #funs2, #tags2, #after2]
→
{#DM} PG-ProduceBody1[#ModuleName, #SortName, #Rest, #n, #terms, #words, #consumer, in funs tags after . #[%n⟪« #in2 »«in»⟫, %n⟪« #funs2 »«funs»⟫, %n⟪« #tags2 »«tags»⟫, JoinTextMaps[#after2, after]]]
;

PG-AttributeCollection[FormKind, $String, $Numeric, Text, Boolean] :: Text;

PG-AttributeCollection[#ModuleName, #Kind, #SortName, #Prec, #Construct, B_FALSE] → #Construct ;
PG-AttributeCollection[#ModuleName, #Kind, #SortName, #Prec, #Construct, B_TRUE] → %n⟪<«PG-ProductionNameWithPrecText[#SortName,#Prec]»LR «#Construct»>⟫ ;

PG-AttributeProduction[FormKind, $String, $Numeric, Boolean] :: TextMapSort;
PG-AttributeProduction[#ModuleName, #dontcare, #SortName, #Prec, #IsLeftRecursive]
→
EmptyTextMap //TODO: eliminate?
;

PG-ProductionSortFunsText[$String<!--ModuleName-->, $String, $Numeric, FormKind, $List[Text], $List[Text]] :: Text;

-[Data[#SortName,#Prec],Data[#words]]:
PG-ProductionSortFunsText[#ModuleName, #SortName, #Prec, #scheme, #words, #terms]
→
%n⟪
/***METAELIM: †«PG-QN[#ModuleName, "Node", #SortName]»[†« PG-QN[#ModuleName, "Tag", StringJoin[(PG-ProductionNameWithPrec[#SortName, #Prec]; IfEmpty[#words, "EMPTY", MapWhen[ok x.TextToStringWhen[ok, x], #words]]), "_"]] »« WrappedTextJoin[#terms, %n⟨, (⟩, %n⟨; ⟩, %n⟨;)⟩] »]; ***/
⟫;

PG-ProductionSortTagsText[$String<!--ModuleName-->, $String, $Numeric, FormKind, $List[Text], $List[Text]] :: Text;

-[Data[#SortName,#Prec],Data[#words]]:
PG-ProductionSortTagsText[#ModuleName, #SortName, #Prec, #scheme, #words, #terms]
→
%n⟪†« PG-QN[#ModuleName, #SortName, StringJoin[(PG-ProductionNameWithPrec[#SortName, #Prec]; IfEmpty[#words, "EMPTY", MapWhen[ok x.TextToStringWhen[ok, x], #words]]), "_"]] »; ⟫
;

PG-ProductionConstructionText[$String<!--ModuleName-->, $String, $Numeric, FormKind, $List[Text], $List[Text]] :: Text;

-[Data[#SortName,#Prec],Data[#words]]:
PG-ProductionConstructionText[#ModuleName, #SortName, #Prec, FK_SCHEME[#Inh], #words, #terms]
→
%n⟪⟦ {{
/***PG: '†« PG-QN[#ModuleName, PG-ProductionNameWithPrec[#SortName, #Prec], IfEmpty[#words, "EMPTY", MapStringConcatWhen[ok x.TextToStringWhen[ok, x], #words]]] »'« WrappedTextJoin[#terms, %n⟨[⟩, %n⟨, ⟩, %n⟨]⟩] » ***/
/***METAPG: '†« PG-QN[#ModuleName, "Node", #SortName] »'['†« PG-QN[#ModuleName, "Tag", StringJoin[(PG-ProductionNameWithPrec[#SortName, #Prec]; IfEmpty[#words, "EMPTY", MapWhen[ok x.TextToStringWhen[ok, x], #words]]), "_"]] »'« WrappedTextJoin[#terms, %n⟨, (⟩, %n⟨; ⟩, %n⟨;)⟩] »] ***/
}}⟧
⟫
;

-[Data[#SortName,#Prec],Data[#words]]:
PG-ProductionConstructionText[#ModuleName, #SortName, #Prec, FK_SUGAR[#Inh], #words, #terms]
→
%n⟪⟦ {{ « WrappedTextJoin[#terms, %n⟨⟩, %n⟨ ⟩, %n⟨⟩] » }}⟧
⟫
;

-[Data[#SortName,#Prec,#Kind],Data[#words]]:
PG-ProductionConstructionText[#ModuleName, #SortName, #Prec, $[NotMatch,FK_SCHEME[#_Inh],$[NotMatch,FK_SUGAR[#_term],#Kind]], #words, #terms]
→
IfAliasKind[#Kind, WrappedTextJoin[#terms, %n⟨ {{⟩, %n⟨ ⟩, %n⟨}}⟩],
  %n⟪⟦ {{
/***PG: '†« PG-QN[#ModuleName, PG-ProductionNameWithPrec[#SortName, #Prec], IfEmpty[#words, "EMPTY", MapStringConcatWhen[ok x.TextToStringWhen[ok, x], #words]]] »'« WrappedTextJoin[#terms, %n⟨[⟩, %n⟨, ⟩, %n⟨]⟩] » ***/
/***METAPG: '†« PG-QN[#ModuleName, "Node", #SortName] »'['†« PG-QN[#ModuleName, "Tag", StringJoin[(PG-ProductionNameWithPrec[#SortName, #Prec]; IfEmpty[#words, "EMPTY", MapWhen[ok x.TextToStringWhen[ok, x], #words]]), "_"]] »'« WrappedTextJoin[#terms, %n⟨, (⟩, %n⟨; ⟩, %n⟨;)⟩] »] ***/
}}⟧
⟫]
;

∀ a . IfAliasKind[FormKind, a, a] :: a;
IfAliasKind[FK_ALIAS, #1, #2] → #1 ;
IfAliasKind[FK_SYMBOL[#IsStatic, #t], #1, #2] → #1 ;
-[Data[#Kind]]: IfAliasKind[$[NotMatch,FK_ALIAS,$[NotMatch,FK_SYMBOL[#IsStatic, #t],#Kind]], #1, #2] → #2 ;

// (1) Constant Token Case: (a) collect productions starting with the constant token and ...

{$String<!--SortName--> : DeclarationMapEntry} PG-ProduceBodyWord1[$String<!--ModuleName-->, $String<!--HostSort-->, $List[PFK_SORT], $List[PFK_SORT], $String, $List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

-[Data[#word1,#word],Share[#ParsedForm1,#Kind1,#Rest,#wordPFKs,#n,#terms,#words,#consumer]]:
{#DM} PG-ProduceBodyWord1[#ModuleName, #SortName, (PFK[Hx_M_ParsedFormWord[#word1, #ParsedForm1], #Kind1]; #Rest), #Failed, #word, #wordPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
$[If, $[Equal, #word, #word1],
  {#DM} PG-ProduceBodyWord1[#ModuleName, #SortName, #Rest, #Failed, #word, Append[#wordPFKs, (PFK[#ParsedForm1, #Kind1];)], #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]],
  {#DM} PG-ProduceBodyWord1[#ModuleName, #SortName, #Rest, Append[#Failed, (PFK[Hx_M_ParsedFormWord[#word1, #ParsedForm1], #Kind1];)], #word, #wordPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]]
;

{#DM} PG-ProduceBodyWord1[#ModuleName, #SortName, (PFK[Hx_M_ParsedFormTerm[#ScopeSortPrecRepeat1, #ParsedForm1], #Kind]; #Rest), #Failed, #word, #wordPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyWord1[#ModuleName, #SortName, #Rest, Append[#Failed, (PFK[Hx_M_ParsedFormTerm[#ScopeSortPrecRepeat1, #ParsedForm1], #Kind];)], #word, #wordPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{#DM} PG-ProduceBodyWord1[#ModuleName, #SortName, (PFK[Hx_M_ParsedFormSpace[#space1, #ParsedForm1], #Kind1]; #Rest), #Failed, #word, #wordPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyWord1[#ModuleName, #SortName, (PFK[#ParsedForm1, #Kind1]; #Rest), #Failed, #word, #wordPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{#DM} PG-ProduceBodyWord1[#ModuleName, #SortName, (PFK[Hx_M_ParsedFormDone, #Kind]; #Rest), #Failed, #word, #wordPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyWord1[#ModuleName, #SortName, #Rest, Append[#Failed, (PFK[Hx_M_ParsedFormDone, #Kind];)], #word, #wordPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{#DM} PG-ProduceBodyWord1[#ModuleName, #SortName, (), #Failed, #word, #wordPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyWord2[#ModuleName, #SortName, #Failed, #word, #wordPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

// ... (b) emit constant token branch.

{$String<!--SortName--> : DeclarationMapEntry} PG-ProduceBodyWord2[$String<!--ModuleName-->, $String<!--HostSort-->, $List[PFK_SORT], $String, $List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

{#DM} PG-ProduceBodyWord2[#ModuleName, #SortName, (), #word, #wordPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBody[#ModuleName, #SortName, #wordPFKs, #n, #terms, Append[#words, (%n⟨†‹$[Mangle,#word]›⟩;)], #consumer, in1 funs1 tags1 after1 . #[%n⟪« ProductionWord[#word] »⟦« in1 »⟧⟫, funs1, tags1, after1]]
;

{#DM} PG-ProduceBodyWord2[#ModuleName, #SortName, (#PFK1;#PFKs), #word, #wordPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBody[#ModuleName, #SortName, #wordPFKs, #n, #terms, Append[#words, (%n⟨†‹$[Mangle,#word]›⟩;)], #consumer, in1 funs1 tags1 after1 .
  {#DM} PG-ProduceBody[#ModuleName, #SortName, (#PFK1;#PFKs), #n, #terms, #words, #consumer, in2 funs2 tags2 after2 .
    #[%n⟪(« ProductionWord[#word] »« in1 »
| « in2 »)⟫, %n⟪«funs1»«funs2»⟫, %n⟪«tags1»«tags2»⟫, JoinTextMaps[after1, after2]]]]
;

    ProductionWord[$String] :: Text;
    ProductionWord[#word] → %n⟪†« Stringify[#word] »⟫ ;

// (2) Common Nonterminal: (a) collect productions starting with the nonterminal and...

{$String : DeclarationMapEntry} PG-ProduceBodyTerm1[$String<!--ModuleName-->, $String<!--HostSort-->,
	$List[PFK_SORT], $List[PFK_SORT], HxScopeSort, $Numeric, HxRepeat, FormKind, $List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

{#DM} PG-ProduceBodyTerm1[#ModuleName, #SortName, (PFK[Hx_M_ParsedFormWord[#word1, #ParsedForm1], #Kind1]; #Rest), #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyTerm1[#ModuleName, #SortName, #Rest, Append[#Failed, (PFK[Hx_M_ParsedFormWord[#word1, #ParsedForm1], #Kind1];)], #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{#DM} PG-ProduceBodyTerm1[#ModuleName, #SortName, (PFK[Hx_M_ParsedFormTerm[Hx_M_ScopeSortPrecRepeat[#ScopeSort1, #Prec1, #Repeat1], #ParsedForm1], #Kind1]; #Rest), #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyTerm1x[#ModuleName, #SortName, PG-SameScopeSort[#ScopeSort1, #Prec1, #Repeat1, #ScopeSort, #Prec, #Repeat], #ScopeSort1, #Prec1, #Repeat1, #ParsedForm1, #Kind1, #Rest, #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

    // Local test if two ScopeSorts are the same.
    
    PG-SameScopeSort[HxScopeSort, $Numeric, HxRepeat, HxScopeSort, $Numeric, HxRepeat] :: Boolean;
    PG-SameScopeSort[#Sort1, #Prec1, #Repeat1, #Sort2, #Prec2, #Repeat2] → PG-SameScopeSort2[#Sort1, #Sort2, #Prec1, #Repeat1, #Prec2, #Repeat2] ;
    
    PG-SameScopeSort2[HxScopeSort, HxScopeSort, $Numeric, HxRepeat, $Numeric, HxRepeat] :: Boolean;
    
    PG-SameScopeSort2[%rawHxScopeSort⟪ #HxSort1# [ #HxSubstituteSorts1# ] ⟫, %rawHxScopeSort⟪ #HxSort2# [ #HxSubstituteSorts2# ] ⟫, #Prec1, #Repeat1, #Prec2, #Repeat2]
    →
    And[PG-SameSort[#HxSort1#, #HxSort2#], And[PG-SamePrec[#Prec1, #Prec2], PG-SubRepeat[#Repeat1, #Repeat2]]]
    ;
    -[Free[v1::Text]]:
    PG-SameScopeSort2[%rawHxScopeSort⟪ [ v1 : #HxSort1# ] ⟫                   , %rawHxScopeSort⟪ #HxSort2# [ #HxSubstituteSorts2# ] ⟫, #P1, #R1, #P2, #R2] → B_FALSE ;
    -[Free[v2::Text]]:
    PG-SameScopeSort2[%rawHxScopeSort⟪ #HxSort1# [ #HxSubstituteSorts1# ] ⟫, %rawHxScopeSort⟪ [ v2 : #HxSort2# ] ⟫, #P1, #R1, #P2, #R2] → B_FALSE ;
    -[Free[v1::Text,v2::Text]]:
    PG-SameScopeSort2[%rawHxScopeSort⟪ [ v1 : #HxSort1# ] ⟫                   , %rawHxScopeSort⟪ [ v2 : #HxSort2# ] ⟫, #P1, #R1, #P2, #R2] → PG-SameSort[#HxSort1#, #HxSort2#] ;
    
    PG-SameSort[HxSort, HxSort] :: Boolean;
    -[Data[#1,#2]]: PG-SameSort[#1, #2] → PG-SameSort2[#1, #2] ;
    
    PG-SameSort2[HxSort, HxSort] :: Boolean;
    
    -[Data[#HxSortName1#,#HxSortName2#]]:
    PG-SameSort2[%rawHxSort⟪ #HxSortName1# #HxMetaVariables1# #HxSimpleSorts1# ⟫, %rawHxSort⟪ #HxSortName2# #HxMetaVariables2# #HxSimpleSorts2# ⟫]
    →
    $[If, $[Equal, #HxSortName1#, #HxSortName2#], B_TRUE, B_FALSE]
    ;
    
    PG-SameSort2[$[NotMatch,%rawHxSort⟪ #HxSortName1# #HxMetaVariables1# #HxSimpleSorts1# ⟫,#1], #2]
    →
    B_FALSE
    ;
    
    PG-SameSort2[#1,$[NotMatch,%rawHxSort⟪ #HxSortName2# #HxMetaVariables2# #HxSimpleSorts2# ⟫,#2]]
    →
    B_FALSE
    ;
    
    PG-SamePrec[$Numeric, $Numeric] :: Boolean;
    -[Data[#Prec1,#Prec2]]: PG-SamePrec[#Prec1, #Prec2] → $[If, $[NumericEqual, #Prec1, #Prec2], B_TRUE, B_FALSE] ;
    
    PG-SubRepeat[HxRepeat, HxRepeat] :: Boolean;
    
    PG-SubRepeat-single: PG-SubRepeat[%rawHxRepeat⟪ ⟫, #Repeat2] → B_TRUE ;
    
    PG-SubRepeat-maybe-single: PG-SubRepeat[%rawHxRepeat⟪ ? ⟫, %rawHxRepeat⟪ ⟫] → B_FALSE;
    PG-SubRepeat-maybe-maybe: PG-SubRepeat[%rawHxRepeat⟪ ? ⟫, %rawHxRepeat⟪ ? ⟫] → B_TRUE;
    PG-SubRepeat-maybe-many: PG-SubRepeat[%rawHxRepeat⟪ ? ⟫, %rawHxRepeat⟪ * ⟫] → B_TRUE;
    PG-SubRepeat-maybe-some: PG-SubRepeat[%rawHxRepeat⟪ ? ⟫, %rawHxRepeat⟪ + ⟫] → B_FALSE;
    PG-SubRepeat-maybe-somesep: PG-SubRepeat[%rawHxRepeat⟪ ? ⟫, %rawHxRepeat⟪ + _ #HxRegExpLeaf2# ⟫] → B_FALSE;
    
    PG-SubRepeat-some-single: PG-SubRepeat[%rawHxRepeat⟪ + ⟫, %rawHxRepeat⟪ ⟫] → B_FALSE;
    PG-SubRepeat-some-maybe: PG-SubRepeat[%rawHxRepeat⟪ + ⟫, %rawHxRepeat⟪ ? ⟫] → B_FALSE;
    PG-SubRepeat-some-many: PG-SubRepeat[%rawHxRepeat⟪ + ⟫, %rawHxRepeat⟪ * ⟫] → B_TRUE;
    PG-SubRepeat-some-some: PG-SubRepeat[%rawHxRepeat⟪ + ⟫, %rawHxRepeat⟪ + ⟫] → B_TRUE;
    PG-SubRepeat-some-somesep: PG-SubRepeat[%rawHxRepeat⟪ + ⟫, %rawHxRepeat⟪ + _ #HxRegExpLeaf2# ⟫] → B_FALSE;
    
    PG-SubRepeat-many-many: PG-SubRepeat[%rawHxRepeat⟪ * ⟫, %rawHxRepeat⟪ * ⟫] → B_TRUE ;
    PG-SubRepeat-many-other[Data[#_]]: PG-SubRepeat[%rawHxRepeat⟪ * ⟫, $[NotMatch,%rawHxRepeat⟪ * ⟫,#_]] → B_FALSE;
    
    PG-SubRepeat-somesep-single: PG-SubRepeat[%rawHxRepeat⟪ + _ #HxRegExpLeaf1# ⟫, %rawHxRepeat⟪ ⟫] → B_FALSE;
    PG-SubRepeat-somesep-maybe: PG-SubRepeat[%rawHxRepeat⟪ + _ #HxRegExpLeaf1# ⟫, %rawHxRepeat⟪ ? ⟫] → B_FALSE;
    PG-SubRepeat-somesep-many: PG-SubRepeat[%rawHxRepeat⟪ + _ #HxRegExpLeaf1# ⟫, %rawHxRepeat⟪ * ⟫] → B_FALSE;
    PG-SubRepeat-somesep-some: PG-SubRepeat[%rawHxRepeat⟪ + _ #HxRegExpLeaf1# ⟫, %rawHxRepeat⟪ + ⟫] → B_FALSE;
    
    PG-SubRepeat-somesep-string-string: PG-SubRepeat[%rawHxRepeat⟪ + _ #HxString1# ⟫, %rawHxRepeat⟪ + _ #HxString2# ⟫] → SameString[UnString[#HxString1#], UnString[#HxString2#]] ;
    PG-SubRepeat-somesep-string-word: PG-SubRepeat[%rawHxRepeat⟪ + _ #HxString1# ⟫, %rawHxRepeat⟪ + _ #HxWord2# ⟫] → SameString[UnString[#HxString1#], #HxWord2#] ;
    PG-SubRepeat-somesep-word-string: PG-SubRepeat[%rawHxRepeat⟪ + _ #HxWord1# ⟫, %rawHxRepeat⟪ + _ #HxString2# ⟫] → SameString[#HxWord1#, UnString[#HxString2#]] ;
    PG-SubRepeat-somesep-word-word: PG-SubRepeat[%rawHxRepeat⟪ + _ #HxWord1# ⟫, %rawHxRepeat⟪ + _ #HxWord2# ⟫] → SameString[#HxWord1#, #HxWord2#] ;







{#DM} PG-ProduceBodyTerm1[#ModuleName, #SortName, (PFK[Hx_M_ParsedFormSpace[#space1, #ParsedForm1], #Kind1]; #Rest), #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyTerm1[#ModuleName, #SortName, (PFK[#ParsedForm1, #Kind1]; #Rest), #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{#DM} PG-ProduceBodyTerm1[#ModuleName, #SortName, (PFK[Hx_M_ParsedFormDone, #Kind1]; #Rest), #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyTerm1[#ModuleName, #SortName, #Rest, Append[#Failed, (PFK[Hx_M_ParsedFormDone, #Kind1];)], #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{#DM} PG-ProduceBodyTerm1[#ModuleName, #SortName, (), #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyTerm2[#ModuleName, #SortName, #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

// ... helper to filter identical scope sorts...

{$String : DeclarationMapEntry}
PG-ProduceBodyTerm1x[$String<!--ModuleName-->, $String<!--HostSort-->, Boolean, HxScopeSort, $Numeric, HxRepeat, HxParsedForm, FormKind,
	$List[PFK_SORT], $List[PFK_SORT], HxScopeSort, $Numeric, HxRepeat, FormKind, $List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

{#DM} PG-ProduceBodyTerm1x[#ModuleName, #SortName, B_FALSE, #ScopeSort1, #Prec1, #Repeat1, #ParsedForm1, #Kind1, #Rest, #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyTerm1[#ModuleName, #SortName, #Rest, Append[#Failed, (PFK[Hx_M_ParsedFormTerm[Hx_M_ScopeSortPrecRepeat[#ScopeSort1, #Prec1, #Repeat1], #ParsedForm1], #Kind1];)], #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{#DM} PG-ProduceBodyTerm1x[#ModuleName, #SortName, B_TRUE, #ScopeSort1, #Prec1, #Repeat1, #ParsedForm1, #Kind1, #Rest, #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyTerm1[#ModuleName, #SortName, #Rest, #Failed, #ScopeSort, #Prec, #Repeat, #Kind, Append[#nonterminalPFKs, (PFK[#ParsedForm1, #Kind1];)], #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

// ... (b) emit branch (with recursive nesting of tail).

{$String : DeclarationMapEntry} PG-ProduceBodyTerm2[$String<!--ModuleName-->, $String<!--HostSort-->, $List[PFK_SORT], HxScopeSort, $Numeric, HxRepeat, FormKind, $List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

{#DM} PG-ProduceBodyTerm2[#ModuleName, #SortName, (), #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyTerm3[#ModuleName, #SortName, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{#DM} PG-ProduceBodyTerm2[#ModuleName, #SortName, (#PFK1;#PFKs), #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyTerm3[#ModuleName, #SortName, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in1 funs1 tags1 after1 .
  {#DM} PG-ProduceBody[#ModuleName, #SortName, (#PFK1;#PFKs), #n, #terms, #words, #consumer, in2 funs2 tags2 after2 .
    #[%n⟪(« in1 »
| « in2 »)⟫, %n⟪«funs1»«funs2»⟫, %n⟪«tags1»«tags2»⟫, JoinTextMaps[after1, after2]]]]
;

{$String : DeclarationMapEntry} PG-ProduceBodyTerm3[$String<!--ModuleName-->, $String<!--HostSort-->, HxScopeSort, $Numeric, HxRepeat, FormKind, $List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

-[Free[v::Text]]:
{#DM} PG-ProduceBodyTerm3[#ModuleName, #SortName, %rawHxScopeSort⟪ [ v : #HxSort# ] ⟫, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
IfSingletonRepeat[#Repeat,
  {#DM} PG-ProduceBody[#ModuleName, #SortName, #nonterminalPFKs, #n, #terms,  Append[#words, (%n⟨†‹SortVar[#HxSort#]›⟩;)], #consumer, in funs tags after .
    #[%n⟪⟦ <«PG-ProductionNameWithPrecText[{#DM}PG-SymbolSortTokenName[PG-SortName[#HxSort#]], #Prec]»>^«v» ⟦« in »⟧ ⟧⟫, funs, tags, after]],
  CookError["Cannot use repeat specification on binder"]]
;

    SortVar[HxSort] :: $String;
    -[Data[#Sort]]: SortVar[#Sort] → SortVar2[#Sort] ;
    SortVar2[HxSort] :: $String;
    -[Data[#SortName]]: SortVar2[           %rawHxSort⟪ #HxSortName# #HxMetaVariables# #HxSimpleSorts# ⟫] → SortVar3[#HxSortName#, #HxMetaVariables#] ;
                        SortVar2[$[NotMatch,%rawHxSort⟪ #HxSortName# #HxMetaVariables# #HxSimpleSorts# ⟫,#]] →  "bad" ;
    SortVar3[$String, $List[$String]] :: $String;
    SortVar3[#SortName, ()] → $[:,"v",#SortName] ;
    SortVar3[#SortName, (#MetaVar;)] → $[:,"v",#SortName,$[Replace,#MetaVar,"#",""]] ;

{#DM} PG-ProduceBodyTerm3[#ModuleName, #SortName, %rawHxScopeSort⟪ #HxSort# #HxRepeat# [ #HxSubstituteSorts# ] ⟫, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyTerm4[#ModuleName, #SortName, #HxSort#, #HxSubstituteSorts#, PG-ProductionNameWithPrecRepeatText[PG-SortName[#HxSort#], #Prec, NestedRepeat[#HxRepeat#, #Repeat]], #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{$String : DeclarationMapEntry} PG-ProduceBodyTerm4[$String<!--ModuleName-->, $String<!--HostSort-->, HxSort, $List[HxSubstituteSort], Text, $Numeric, HxRepeat, FormKind, $List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

-[Data[#consumer]]:
{#DM} PG-ProduceBodyTerm4[#ModuleName, #SortName, #HxSort#, #HxSubstituteSorts#, #ProductionName, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, <!--$[NotMatch,C_INLINE,-->#consumer<!--]-->, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBody[#ModuleName, #SortName, #nonterminalPFKs, $[Plus,#n,1],
  Append[#terms, (%n⟨†‹ PG-SortMetaVar[#HxSort#, #n] ›⟩;)],
  Append[#words, (%n⟨†‹ PG-SortName[#HxSort#] ›⟩;)],
  #consumer,
  in funs tags after .
    #[%n⟪⟦( « PG-VariablePrefix[#Kind, #ModuleName, #SortName, #ProductionName] » <« #ProductionName »>«
	WrappedTextJoin[Map[s.PG-ExtractSubstitutedSort[s], #HxSubstituteSorts#], %n⟨[⟩, %n⟨,⟩, %n⟨]⟩] »«
	PG-VariableMarker[#Kind, %n⟨:†‹ PG-SortMetaVar[#HxSort#, #n] ›⟩] » ⟦« in »⟧ )
      ⟧⟫, funs, tags, after]]
;

    PG-SortMetaVar[HxSort, $Numeric] :: $String;
    -[Data[#Sort]]: PG-SortMetaVar[#Sort, #n] → PG-SortMetaVar2[#Sort, #n] ;
    PG-SortMetaVar2[HxSort, $Numeric] :: $String;
    PG-SortMetaVar2[           %rawHxSort⟪ #HxSortName# #HxMetaVariable# #HxSimpleSorts# ⟫,    #n] → #HxMetaVariable# ;
    PG-SortMetaVar2[           %rawHxSort⟪ #HxSortName#                #HxSimpleSorts# ⟫,    #n] → $[:,"#_",#HxSortName#,"_",$[FormatNumber,#n]] ;
    PG-SortMetaVar2[$[NotMatch,%rawHxSort⟪ #HxSortName# #HxMetaVariables# #HxSimpleSorts# ⟫,#], #n] →  "#bad" ;
    
    // TODO: Eliminate redundant repeat productions!

    PG-ExtractSubstitutedSort[HxSubstituteSort] :: Text;
    -[Free[v1::Text]]:
    PG-ExtractSubstitutedSort[%rawHxSubstituteSort⟪ v1 : #HxSort2# ⟫] → %n⟪«v1»⟫ ;

    PG-VariablePrefix[FormKind, $String<!--ModuleName-->, $String<!--SortName-->, Text<!--Other-->] :: Text;
    -[Data[#Kind,#ModuleName,#SortName]]: PG-VariablePrefix[#Kind, #ModuleName, #SortName, #Other] → PG-VariablePrefix2[#Kind, #ModuleName, #SortName, #Other] ;

    PG-VariablePrefix2[FormKind, $String<!--ModuleName-->, $String<!--SortName-->, Text<!--Other-->] :: Text;
    PG-VariablePrefix2[FK_SYMBOL[#free, #t], #ModuleName, #SortName, #Other] → %n⟪/***METAPG:{†« PG-QN[#ModuleName,"Var", #SortName] »_«#Other»}***/⟫ ;
    PG-VariablePrefix2[$[NotMatch,FK_SYMBOL[#IsStatic,#t],#Kind], #ModuleName, #SortName, #Other] → %n⟪⟫ ;

    PG-VariableMarker[FormKind, Text] :: Text;
    -[Data[#Kind]]: PG-VariableMarker[#Kind, #Other] → PG-VariableMarker2[#Kind, #Other] ;

    PG-VariableMarker2[FormKind, Text] :: Text;
    PG-VariableMarker2[FK_SYMBOL[$False,#t], #Other] → %n⟪!!!« #Other »⟫ ;
    PG-VariableMarker2[FK_SYMBOL[$True,#t], #Other] → %n⟪!!« #Other »⟫ ;
    PG-VariableMarker2[$[NotMatch,FK_SYMBOL[#IsStatic,#t],#Kind], #Other] → #Other ;


// REPEATS.

∀ a . IfSingletonRepeat[HxRepeat, a, a] :: a;
IfSingletonRepeat[%rawHxRepeat⟪ ⟫, #1, #2] → #1 ;
IfSingletonRepeat[%rawHxRepeat⟪ ? ⟫, #1, #2] → #2 ;
IfSingletonRepeat[%rawHxRepeat⟪ * ⟫, #1, #2] → #2 ;
IfSingletonRepeat[%rawHxRepeat⟪ + ⟫, #1, #2] → #2 ;
IfSingletonRepeat[%rawHxRepeat⟪ + _ #HxRegExpLeaf# ⟫, #1, #2] → #2 ;

NestedRepeat[HxRepeat, HxRepeat] :: HxRepeat;
NestedRepeat-single-single:   NestedRepeat[%rawHxRepeat⟪ ⟫, %rawHxRepeat⟪ ⟫]                                     → %rawHxRepeat⟪ ⟫ ;
NestedRepeat-single-maybe :   NestedRepeat[%rawHxRepeat⟪ ⟫, %rawHxRepeat⟪ ? ⟫]                                   → %rawHxRepeat⟪ ? ⟫ ;
NestedRepeat-single-many:     NestedRepeat[%rawHxRepeat⟪ ⟫, %rawHxRepeat⟪ * ⟫]                                   → %rawHxRepeat⟪ * ⟫ ;
NestedRepeat-single-some:     NestedRepeat[%rawHxRepeat⟪ ⟫, %rawHxRepeat⟪ + ⟫]                                   → %rawHxRepeat⟪ + ⟫ ;
NestedRepeat-single-somesep:  NestedRepeat[%rawHxRepeat⟪ ⟫, %rawHxRepeat⟪ + _ #HxRegExpLeaf2# ⟫]                   → %rawHxRepeat⟪ + _ #HxRegExpLeaf2# ⟫ ;
NestedRepeat-maybe-single:    NestedRepeat[%rawHxRepeat⟪ ? ⟫, %rawHxRepeat⟪ ⟫]                                   → %rawHxRepeat⟪ ? ⟫ ;
NestedRepeat-maybe-maybe :    NestedRepeat[%rawHxRepeat⟪ ? ⟫, %rawHxRepeat⟪ ? ⟫]                                 → %rawHxRepeat⟪ ? ⟫ ;
NestedRepeat-maybe-many:      NestedRepeat[%rawHxRepeat⟪ ? ⟫, %rawHxRepeat⟪ * ⟫]                                 → %rawHxRepeat⟪ * ⟫ ;
NestedRepeat-maybe-some:      NestedRepeat[%rawHxRepeat⟪ ? ⟫, %rawHxRepeat⟪ + ⟫]                                 → %rawHxRepeat⟪ * ⟫ ;
NestedRepeat-maybe-somesep:   NestedRepeat[%rawHxRepeat⟪ ? ⟫, %rawHxRepeat⟪ + _ #HxRegExpLeaf2# ⟫]                 → $[Error,"Cannot nest ? in +_'...' repeater."] ;
NestedRepeat-many-single:     NestedRepeat[%rawHxRepeat⟪ * ⟫, %rawHxRepeat⟪ ⟫]                                   → %rawHxRepeat⟪ * ⟫ ;
NestedRepeat-many-maybe :     NestedRepeat[%rawHxRepeat⟪ * ⟫, %rawHxRepeat⟪ ? ⟫]                                 → %rawHxRepeat⟪ * ⟫ ;
NestedRepeat-many-many:       NestedRepeat[%rawHxRepeat⟪ * ⟫, %rawHxRepeat⟪ * ⟫]                                 → %rawHxRepeat⟪ * ⟫ ;
NestedRepeat-many-some:       NestedRepeat[%rawHxRepeat⟪ * ⟫, %rawHxRepeat⟪ + ⟫]                                 → %rawHxRepeat⟪ * ⟫ ;
NestedRepeat-many-somesep:    NestedRepeat[%rawHxRepeat⟪ * ⟫, %rawHxRepeat⟪ + _ #HxRegExpLeaf2# ⟫]                 → $[Error,"Cannot nest * in +_'...' repeater."] ;
NestedRepeat-some-single:     NestedRepeat[%rawHxRepeat⟪ + ⟫, %rawHxRepeat⟪ ⟫]                                   → %rawHxRepeat⟪ + ⟫ ;
NestedRepeat-some-maybe :     NestedRepeat[%rawHxRepeat⟪ + ⟫, %rawHxRepeat⟪ ? ⟫]                                 → %rawHxRepeat⟪ * ⟫ ;
NestedRepeat-some-many:       NestedRepeat[%rawHxRepeat⟪ + ⟫, %rawHxRepeat⟪ * ⟫]                                 → %rawHxRepeat⟪ * ⟫ ;
NestedRepeat-some-some:       NestedRepeat[%rawHxRepeat⟪ + ⟫, %rawHxRepeat⟪ + ⟫]                                 → %rawHxRepeat⟪ + ⟫ ;
NestedRepeat-some-somesep:    NestedRepeat[%rawHxRepeat⟪ + ⟫, %rawHxRepeat⟪ + _ #HxRegExpLeaf2# ⟫]                 → %rawHxRepeat⟪ + _ #HxRegExpLeaf2# ⟫ ;
NestedRepeat-somesep-single:  NestedRepeat[%rawHxRepeat⟪ + _ #HxRegExpLeaf1# ⟫, %rawHxRepeat⟪ ⟫]                   → %rawHxRepeat⟪ + _ #HxRegExpLeaf1# ⟫ ;
NestedRepeat-somesep-maybe :  NestedRepeat[%rawHxRepeat⟪ + _ #HxRegExpLeaf1# ⟫, %rawHxRepeat⟪ ? ⟫]                 → $[Error,"Cannot nest +_'...' in ? repeater."] ;
NestedRepeat-somesep-many:    NestedRepeat[%rawHxRepeat⟪ + _ #HxRegExpLeaf1# ⟫, %rawHxRepeat⟪ * ⟫]                 → $[Error,"Cannot nest +_'...' in * repeater."] ;
NestedRepeat-somesep-some:    NestedRepeat[%rawHxRepeat⟪ + _ #HxRegExpLeaf1# ⟫, %rawHxRepeat⟪ + ⟫]                 → $[Error,"Cannot nest +_'...' in + repeater."] ;
NestedRepeat-somesep-somesep: NestedRepeat[%rawHxRepeat⟪ + _ #HxRegExpLeaf1# ⟫, %rawHxRepeat⟪ + _ #HxRegExpLeaf2# ⟫] → $[Error,"Cannot nest +_'...' in another +_'...' repeater."] ;








/////////////////////////////////////////////////////////////////////
// 15. TEXT OF LEXICAL DECLARATIONS.

// a.

// Instantiate CPS processing.
PG-Lexical[$List[HxDeclaration], $String<!--ModuleName-->] :: Text ;
PG-Lexical[#Declarations, #ModuleName] → PG-Lexical2[#Declarations, #ModuleName, B_FALSE, hasskip.PG-Lexical2Tail[hasskip]] ;

// Generate PG token instructions per HACS declaration.

PG-Lexical2[$List[HxDeclaration], $String, Boolean, ha::Boolean.Text] :: Text ;

Lexical-module:
PG-Lexical2[%rawHxDeclarations⟪ module #HxModuleName2# { #HxDeclarations2# } ; #HxDeclarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
PG-Lexical2[#HxDeclarations2#, #HxModuleName2#, #hasSkip, hasskip.PG-Lexical2[#HxDeclarations#, #ModuleName, hasskip, hasskip2.#[hasskip2]]]
;

Lexical-space:
PG-Lexical2[%rawHxDeclarations⟪ space #HxRegExp# ; #HxDeclarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
%n⟪skip ::= ' ' | ⟦« PG-InlineRegExp[#HxRegExp#, #ModuleName, "space$"] »⟧ .
« PG-DeclareRegExp[#HxRegExp#, #ModuleName, "space$"] »« PG-Lexical2[#HxDeclarations#, #ModuleName, B_TRUE, hasskip.#[hasskip]] »⟫
;

Lexical-token:
PG-Lexical2[%rawHxDeclarations⟪ token #HxSortName# | #HxRegExp# ; #HxDeclarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
%n⟪token «PG-TokenNameText[#HxSortName#]»/***METAPG:(USER)***/ ::= ⟦« PG-InlineRegExp[#HxRegExp#, #ModuleName, #HxSortName#] »⟧ .
« PG-DeclareRegExp[#HxRegExp#, #ModuleName, #HxSortName#] »« PG-Lexical2[#HxDeclarations#, #ModuleName, #hasSkip, hasskip.#[hasskip]] »⟫
;

Lexical-fragment:
PG-Lexical2[%rawHxDeclarations⟪ fragment #HxFragmentName# | #HxRegExp# ; #HxDeclarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
%n⟪token fragment «PG-TokenNameText[#HxFragmentName#]» ::= ⟦« PG-InlineRegExp[#HxRegExp#, #ModuleName, #HxFragmentName#] »⟧ . 
« PG-DeclareRegExp[#HxRegExp#, #ModuleName, #HxFragmentName#] »« PG-Lexical2[#HxDeclarations#, #ModuleName, #hasSkip, hasskip.#[hasskip]] »⟫
;

Lexical-attribute:
PG-Lexical2[%rawHxDeclarations⟪ attribute #HxAttributeKind# #HxAttributeName# #HxAttributeForm# #HxAttributeOptions# ; #HxDeclarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
PG-Lexical2[#HxDeclarations#, #ModuleName, #hasSkip, hasskip.#[hasskip]]
;

Lexical-sort:
PG-Lexical2[%rawHxDeclarations⟪ sort #HxSortName# #HxRepeat# #HxSortAbstraction# ; #HxDeclarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
PG-Lexical2[#HxDeclarations#, #ModuleName, #hasSkip, hasskip.#[hasskip]]
;

Lexical-main-sort:
PG-Lexical2[%rawHxDeclarations⟪ main sort #HxSortName# #HxRepeat# #HxSortAbstraction# ; #HxDeclarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
PG-Lexical2[#HxDeclarations#, #ModuleName, #hasSkip, hasskip.#[hasskip]]
;

Lexical-alternatives:
PG-Lexical2[%rawHxDeclarations⟪ #HxSortAlternatives# ; #HxDeclarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
PG-Lexical2[#HxDeclarations#, #ModuleName, #hasSkip, hasskip.#[hasskip]]
;

Lexical-rule:
PG-Lexical2[%rawHxDeclarations⟪ rule #HxRule# ; #HxDeclarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
PG-Lexical2[#HxDeclarations#, #ModuleName, #hasSkip, hasskip.#[hasskip]]
;

Lexical-nest:
PG-Lexical2[%rawHxDeclarations⟪ { #HxDeclarations2# } #HxDeclarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
PG-Lexical2[#HxDeclarations2#, #ModuleName, #hasSkip, hasskip.PG-Lexical2[#HxDeclarations#, #ModuleName, hasskip, hasskip2.#[hasskip2]]]
;

Lexical-done:
PG-Lexical2[%rawHxDeclarations⟪ ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
#[#hasSkip]
;

// The final continuation.
PG-Lexical2Tail[Boolean] :: Text;
PG-Lexical2Tail[B_TRUE] → %n⟪⟫ ;
PG-Lexical2Tail[B_FALSE] → %n⟪skip ::= " " .
⟫ ;

// b. Inline Text of Regular Expression.

//

PG-InlineRegExp[$List[HxRegExpChoice], $String<!--ModuleName-->, $String<!--identifier-->] :: Text ;
PG-InlineRegExp[(#RegExpChoice; #RegExp), #ModuleName, #id]
→
%n⟪⟦« PG-InlineRegExpChoice[#RegExpChoice, #ModuleName, #id] »⟧ « PG-InlineRegExp2[#RegExp, #ModuleName, #id] »⟫
;

PG-InlineRegExp2[$List[HxRegExpChoice], $String<!--ModuleName-->, $String<!--identifier-->] :: Text ;
PG-InlineRegExp2[(#RegExpChoice; #RegExp), #ModuleName, #id]
→
%n⟪| ⟦« PG-InlineRegExpChoice[#RegExpChoice, #ModuleName, #id] »⟧ « PG-InlineRegExp2[#RegExp, #ModuleName, #id] »⟫
;
PG-InlineRegExp2[(), #ModuleName, #id]
→
%n⟪⟫
;

//

PG-InlineRegExpChoice[HxRegExpChoice, $String<!--ModuleName-->, $String] :: Text;

PG-InlineRegExpChoice[%rawHxRegExpChoice⟪ nested #HxRegExpSimple1# #HxRegExpSimple2# ⟫, #ModuleName, #id]
→
%n⟪NESTED_«PG-TokenNameText[#id]»⟫
;
PG-InlineRegExpChoice[%rawHxRegExpChoice⟪ #HxRegExpUnits# ⟫, #ModuleName, #id]
→
PG-InlineRegExpUnits[#HxRegExpUnits#, #ModuleName, #id]
;

//

PG-InlineRegExpUnits[$List[HxRegExpUnit], $String<!--ModuleName-->, $String] :: Text;

PG-InlineRegExpUnits[%rawHxRegExpUnits⟪ #HxRegExpUnit# #HxRegExpUnits# ⟫, #ModuleName, #id]
→
%n⟪« PG-InlineRegExpUnit[#HxRegExpUnit#, #ModuleName, #id] » « PG-InlineRegExpUnits[#HxRegExpUnits#, #ModuleName, #id] »⟫
;
PG-InlineRegExpUnits[%rawHxRegExpUnits⟪ ⟫, #ModuleName, #id]
→
%n⟪⟫
;

//

PG-InlineRegExpUnit[HxRegExpUnit, $String<!--ModuleName-->, $String] :: Text;

PG-InlineRegExpUnit[%rawHxRegExpUnit⟪ #HxRegExpSimple# ⟫, #ModuleName, #id]
→
PG-InlineRegExpSimple[#HxRegExpSimple#, #ModuleName, #id]
;

PG-InlineRegExpUnit[%rawHxRegExpUnit⟪ #HxRegExpSimple# ? ⟫, #ModuleName, #id]
→
%n⟪( « PG-InlineRegExpSimple[#HxRegExpSimple#, #ModuleName, #id] » )?⟫
;

PG-InlineRegExpUnit[%rawHxRegExpUnit⟪ #HxRegExpSimple# * ⟫, #ModuleName, #id]
→
%n⟪( « PG-InlineRegExpSimple[#HxRegExpSimple#, #ModuleName, #id] » )*⟫
;

PG-InlineRegExpUnit[%rawHxRegExpUnit⟪ #HxRegExpSimple# + ⟫, #ModuleName, #id]
→
%n⟪( « PG-InlineRegExpSimple[#HxRegExpSimple#, #ModuleName, #id] » )+⟫
;

PG-InlineRegExpUnit[%rawHxRegExpUnit⟪ #HxRegExpSimple# + _ #HxRegExpLeaf# ⟫, #ModuleName, #id]
→
%n⟪( « PG-InlineRegExpSimple[#HxRegExpSimple#, #ModuleName, #id] » ( « PG-InlineRegExpSimple[#HxRegExpLeaf#, #ModuleName, #id] » « PG-InlineRegExpSimple[#HxRegExpSimple#, #ModuleName, #id] » )* )⟫
;

//

PG-InlineRegExpSimple[HxRegExpSimple, $String<!--ModuleName-->, $String] :: Text;

PG-InlineRegExpSimple[%rawHxRegExpSimple⟪ #HxString# ⟫, #ModuleName, #id]
→
%n⟪†«#HxString#»⟫ // TODO: manually decode HACS and recode PG escapes (or at least check)!
;

PG-InlineRegExpSimple[%rawHxRegExpSimple⟪ #HxWord# ⟫, #ModuleName, #id]
→
%n⟪†« Stringify[#HxWord#] »⟫
;

PG-InlineRegExpSimple[%rawHxRegExpSimple⟪ #HxFragmentRef# ⟫, #ModuleName, #id]
→
%n⟪«PG-TokenNameText[#HxFragmentRef#]»⟫
;

PG-InlineRegExpSimple[%rawHxRegExpSimple⟪ . ⟫, #ModuleName, #id]
→
PG-InlineRegExpSimple[%rawHxRegExpSimple⟪ [^\n\r\f] ⟫, #ModuleName, #id]
;

PG-InlineRegExpSimple[%rawHxRegExpSimple⟪ #HxRegExpClass# ⟫, #ModuleName, #id]
→
PG-InlineRegExpClass1[#HxRegExpClass#, #ModuleName, #id]
;

PG-InlineRegExpSimple[%rawHxRegExpSimple⟪ ( #HxRegExp# ) ⟫, #ModuleName, #id]
→
%n⟪( « PG-InlineRegExp[#HxRegExp#, #ModuleName, #id] » )⟫
;

//

PG-InlineRegExpClass1[HxRegExpClass, $String<!--ModuleName-->, $String] :: Text;

PG-InlineRegExpClass1[Hx_M_RegExpClassNot[#RegExpClass], #ModuleName, #id]
→
%n⟪~[« PG-InlineRegExpClass2[#RegExpClass, #ModuleName, #id, %n⟨⟩] »]⟫
;

PG-InlineRegExpClass1[$[NotMatch,Hx_M_RegExpClassNot[#_],#RegExpClass], #ModuleName, #id]
→
%n⟪[« PG-InlineRegExpClass2[#RegExpClass, #ModuleName, #id, %n⟨⟩] »]⟫
;

PG-InlineRegExpClass2[HxRegExpClass, $String<!--ModuleName-->, $String, Text] :: Text;

PG-InlineRegExpClass2[Hx_M_RegExpClassChar[#Char, #RegExpClass], #ModuleName, #id, #sep]
→
%n⟪«#sep»« PG-InlineRegExpRangeChar[#Char, #ModuleName, #id] »« PG-InlineRegExpClass2[#RegExpClass, #ModuleName, #id, %n⟨,⟩] »⟫
;

PG-InlineRegExpClass2[Hx_M_RegExpClassRange[#lo, #hi, #RegExpClass], #ModuleName, #id, #sep]
→
%n⟪«#sep»« PG-InlineRegExpRangeChar[#lo, #ModuleName, #id] »-« PG-InlineRegExpRangeChar[#hi, #ModuleName, #id] »« PG-InlineRegExpClass2[#RegExpClass, #ModuleName, #id, %n⟨,⟩] »⟫
;

PG-InlineRegExpClass2[Hx_M_RegExpClassDone, #ModuleName, #id, #sep]
→
%n⟪⟫
;
PG-InlineRegExpRangeChar[$String, $String<!--ModuleName-->, $String] :: Text;
-[Data[#HxRegExpRangeStartChar#]]:
PG-InlineRegExpRangeChar[#HxRegExpRangeStartChar#, #ModuleName, #id]
→
$[If, $[Equal,#HxRegExpRangeStartChar#,"'"], %n⟪"'"⟫, %n⟪'†« #HxRegExpRangeStartChar# »'⟫]
;

// 

PG-DeclareRegExp[$List[HxRegExpChoice], $String<!--ModuleName-->, $String<!--identifier-->] :: Text ;
PG-DeclareRegExp[(#RegExpChoice; #RegExp), #ModuleName, #id]
→
%n⟪« PG-DeclareRegExpChoice[#RegExpChoice, #ModuleName, #id] »« PG-DeclareRegExp[#RegExp, #ModuleName, #id] »⟫
;
PG-DeclareRegExp[(), #ModuleName, #id]
→
%n⟪⟫
;

PG-DeclareRegExpChoice[HxRegExpChoice, $String<!--ModuleName-->, $String] :: Text;
PG-DeclareRegExpChoice[%rawHxRegExpChoice⟪ nested #HxRegExpSimple1# #HxRegExpSimple2# ⟫, #ModuleName, #id]
→
%n⟪
%{
/* token †«#id». */
MORE : { < « PG-InlineRegExpSimple[#HxRegExpSimple1#, #ModuleName, #id] » > { nesting = 0; nestedState = curLexState; } : USER_IN_«PG-TokenNameText[#id]» }
<USER_IN_«PG-TokenNameText[#id]»> MORE : { < « PG-InlineRegExpSimple[#HxRegExpSimple1#, #ModuleName, #id] » > { nesting = 1; } : USER_IN_NESTED_«PG-TokenNameText[#id]» }
<USER_IN_NESTED_«PG-TokenNameText[#id]»> MORE : { < « PG-InlineRegExpSimple[#HxRegExpSimple1#, #ModuleName, #id] » > { nesting++; } }
<USER_IN_NESTED_«PG-TokenNameText[#id]»> MORE : { < « PG-InlineRegExpSimple[#HxRegExpSimple2#, #ModuleName, #id] » > { if (--nesting <= 0) SwitchTo(USER_IN_«PG-TokenNameText[#id]»); } }
<USER_IN_«PG-TokenNameText[#id]»> †« $[If,$[Equal,#id,"space$"],"SKIP","TOKEN"] » : { < T_NESTED_«PG-TokenNameText[#id]» : « PG-InlineRegExpSimple[#HxRegExpSimple2#, #ModuleName, #id] » > { SwitchTo(nestedState); } }
<USER_IN_«PG-TokenNameText[#id]»,USER_IN_NESTED_«PG-TokenNameText[#id]»> MORE : { < ~[] > }
%}
⟫
;
PG-DeclareRegExpChoice[%rawHxRegExpChoice⟪ #HxRegExpUnits# ⟫, #ModuleName, #id]
→
PG-DeclareRegExpUnits[#HxRegExpUnits#, #ModuleName, #id]
;

PG-DeclareRegExpUnits[$List[HxRegExpUnit], $String<!--ModuleName-->, $String] :: Text;
PG-DeclareRegExpUnits[%rawHxRegExpUnits⟪ #HxRegExpUnit# #HxRegExpUnits# ⟫, #ModuleName, #id]
→
%n⟪« PG-DeclareRegExpUnit[#HxRegExpUnit#, #ModuleName, #id] »« PG-DeclareRegExpUnits[#HxRegExpUnits#, #ModuleName, #id] »⟫
;
PG-DeclareRegExpUnits[%rawHxRegExpUnits⟪ ⟫, #ModuleName, #id]
→
%n⟪⟫
;

PG-DeclareRegExpUnit[HxRegExpUnit, $String<!--ModuleName-->, $String] :: Text;
PG-DeclareRegExpUnit[%rawHxRegExpUnit⟪ #HxRegExpSimple# ⟫, #ModuleName, #id] → PG-DeclareRegExpSimple[#HxRegExpSimple#, #ModuleName, #id] ;
PG-DeclareRegExpUnit[%rawHxRegExpUnit⟪ #HxRegExpSimple# ? ⟫, #ModuleName, #id] → PG-DeclareRegExpSimple[#HxRegExpSimple#, #ModuleName, #id] ;
PG-DeclareRegExpUnit[%rawHxRegExpUnit⟪ #HxRegExpSimple# * ⟫, #ModuleName, #id] → PG-DeclareRegExpSimple[#HxRegExpSimple#, #ModuleName, #id] ;
PG-DeclareRegExpUnit[%rawHxRegExpUnit⟪ #HxRegExpSimple# + ⟫, #ModuleName, #id] → PG-DeclareRegExpSimple[#HxRegExpSimple#, #ModuleName, #id] ;
PG-DeclareRegExpUnit[%rawHxRegExpUnit⟪ #HxRegExpSimple# + _ #HxRegExpLeaf# ⟫, #ModuleName, #id] → %n⟪« PG-DeclareRegExpSimple[#HxRegExpSimple#, #ModuleName, #id] »« PG-DeclareRegExpSimple[#HxRegExpLeaf#, #ModuleName, #id] »⟫ ;

PG-DeclareRegExpSimple[HxRegExpSimple, $String<!--ModuleName-->, $String] :: Text;
PG-DeclareRegExpSimple[%rawHxRegExpSimple⟪ #HxString# ⟫, #ModuleName, #id] → %n⟪⟫ ;
PG-DeclareRegExpSimple[%rawHxRegExpSimple⟪ #HxWord# ⟫, #ModuleName, #id] → %n⟪⟫ ;
PG-DeclareRegExpSimple[%rawHxRegExpSimple⟪ #HxFragmentRef# ⟫, #ModuleName, #id] → %n⟪⟫ ;
PG-DeclareRegExpSimple[%rawHxRegExpSimple⟪ . ⟫, #ModuleName, #id] → %n⟪⟫ ;
PG-DeclareRegExpSimple[%rawHxRegExpSimple⟪ #HxRegExpClass# ⟫, #ModuleName, #id] → %n⟪⟫ ;
PG-DeclareRegExpSimple[%rawHxRegExpSimple⟪ ( #HxRegExp# ) ⟫, #ModuleName, #id] → PG-DeclareRegExp[#HxRegExp#, #ModuleName, #id] ;


/////////////////////////////////////////////////////////////////////
// 16. PG TEXT NAMING CONVENTIONS.

// PG token name and constructor.

PG-TokenNameText[$String] :: Text;
-[Data[#Name]]: PG-TokenNameText[#Name] → %n⟪†«#Name»⟫ ; ///%n⟪T†« $[Mangle,$[Trim,#Name]] »⟫ ;

PG-TokenConstructorText[$String<!--ModuleName-->, $String] :: Text;
PG-TokenConstructorText[#ModuleName, #Name] → %n⟪†« PG-QN[#ModuleName, "Token", #Name] »⟫ ;

// PG production (= non-terminal = sort) name and constructor.

PG-ProductionNameText[$String] :: Text;
-[Data[#Name]]: PG-ProductionNameText[#Name] → %n⟪†« #Name »⟫ ;

// PG special production name for non-terminals with precedence.

PG-ProductionNameWithPrecText[$String, $Numeric] :: Text;
-[Data[#Name,#Prec],Copy[#Name,#Prec]]: PG-ProductionNameWithPrecText[#Name, #Prec] → PG-ProductionNameText[$[If, $[NumericEqual,#Prec,0], #Name, $[:,#Name,$[FormatNumber,#Prec]]]] ;

PG-ProductionNameWithPrec[$String, $Numeric] :: $String;
-[Data[#Name,#Prec],Copy[#Name,#Prec]]: PG-ProductionNameWithPrec[#Name, #Prec] → $[If, $[NumericEqual,#Prec,0], #Name, $[:,#Name,$[FormatNumber,#Prec]]] ;

// PG special production name for non-terminals with precedence and repeat...

PG-ProductionNameWithPrecRepeatText[$String, $Numeric, HxRepeat] :: Text;
PG-ProductionNameWithPrecRepeatText[#Name, #Prec, %rawHxRepeat⟪ ⟫] → PG-ProductionNameWithPrecText[#Name, #Prec] ;
PG-ProductionNameWithPrecRepeatText[#Name, #Prec, %rawHxRepeat⟪ ? ⟫]→ %n⟪« PG-ProductionNameWithPrecText[#Name, #Prec] »_Maybe⟫ ;
PG-ProductionNameWithPrecRepeatText[#Name, #Prec, %rawHxRepeat⟪ * ⟫]→ %n⟪« PG-ProductionNameWithPrecText[#Name, #Prec] »_MaybeSome⟫ ;
-[Data[#HxRegExpSimple#]]:
PG-ProductionNameWithPrecRepeatText[#Name, #Prec, %rawHxRepeat⟪ + ⟫]→ %n⟪« PG-ProductionNameWithPrecText[#Name, #Prec] »_Some⟫ ;
-[Data[#HxRegExpLeaf#]]:
PG-ProductionNameWithPrecRepeatText[#Name, #Prec, %rawHxRepeat⟪ + _ #HxRegExpLeaf# ⟫]→ %n⟪« PG-ProductionNameWithPrecText[#Name, #Prec] »« PG-RegExpLeafNameText["", #HxRegExpLeaf#] »⟫ ;

    // Convert regular expression to name fragment...
    PG-RegExpLeafNameText[$String, HxRegExpSimple] :: Text;
    -[Data[#Name,#HxString#]]:      PG-RegExpLeafNameText[#Name, %rawHxRegExpLeaf⟪ #HxString# ⟫] → %n⟪†«#Name»_SomeS†« $[Mangle,#HxString#] »⟫ ;
    -[Data[#Name,#HxWord#]]:        PG-RegExpLeafNameText[#Name, %rawHxRegExpLeaf⟪ #HxWord# ⟫] → %n⟪†«#Name»_SomeW†« $[Mangle,#HxWord#] »⟫ ;


/////////////////////////////////////////////////////////////////////
// X. HELPERS.

// Convert hx module name string to Java style class name.

PG-ClassName[$String] :: $String;
-[Data[#Name]]: PG-ClassName[#Name] → $[Replace, $[Replace, #Name, "/","."], "\"", ""] ;

// Convert hx module name to lower case prefix.

PG-Prefix[$String] :: $String;
-[Data[#Name]]: PG-Prefix[#Name] → $[If, $[Contains,#Name,"."], PG-Prefix[$[AfterFirst,#Name,"."]], $[:,$[Replace,#Name,"\"",""],'/***METAPG:Meta***/$']] ;

// Extract last component of module name.

PG-LastName[$String] :: $String;
-[Data[#Name]]: PG-LastName[#Name]  → $[If, $[Contains,#Name,"."], PG-LastName[$[AfterFirst,#Name,"."]], $[Replace,#Name,"\"",""]] ;
// TODO: Sanity check that it is a capitalized word!

// Create qualified name.

PG-QN[$String<!--ModuleName-->, $String<!--Kind-->, $String<!--LocalName-->] :: $String ;
PG-QN[#ModuleName, #Kind, #Name] → PG-QN2[PG-LastName[#ModuleName], #Kind, #Name] ;
-[Data[#ModuleBase,#Kind,#Name]]: PG-QN2[#ModuleBase, #Kind, #Name] → $[If, $[Contains,#Name,'$'], $[:,#Kind,'_',#Name], $[:,#ModuleBase,'$',#Kind,'_',#Name]] ;

// Local name.

PG-LN[$String<!--BaseName-->, $String<!--Type-->] :: $String ;
-[Data[#BaseName,#Kind]] : PG-LN[#BaseName, #Kind] → $[:,#BaseName,'_',#Kind] ;

// Generate sort name for sort with repetition.

PG-SortNameWithRepeat[HxSort, HxRepeat] :: $String;
PG-SortNameWithRepeat[#Sort, #Repeat] → PG-SortNameWithRepeat1[PG-SortName[#Sort], #Repeat] ;
PG-SortNameWithRepeat1[$String, HxRepeat] :: $String;
-[Data[#FullSortName]] : PG-SortNameWithRepeat1[#FullSortName, #Repeat] → If[SameString["", #FullSortName], "", PG-SortNameWithRepeat2[#FullSortName, #Repeat]] ;
PG-SortNameWithRepeat2[$String, HxRepeat] :: $String;
PG-SortNameWithRepeat2[#FullSortName, %rawHxRepeat⟪ ⟫] → #FullSortName ;
PG-SortNameWithRepeat2[#FullSortName, %rawHxRepeat⟪ ? ⟫] → $[:,#FullSortName,"_Maybe"] ;
PG-SortNameWithRepeat2[#FullSortName, %rawHxRepeat⟪ * ⟫] → $[:,#FullSortName,"_MaybeSome"] ;
PG-SortNameWithRepeat2[#FullSortName, %rawHxRepeat⟪ + ⟫] → $[:,#FullSortName,"_Some"] ;
PG-SortNameWithRepeat2[#FullSortName, %rawHxRepeat⟪ + _ #HxRegExpLeaf# ⟫] → RegExpLeafSuffix[#HxRegExpLeaf#, $[:,#FullSortName,"_Some_"]] ;

// Extract sort name from sort.

PG-SortName[HxSort] :: $String;
-[Data[#Sort]]: PG-SortName[#Sort] → PG-SortName2[#Sort] ;

PG-SortName2[HxSort] :: $String;
PG-SortName2[           %rawHxSort⟪ #HxSortName# #HxMetaVariables# #HxSimpleSorts# ⟫] → #HxSortName# ;
PG-SortName2[$[NotMatch,%rawHxSort⟪ #HxSortName# #HxMetaVariables# #HxSimpleSorts# ⟫,#]] →  $[Show,#] ;

PG-BaseSortName[HxSort] :: $String;
-[Data[#Sort]]: PG-BaseSortName[#Sort] → PG-BaseSortName2[#Sort] ;
PG-BaseSortName2[HxSort] :: $String;
PG-BaseSortName2[           %rawHxSort⟪ #HxSortName# #HxMetaVariables# #HxSimpleSorts# ⟫] → #HxSortName# ;
PG-BaseSortName2[$[NotMatch,%rawHxSort⟪ #HxSortName# #HxMetaVariables# #HxSimpleSorts# ⟫,#]] →  "BAD" ;

// Extract inherited map attribute names (from all schemes).

{$String : DeclarationMapEntry} InheritedNames :: NameSet ;
{#DM} InheritedNames → FoldWhen[ok k ns.{#DM} KeepInheritedEntry[ok, k, ns], $[{#DM}Keys[$String]], NoNames] ;

{$String : DeclarationMapEntry} KeepInheritedEntry[Ok, $String, NameSet] :: NameSet;
{#DM} KeepInheritedEntry[OK, #name, #synthesized] → KeepInheritedEntry1[$[{#DM}Get[DeclarationMapEntry], #name, DME_NONE], #synthesized] ;

KeepInheritedEntry1[DeclarationMapEntry, NameSet] :: NameSet;
-[Data[#entry]]:
KeepInheritedEntry1[#entry, #synthesized] → KeepInheritedEntry2[#entry, #synthesized] ;

KeepInheritedEntry2[DeclarationMapEntry, NameSet] :: NameSet;
KeepInheritedEntry2[DME_ATTRIBUTE[%rawHxAttributeKind⟪ ↓ ⟫, #name, #form, #options], #synthesized] → AddName[#synthesized, #name] ;
KeepInheritedEntry2[$[NotMatch,DME_ATTRIBUTE[%rawHxAttributeKind⟪ ↓ ⟫, #name, #form, #options], #_], #synthesized] → #synthesized ;

{$String : DeclarationMapEntry} InheritedMapNames :: NameSet ;
{#DM} InheritedMapNames → FoldWhen[ok k ns.{#DM} KeepInheritedMapEntry[ok, k, ns], $[{#DM}Keys[$String]], NoNames] ;

{$String : DeclarationMapEntry} KeepInheritedMapEntry[Ok, $String, NameSet] :: NameSet;
{#DM} KeepInheritedMapEntry[OK, #name, #inheritedmaps] → KeepInheritedMapEntry1[$[{#DM}Get[DeclarationMapEntry], #name, DME_NONE], #inheritedmaps] ;

KeepInheritedMapEntry1[DeclarationMapEntry, NameSet] :: NameSet;
-[Data[#entry]]:
KeepInheritedMapEntry1[#entry, #inheritedmaps] → KeepInheritedMapEntry2[#entry, #inheritedmaps] ;

KeepInheritedMapEntry2[DeclarationMapEntry, NameSet] :: NameSet;
KeepInheritedMapEntry2[DME_ATTRIBUTE[%rawHxAttributeKind⟪ ↓ ⟫, #name, %rawHxAttributeForm⟪ { #HxSort1# : #HxSort2# } ⟫, #options], #inheritedmaps] → AddName[#inheritedmaps, #name] ;
KeepInheritedMapEntry2[$[NotMatch,DME_ATTRIBUTE[%rawHxAttributeKind⟪ ↓ ⟫, #name, %rawHxAttributeForm⟪ { #HxSort1# : #HxSort2# } ⟫, #options], #_], #inheritedmaps] → #inheritedmaps ;

{$String : DeclarationMapEntry} SynthesizedNames :: NameSet ;
{#DM} SynthesizedNames → FoldWhen[ok k ns.{#DM} KeepSynthesizedEntry[ok, k, ns], $[{#DM}Keys[$String]], NoNames] ;

{$String : DeclarationMapEntry} KeepSynthesizedEntry[Ok, $String, NameSet] :: NameSet;
{#DM} KeepSynthesizedEntry[OK, #name, #synthesized] → KeepSynthesizedEntry1[$[{#DM}Get[DeclarationMapEntry], #name, DME_NONE], #synthesized] ;

KeepSynthesizedEntry1[DeclarationMapEntry, NameSet] :: NameSet;
-[Data[#entry]]:
KeepSynthesizedEntry1[#entry, #synthesized] → KeepSynthesizedEntry2[#entry, #synthesized] ;

KeepSynthesizedEntry2[DeclarationMapEntry, NameSet] :: NameSet;
KeepSynthesizedEntry2[DME_ATTRIBUTE[%rawHxAttributeKind⟪ ↑ ⟫, #name, #form, #options], #synthesized] → AddName[#synthesized, #name] ;
KeepSynthesizedEntry2[$[NotMatch,DME_ATTRIBUTE[%rawHxAttributeKind⟪ ↑ ⟫, #name, #form, #options], #_], #synthesized] → #synthesized ;

{$String : DeclarationMapEntry} SynthesizedMapNames :: NameSet ;
{#DM} SynthesizedMapNames → FoldWhen[ok k ns.{#DM} KeepSynthesizedMapEntry[ok, k, ns], $[{#DM}Keys], NoNames] ;

{$String : DeclarationMapEntry} KeepSynthesizedMapEntry[Ok, $String, NameSet] :: NameSet;
{#DM} KeepSynthesizedMapEntry[OK, #name, #synthesizedmaps] → KeepSynthesizedMapEntry1[$[{#DM}Get[DeclarationMapEntry], #name, DME_NONE], #synthesizedmaps] ;

KeepSynthesizedMapEntry1[DeclarationMapEntry, NameSet] :: NameSet;
-[Data[#entry]]:
KeepSynthesizedMapEntry1[#entry, #synthesizedmaps] → KeepSynthesizedMapEntry2[#entry, #synthesizedmaps] ;

KeepSynthesizedMapEntry2[DeclarationMapEntry, NameSet] :: NameSet;
KeepSynthesizedMapEntry2[DME_ATTRIBUTE[%rawHxAttributeKind⟪ ↑ ⟫, #name, %rawHxAttributeForm⟪ { #HxSort1# : #HxSort2# } ⟫, #options], #synthesizedmaps] → AddName[#synthesizedmaps, #name] ;
KeepSynthesizedMapEntry2[$[NotMatch,DME_ATTRIBUTE[%rawHxAttributeKind⟪ ↑ ⟫, #name, %rawHxAttributeForm⟪ { #HxSort1# : #HxSort2# } ⟫, #options], #_], #synthesizedmaps] → #synthesizedmaps ;







// Errors.

∀ a . CookError[$String] :: a;
-[Data[#message]]: CookError[#message] → $[Error, #message] ;






)] //PG


/// /////////////////////////////////////////////////////////////////////
/// // PG-ProductionNames: Extract top level productions.
/// //
/// // Only include productions for tokens and sorts that have syntax.
/// 
/// {$String<!--SortName--> : DeclarationMapEntry} PG-ProductionNames[$List[$String]] :: $List[$String];
/// {#DM}PG-ProductionNames[()] → () ;
/// {#DM}PG-ProductionNames[(#1;#s)] → {#DM}PG-ProductionNames2[$[{#DM}Get[DeclarationMapEntry],#1,DME_NONE], #1, #s] ;
/// 
/// {$String<!--SortName--> : DeclarationMapEntry} PG-ProductionNames2[DeclarationMapEntry, $String, $List[$String]] :: $List[$String];
/// {#DM}PG-ProductionNames2[DME_NONE, #1, #s] → {#DM}PG-ProductionNames[#s] ;
/// {#DM}PG-ProductionNames2[DME_TOKEN[#SortName], #1, #s] → (#1 ; {#DM}PG-ProductionNames[#s]) ;
/// {#DM}PG-ProductionNames2[DME_ATTRIBUTE[#Kind, #Name, #AttributeForm, #AttributeOptions], #1, #s] → {#DM}PG-ProductionNames[#s] ;
/// {#DM}PG-ProductionNames2[DME_SORT[#Defines, #SortName, #Precs, #Wrapper], #1, #s] → {#DM}PG-ProductionNames3[#Defines, #1, #s] ;
/// 
/// {$String<!--SortName--> : DeclarationMapEntry} PG-ProductionNames3[$List[Define], $String, $List[$String]] :: $List[$String];
/// -[Fresh[dummy::HxSortParam]]:
/// {#DM} PG-ProductionNames3[(D_ABSTRACTION[a.#Define1[a]]; #Defines), #1, #s] → {#DM} PG-ProductionNames3[(#Define1[dummy]; #Defines), #1, #s] ;
/// {#DM} PG-ProductionNames3[(D_RULE[#Rule, #RuleSort, #IsData]; #Defines), #1, #s] → {#DM} PG-ProductionNames3[#Defines, #1, #s] ;
/// {#DM} PG-ProductionNames3[(D_FORM[#Form1, #Kind1]; #Defines), #1, #s] → {#DM} PG-ProductionNames4[#Form1, #Defines, #1, #s] ;
/// {#DM} PG-ProductionNames3[(D_NONE; #Defines), #1, #s] → {#DM} PG-ProductionNames3[#Defines, #1, #s] ;
/// {#DM} PG-ProductionNames3[(), #1, #s] → {#DM}PG-ProductionNames[#s] ;
/// 
/// {$String<!--SortName--> : DeclarationMapEntry} PG-ProductionNames4[HxForm, $List[Define], $String, $List[$String]] :: $List[$String];
/// {#DM} PG-ProductionNames4[Hx_M_FormParsedSorted[#Sort1, #ParsedForm1, #Prec1, #InheritedRefs], #Defines, #1, #s] → (#1; {#DM}PG-ProductionNames[#s]) ;
/// {#DM} PG-ProductionNames4[Hx_M_FormParsed[#ParsedForm1, #Prec1, #InheritedRefs], #Defines, #1, #s] → (#1; {#DM}PG-ProductionNames[#s]) ;
/// {#DM} PG-ProductionNames4[Hx_M_FormConstruction[#Constructor, #ScopeSortList, #InheritedRefs], #Defines, #1, #s] → {#DM} PG-ProductionNames3[#Defines, #1, #s] ;
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// /////////////////////////////////////////////////////////////////////
/// 
/// 
/// /////////////////////////////////////////////////////////////////////
/// // TEXT LIST OF REPEAT-DERIVED DECLARATIONS.
/// 
/// PG-ProduceDerived[DERIVED_SORT] :: TextMapSort;
/// PG-ProduceDerived[DERIVED[#SortName, #Prec, #Repeat]] → PG-ProduceRepeat[#Repeat, #SortName, #Prec, PG-ProductionNameWithPrecRepeatText[#SortName, #Prec, #Repeat]] ; 
/// 
/// PG-ProduceRepeat[HxRepeat, $String, $Numeric, Text] :: TextMapSort;
/// 
/// PG-ProduceRepeat[%rawHxRepeat⟪ ⟫, #s, #p, #name] → EmptyTextMap ;
/// 
/// -[Data[#s]]:
/// PG-ProduceRepeat[%rawHxRepeat⟪ ? ⟫, #s, #p, #name]
/// →
/// SingletonTextMap[TextToString[#name], %n⟪
/// <«#name»> ::= «
///   PG-MetaHead[B_TRUE, #ModuleName, $[:,#s,"?"], TextToString[#name], B_FALSE, 0]
/// »( <«PG-ProductionNameWithPrecText[#s, #p]»>:#1 {{ $Cons[#1,$Nil] }} | {{ $Nil }} ).
/// « PG-MetaTail[B_TRUE, $[:,#s,"?"], TextToString[#name]] »⟫]
/// ;
/// 
/// -[Data[#s]]:
/// PG-ProduceRepeat[%rawHxRepeat⟪ * ⟫, #s, #p, #name]
/// →
/// SingletonTextMap[TextToString[#name], %n⟪
/// <«#name»> ::= «
///   PG-MetaHead[B_TRUE, #ModuleName, $[:,#s,"*"], TextToString[#name], B_FALSE, 0]
/// »( <«PG-ProductionNameWithPrecText[#s, #p]»>:#1 <«#name»>:#2 {{ $Cons[#1,#2] }} | {{ $Nil }} ).
/// « PG-MetaTail[B_TRUE, $[:,#s,"*"], TextToString[#name]] »⟫]
/// ;
/// 
/// -[Data[#s]]:
/// PG-ProduceRepeat[%rawHxRepeat⟪ + ⟫, #s, #p, #name]
/// →
/// SingletonTextMap[TextToString[#name], %n⟪
/// <«#name»> ::= «
///   PG-MetaHead[B_TRUE, #ModuleName, $[:,#s,"+"], TextToString[#name], B_FALSE, 0]
/// » <«PG-ProductionNameWithPrecText[#s, #p]»>:#1 ( <«#name»>:#2 {{ $Cons[#1,#2] }} | {{ $Cons[#1,$Nil] }} ) .
/// « PG-MetaTail[B_TRUE, $[:,#s,"+"], TextToString[#name]] »⟫]
/// ;
/// 
/// -[Data[#s]]:
/// PG-ProduceRepeat[%rawHxRepeat⟪ + _ #HxRegExpLeaf# ⟫, #s, #p, #name]
/// →
/// SingletonTextMap[TextToString[#name], %n⟪
/// <«#name»> ::= «
///   PG-MetaHead[B_TRUE, #ModuleName, RegExpLeafSuffix[#HxRegExpLeaf#, $[:,#s,"+_"]], TextToString[#name], B_FALSE, 0]
/// » <«PG-ProductionNameWithPrecText[#s, #p]»>:#1 ( « PG-InlineRegExpSimple[#HxRegExpLeaf#, ""] » <«#name»>:#2 {{ $Cons[#1,#2] }} | {{ $Cons[#1,$Nil] }} ) .
/// « PG-MetaTail[B_TRUE, RegExpLeafSuffix[#HxRegExpLeaf#, $[:,#s,"+_"]], TextToString[#name]] »⟫]
/// ;
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// /////////////////////////////////////////////////////////////////////
/// /////////////////////////////////////////////////////////////////////
/// 
/// // CookBase.crs: CRSX3 SUPPORT LIBRARY FOR HACS PREPROCESSOR OPERATIONS.
/// //
/// // Declarations here depend only on the Prelude and the Hx syntax.
/// //
/// CookBase[(
/// 
/// $Use["org/crsx/hacs/Prelude.crs"];
/// 
/// // Syntax and sorts of hx terms (%rawHx...⟪...⟫).
/// $Use["org/crsx/hacs/Hx.crs"];
/// 
/// // Syntax and sorts of text (%n⟪...⟫).
/// $CheckGrammar["net.sf.crsx.text.Text"];
/// $Use["net/sf/crsx/text/Text.crs"];
/// 
/// $Lax;
/// 
/// /////////////////////////////////////////////////////////////////////
/// // LOCATION EXTRACTION.
/// 
/// $StringEntrySort ::=( STRING[$String]; );
/// 
/// {$String : $StringEntrySort}MakeLocation :: $String;
/// {#L}MakeLocation → MakeLocation2[$[{#L}Get[$StringEntrySort],"$FileLocation",STRING[""]], $[{#L}Get[$StringEntrySort],"$LineLocation",STRING[""]], $[{#L}Get[$StringEntrySort],"$ColumnLocation",STRING[""]]] ;
/// MakeLocation2[$StringEntrySort, $StringEntrySort, $StringEntrySort] :: $String;
/// MakeLocation2[STRING[#file], STRING[#line], STRING[#column]] → $[:,#file," ",#line,":",#column] ;
/// 
/// 
/// 
/// /////////////////////////////////////////////////////////////////////
/// // SORT EXTRACTION.
/// 
/// ScopePG-SortName[HxScopeSort] :: $String;
/// ScopePG-SortName[%rawHxScopeSort⟪ #HxSort# #HxRepeat# [ #HxSubstituteSorts# ] ⟫] → SortNameWithRepeat[#HxSort#, #HxRepeat#] ;
/// -[Free[v::Text]]:
/// ScopePG-SortName[%rawHxScopeSort⟪ [ v : #HxSort# ] ⟫                  ] → PG-SortName[#HxSort#] ;
/// -[Free[v::Text]]:
/// ScopePG-SortName[%rawHxBindersScopeSort⟪ [ v : #HxSort# ] #HxBindersScopeSort# ⟫] → ScopePG-SortName[#HxBindersScopeSort#] ;
/// 
/// ScopeSortMetaVar[HxScopeSort, $Numeric] :: $String;
/// -[Discard[#HxSubstituteSorts#]]: ScopeSortMetaVar[%rawHxScopeSort⟪ #HxSort# [ #HxSubstituteSorts# ] ⟫, #n] → SortMetaVar[#HxSort#, #n] ;
/// -[Free[v::Text]]: ScopeSortMetaVar[%rawHxScopeSort⟪ [ v : #HxSort# ] ⟫                  , #n] → SortMetaVar[#HxSort#, #n] ;
/// 

/// 
/// 
/// 
/// 
/// 
/// /////////////////////////////////////////////////////////////////////
/// // PRODUCTION NAMES.
/// 
/// 
/// /////////////////////////////////////////////////////////////////////
/// // ERRORS.
/// 
/// 
/// /////////////////////////////////////////////////////////////////////
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 


/// 
/// 
/// /////////////////////////////////////////////////////////////////////
/// // COMPARISON OF FORMS.
/// 
/// 
/// 
/// 
/// 
/// /////////////////////////////////////////////////////////////////////
/// // Extract all repeat-derived sort forms from DM structure.
/// 
/// DERIVED_SORT ::=( DERIVED[$String, $Numeric<!--Precedence-->, HxRepeat]; );
/// 
/// {$String<!--SortName--> : DeclarationMapEntry} DerivedSorts[NameSet] :: $List[DERIVED_SORT];
/// {#DM} DerivedSorts[#Names] → FoldNamesWhen[ok x y.{#DM} Then-DerivedSorts2[ok, x, y], #Names, ()] ;
/// 
/// {$String<!--SortName--> : DeclarationMapEntry} Then-DerivedSorts2[Ok, $String, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// {#DM} Then-DerivedSorts2[OK, #name, #derived] → DerivedSorts2[$[{#DM}Get[DeclarationMapEntry], #name, DME_NONE], #derived];
/// 
/// DerivedSorts2[DeclarationMapEntry, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// 
/// DerivedSorts2[DME_NONE, #derived] → #derived ;
/// DerivedSorts2[DME_TOKEN[#name], #derived] → #derived ;
/// DerivedSorts2[DME_ATTRIBUTE[#kind, #name, #form, #options], #derived] → #derived ;
/// 
/// DerivedSorts2[DME_SORT[#Defines, #Name, #Precs, #Wrapper], #derived]
/// →
/// FoldWhen[ok defined derived.Then-DerivedSorts-Defines[ok, defined, derived], #Defines, #derived]
/// ;
/// 
/// Then-DerivedSorts-Defines[Ok, Define, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// -[Fresh[dummy::HxSortParam]]: Then-DerivedSorts-Defines[OK, D_ABSTRACTION[a . #Define[a]], #derived] → Then-DerivedSorts-Defines[OK, #Define[dummy], #derived] ;
/// Then-DerivedSorts-Defines[OK, D_FORM[#Form, #Kind], #derived] → DerivedSorts-Form[#Form, #derived] ;
/// Then-DerivedSorts-Defines[OK, D_RULE[#Rule, #SortName, #IsDataEquivalence], #derived] → DerivedSorts-Rule[#Rule, #derived] ;
/// Then-DerivedSorts-Defines[OK, D_SYNTHESIZES[#AttributeName], #derived] → #derived ;
/// Then-DerivedSorts-Defines[OK, D_NONE, #derived] → #derived ;
/// 
/// DerivedSorts-Form[HxForm, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-Form[Hx_M_FormParsedSorted[#HxSort#, #HxParsedForm#, #HxPrec#, #InheritedRefs], #derived] → DerivedSorts-ParsedForm[#HxParsedForm#, #derived] ;
/// DerivedSorts-Form[Hx_M_FormParsed[#HxParsedForm#, #HxPrec#, #InheritedRefs], #derived] → DerivedSorts-ParsedForm[#HxParsedForm#, #derived] ;
/// DerivedSorts-Form[Hx_M_FormConstruction[#HxConstructor#, #HxScopeSorts#, #InheritedRefs], #derived] → #derived ;
/// 
/// DerivedSorts-ParsedForm[HxParsedForm, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-ParsedForm[Hx_M_ParsedFormWord[#Word, #ParsedForm], #derived] → DerivedSorts-ParsedForm[#ParsedForm, #derived] ;
/// DerivedSorts-ParsedForm[Hx_M_ParsedFormSpace[#Space, #ParsedForm], #derived] → DerivedSorts-ParsedForm[#ParsedForm, #derived] ;
/// DerivedSorts-ParsedForm[Hx_M_ParsedFormDone, #derived] → #derived ;
/// DerivedSorts-ParsedForm[Hx_M_ParsedFormTerm[Hx_M_ScopeSortPrecRepeat[#ScopeSort, #Precedence, #Repeat], #ParsedForm], #derived]
/// →
/// DerivedSorts-ScopeSort[#ScopeSort, #Precedence, #Repeat, DerivedSorts-ParsedForm[#ParsedForm, #derived]]
/// ;
/// 
/// DerivedSorts-ScopeSort[HxScopeSort, $Numeric, HxRepeat, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-ScopeSort[%rawHxScopeSort⟪ #HxSort# #HxRepeat# [ #HxSubstituteSorts1# ] ⟫, #Precedence, #Repeat, #derived] → DerivedSorts-Sort[#HxSort#, #Precedence, NestedRepeat[#HxRepeat#, #Repeat], #derived] ;
/// -[Free[v::Text]]:
/// DerivedSorts-ScopeSort[%rawHxScopeSort⟪ [ v : #HxSort# ] ⟫, #Precedence, #Repeat, #derived] → #derived ;
/// 
/// DerivedSorts-Sort[HxSort, $Numeric, HxRepeat, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// -[Data[#Repeat]]:
/// DerivedSorts-Sort[#Sort, #Precedence, #Repeat, #derived] → DerivedSorts-Sort2[#Repeat, #Precedence, PG-BaseSortName[#Sort], #derived] ;
/// 
/// DerivedSorts-Sort2[HxRepeat, $Numeric, $String, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-Sort2[%rawHxRepeat⟪ ⟫, #Precedence, #Name, #derived] → #derived ;
/// -[Data[#Repeat,#Name]]:
/// DerivedSorts-Sort2[$[NotMatch,%rawHxRepeat⟪ ⟫,#Repeat], #Precedence, #Name, #derived]
/// →
/// $[IfEmpty, #Name, #derived, (DERIVED[#Name, #Precedence, #Repeat] ; #derived)]
/// ;
/// 
/// DerivedSorts-Rule[HxRule, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-Rule[%rawHxRule⟪ #HxPriority# #HxConstruction# : #HxConstruction_Pattern# → #HxTerm_Contraction# ⟫, #derived]
/// →
/// DerivedSorts-Term[#HxConstruction_Pattern#, DerivedSorts-Term[#HxTerm_Contraction#, #derived]]
/// ;
/// 
/// DerivedSorts-Term[HxTerm, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// 
/// DerivedSorts-Term[Hx_M_OMITTED, #derived] → #derived ;
/// 
/// -[Free[v::Text]]:
/// DerivedSorts-Term[%rawHxTerm⟪ v #HxAttributes# ⟫, #derived] → DerivedSorts-Attributes[#HxAttributes#, #derived] ;
/// 
/// -[Free[v::Text]]:
/// DerivedSorts-Term[%rawHxTerm⟪ #HxConstructor# #HxRepeat# v #HxAttributes# ⟫, #derived]
/// →
/// DerivedSorts-Repeat[#HxConstructor#, #HxRepeat#, DerivedSorts-Attributes[#HxAttributes#, #derived]] ;
/// 
/// DerivedSorts-Term[%rawHxTerm⟪ #HxLiteral# #HxAttributes# ⟫, #derived] → DerivedSorts-Attributes[#HxAttributes#, #derived] ;
/// 
/// DerivedSorts-Term[Hx_M_Unparsed[#Unparsed, #Attributes], #derived] → #derived ;
/// DerivedSorts-Term[Hx_M_UnparsedSorted[#Name, #Repeat, #Unparsed, #Attributes], #derived] → #derived ;
/// 
/// DerivedSorts-Term[%rawHxTerm⟪ #HxConstructor# (#HxScopes#) #HxAttributes# ⟫, #derived] → DerivedSorts-Scopes[#HxScopes#, DerivedSorts-Attributes[#HxAttributes#, #derived]] ;
/// 
/// DerivedSorts-Term[%rawHxTerm⟪ #HxConstructor1# #HxRepeat# #HxConstructor# (#HxScopes#) #HxAttributes# ⟫, #derived]
/// →
/// DerivedSorts-Repeat[#HxConstructor1#, #HxRepeat#, DerivedSorts-Scopes[#HxScopes#, DerivedSorts-Attributes[#HxAttributes#, #derived]]]
/// ;
/// 
/// DerivedSorts-Term[%rawHxTerm⟪ #HxMetaVariable# [#HxTerms#] #HxAttributes# ⟫, #derived]
/// →
/// DerivedSorts-Terms[#HxTerms#, DerivedSorts-Attributes[#HxAttributes#, #derived]]
/// ;
/// 
/// DerivedSorts-Term[%rawHxTerm⟪ #HxConstructor_Sort# #HxRepeat# #HxMetaVariable# [#HxTerms#] #HxAttributes# ⟫, #derived]
/// →
/// DerivedSorts-Repeat[#HxConstructor_Sort#, #HxRepeat#, DerivedSorts-Terms[#HxTerms#, #derived]]
/// ;
/// 
/// DerivedSorts-Term[Hx_M_Special[#v, #Concrete], #derived] → #derived ;
/// 
/// DerivedSorts-Repeat[$String, HxRepeat, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-Repeat[#Name, %rawHxRepeat⟪ ⟫, #derived] → #derived ;
/// -[Data[#Name,#Repeat]]: DerivedSorts-Repeat[#Name, $[NotMatch,%rawHxRepeat⟪ ⟫,#Repeat], #derived]
/// →
/// $[IfEmpty, #Name, #derived, (DERIVED[#Name, 0, #Repeat] ; #derived)]
/// ;
/// 
/// DerivedSorts-Scopes[$List[HxScope], $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-Scopes[#Scopes, #derived] → FoldWhen[ok scope derived.Then-DerivedSorts-Scope[ok, scope, derived], #Scopes, #derived] ;
/// 
/// Then-DerivedSorts-Scope[Ok, HxScope, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// Then-DerivedSorts-Scope[OK, Hx_M_Scope[#vs, #Term], #derived] → DerivedSorts-Term[#Term, #derived] ;
/// 
/// DerivedSorts-Terms[$List[HxTerm], $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-Terms[#Terms, #derived] → FoldWhen[ok term derived.Then-DerivedSorts-Term[ok, term, derived], #Terms, #derived] ;
/// 
/// Then-DerivedSorts-Term[Ok, HxTerm, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// Then-DerivedSorts-Term[OK, #Term, #derived] → DerivedSorts-Term[#Term, #derived] ;
/// 
/// DerivedSorts-Attributes[$List[HxAttribute], $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-Attributes[(), #derived] → #derived ;
/// DerivedSorts-Attributes[(#a1;#as), #derived] → DerivedSorts-Attribute[#a1, DerivedSorts-Attributes[#as, #derived]] ;
/// 
/// DerivedSorts-Attribute[HxAttribute, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-Attribute[%rawHxAttribute⟪ #HxAttributeKind# #HxAttributeName# ( #HxTerm# ) ⟫, #derived] → DerivedSorts-Term[#HxTerm#, #derived] ;
/// DerivedSorts-Attribute[%rawHxAttribute⟪ #HxAttributeKind# #HxAttributeName# { #HxTerm# } ⟫, #derived] → DerivedSorts-Term[#HxTerm#, #derived] ;
/// DerivedSorts-Attribute[%rawHxAttribute⟪ #HxAttributeKind# #HxAttributeName# { #HxTerm1# : #HxTerm2# } ⟫, #derived] → DerivedSorts-Term[#HxTerm1#, DerivedSorts-Term[#HxTerm2#, #derived]] ;
/// DerivedSorts-Attribute[%rawHxAttribute⟪ #HxAttributeKind# #HxAttributeName# { ¬ #HxTerm# } ⟫, #derived] → DerivedSorts-Term[#HxTerm#, #derived] ;
/// 
/// // Name.
/// ProductionNameDerived[DERIVED_SORT] :: Text;
/// ProductionNameDerived[DERIVED[#Name, #Prec, #Repeat]] → PG-ProductionNameWithPrecRepeatText[#Name, #Prec, #Repeat] ;
/// 
/// Un$Hx[HxTerm] :: HxTerm ;
/// Un$Hx[#] → # ;
/// 
/// /////////////////////////////////////////////////////////////////////
/// // Extract scope sorts for unparsed constructor.
/// 
/// {$String : DeclarationMapEntry}
/// ConstructorScopeSorts[$String<!--SortName-->, $String<!--Constructor-->] :: Lifted[$List[HxScopeSort]] ;
/// 
/// -[Data[#TopSortName]]:
/// {#DM}ConstructorScopeSorts[#TopSortName, #Constructor]
/// →
/// ConstructorScopeSorts0[$[{#DM}Get[DeclarationMapEntry], #TopSortName, DME_NONE], #Constructor]
/// ;
/// 
/// ConstructorScopeSorts0[DeclarationMapEntry, $String<!--Constructor-->] :: Lifted[$List[HxScopeSort]] ;
/// -[Data[#Entry, #Constructor]]:
/// ConstructorScopeSorts0[#Entry, #Constructor]
/// →
/// ConstructorScopeSorts1[#Entry, #Constructor]
/// ;
/// 
/// ConstructorScopeSorts1[DeclarationMapEntry, $String<!--Constructor-->] :: Lifted[$List[HxScopeSort]] ;
/// 
/// ConstructorScopeSorts1[DME_SORT[#Defines, #Name, #Precs, #Wrapper], #Constructor]
/// →
/// ConstructorScopeSorts2[#Defines, #Constructor]
/// ;
/// ConstructorScopeSorts1[$[NotMatch,DME_SORT[#Defines, #Name, #Precs, #Wrapper],#_], #Constructor] → BOTTOM ;
/// 
/// ConstructorScopeSorts2[$List[Define], $String<!--Constructor-->] :: Lifted[$List[HxScopeSort]] ;
/// 
/// ConstructorScopeSorts2[(), #Constructor] → BOTTOM ;
/// 
/// -[Fresh[param::HxSortParam]]:
/// ConstructorScopeSorts2[(D_ABSTRACTION[a.#Define[a]]; #Defines), #Constructor] → ConstructorScopeSorts2[(#Define[param]; #Defines), #Constructor] ;
/// 
/// ConstructorScopeSorts2[(D_RULE[#Rule, #sort, #IsDataEquivalence?]; #Defines), #Constructor] → ConstructorScopeSorts2[#Defines, #Constructor] ;
/// 
/// ConstructorScopeSorts2[(D_FORM[#Form, #Kind]; #Defines), #Constructor]
/// →
/// ConstructorScopeSorts3[#Form, #Defines, #Constructor]
/// ;
/// 
/// ConstructorScopeSorts2[(D_SYNTHESIZES[#AttributeName]; #Defines), #Constructor] → ConstructorScopeSorts2[#Defines, #Constructor] ;
/// 
/// ConstructorScopeSorts3[HxForm, $List[Define], $String<!--Constructor-->] :: Lifted[$List[HxScopeSort]] ;
/// -[Data[#Constructor1,#Constructor2]]:
/// ConstructorScopeSorts3[Hx_M_FormConstruction[#Constructor1, #ScopeSorts, #InheritedRefs], #Defines, #Constructor2]
/// →
/// $[If, $[Equal,#Constructor1,#Constructor2], LIFTED[#ScopeSorts], ConstructorScopeSorts2[#Defines, #Constructor2]]
/// ;
/// -[Data[#_]]:
/// ConstructorScopeSorts3[$[NotMatch,Hx_M_FormConstruction[#Constructor, #ScopeSorts, #InheritedRefs],#_], #Defines, #Constructor2] → ConstructorScopeSorts2[#Defines, #Constructor2] ;
/// 
/// 
/// /////////////////////////////////////////////////////////////////////
/// // Extract sort names.
/// 
/// {$String : DeclarationMapEntry} SortNameList :: $List[$String] ;
/// {#DM} SortNameList → {#DM} SortNameList2[$[{#DM}Keys[$String]]] ;
/// 
/// {$String : DeclarationMapEntry} SortNameList2[$List[$String]] :: $List[$String] ;
/// {#DM} SortNameList2[()] → () ;
/// {#DM} SortNameList2[(#Name; #Names)] → {#DM} SortNameList3[$[{#DM}Get[DeclarationMapEntry], #Name], #Names] ;
/// 
/// {$String : DeclarationMapEntry} SortNameList3[DeclarationMapEntry, $List[$String]] :: $List[$String] ;
/// {#DM} SortNameList3[DME_SORT[#Defines1, #Name1, #Precs1, #Wrapper1], #Names]
/// →
/// (#Name1 ; {#DM} SortNameList2[#Names])
/// ; 
/// 
/// {#DM} SortNameList3[$[NotMatch, DME_SORT[#Defines1, #Name1, #Precs1, #Wrapper1], #_], #Names]
/// →
/// {#DM} SortNameList2[#Names]
/// ;
/// 
/// 
/// /////////////////////////////////////////////////////////////////////
/// // Extract token names.
/// 
/// {$String : DeclarationMapEntry} TokenNameList :: $List[$String] ;
/// {#DM} TokenNameList → {#DM} TokenNameList2[$[{#DM}Keys[$String]]] ;
/// 
/// {$String : DeclarationMapEntry} TokenNameList2[$List[$String]] :: $List[$String] ;
/// {#DM} TokenNameList2[()] → () ;
/// {#DM} TokenNameList2[(#Name; #Names)] → {#DM} TokenNameList3[$[{#DM}Get[DeclarationMapEntry], #Name], #Name, #Names] ;
/// 
/// {$String : DeclarationMapEntry} TokenNameList3[DeclarationMapEntry, $String, $List[$String]] :: $List[$String] ;
/// {#DM} TokenNameList3[DME_TOKEN[#String1], #Name, #Names]
/// →
/// (#Name ; {#DM} TokenNameList2[#Names])
/// ; 
/// 
/// {#DM} TokenNameList3[$[NotMatch, DME_TOKEN[#String1], #_], #Name, #Names]
/// →
/// {#DM} TokenNameList2[#Names]
/// ;
/// 
/// 
/// /////////////////////////////////////////////////////////////////////
/// // Extract attribute names.
/// 
/// {$String : DeclarationMapEntry} AttributeNameList :: $List[$String] ;
/// {#DM} AttributeNameList → {#DM} AttributeNameList2[$[{#DM}Keys[$String]]] ;
/// 
/// {$String : DeclarationMapEntry} AttributeNameList2[$List[$String]] :: $List[$String] ;
/// {#DM} AttributeNameList2[()] → () ;
/// {#DM} AttributeNameList2[(#Name; #Names)] → {#DM} AttributeNameList3[$[{#DM}Get[DeclarationMapEntry], #Name], #Names] ;
/// 
/// {$String : DeclarationMapEntry} AttributeNameList3[DeclarationMapEntry, $List[$String]] :: $List[$String] ;
/// {#DM} AttributeNameList3[DME_ATTRIBUTE[#HxAttributeKind#, #HxAttributeName#, #HxAttributeForm#, #HxAttributeOptions#], #Names]
/// →
/// (#HxAttributeName# ; {#DM} AttributeNameList2[#Names])
/// ; 
/// 
/// {#DM} AttributeNameList3[$[NotMatch, DME_ATTRIBUTE[#HxAttributeKind#, #HxAttributeName#, #HxAttributeForm#, #HxAttributeOptions#], #_], #Names]
/// →
/// {#DM} AttributeNameList2[#Names]
/// ;
/// 
/// 
/// /////////////////////////////////////////////////////////////////////
/// 
/// 
/// /////////////////////////////////////////////////////////////////////
/// // Sort name for attribute value.
/// 
/// {$String : DeclarationMapEntry} AttributeValuePG-SortName[$String] :: $String;
/// {#DM}AttributeValuePG-SortName[#AttributeName] → {#DM}AttributeValueSortName1[$[{#DM}Get[DeclarationMapEntry], #AttributeName, DME_NONE], #AttributeName] ;
/// 
/// {$String : DeclarationMapEntry} AttributeValueSortName1[DeclarationMapEntry, $String] :: $String;
/// -[Data[#Entry]]:
/// {#DM}AttributeValueSortName1[#Entry, #AttributeName] → {#DM}AttributeValueSortName2[#Entry, #AttributeName] ;
/// 
/// {$String : DeclarationMapEntry} AttributeValueSortName2[DeclarationMapEntry, $String] :: $String;
/// {#DM}AttributeValueSortName2[DME_ATTRIBUTE[#AttributeKind, #AttributeName, %rawHxAttributeForm⟪ ( #HxSort# ) ⟫, #AttributeOptions], #SortName] → PG-SortName[#HxSort#];
/// {#DM}AttributeValueSortName2[DME_ATTRIBUTE[#AttributeKind, #AttributeName, %rawHxAttributeForm⟪ { #HxSort# } ⟫, #AttributeOptions], #SortName] → "";
/// {#DM}AttributeValueSortName2[DME_ATTRIBUTE[#AttributeKind, #AttributeName, %rawHxAttributeForm⟪ { #HxSort1# : #HxSort2# } ⟫, #AttributeOptions], #SortName] → PG-SortName[#HxSort2#];
/// -[Data[#_]]: {#DM}AttributeValueSortName2[$[NotMatch,DME_ATTRIBUTE[#AttributeKind, #AttributeName, #AttributeForm, #AttributeOptions],#_], #SortName] → $[Error,"No declaration of attribute"] ;
/// 
/// {$String : DeclarationMapEntry} AttributeKeyPG-SortName[$String] :: $String;
/// {#DM}AttributeKeyPG-SortName[#SortName] → {#DM}AttributeKeySortName1[$[{#DM}Get[DeclarationMapEntry], #SortName, DME_NONE], #SortName] ;
/// 
/// {$String : DeclarationMapEntry} AttributeKeySortName1[DeclarationMapEntry, $String] :: $String;
/// -[Data[#Entry]]:
/// {#DM}AttributeKeySortName1[#Entry, #SortName] → {#DM}AttributeKeySortName2[#Entry, #SortName] ;
/// 
/// {$String : DeclarationMapEntry} AttributeKeySortName2[DeclarationMapEntry, $String] :: $String;
/// {#DM}AttributeKeySortName2[DME_ATTRIBUTE[#AttributeKind, #AttributeName, %rawHxAttributeForm⟪ ( #HxSort# ) ⟫, #AttributeOptions], #SortName] → "" ;
/// {#DM}AttributeKeySortName2[DME_ATTRIBUTE[#AttributeKind, #AttributeName, %rawHxAttributeForm⟪ { #HxSort# } ⟫, #AttributeOptions], #SortName] → PG-SortName[#HxSort#];
/// {#DM}AttributeKeySortName2[DME_ATTRIBUTE[#AttributeKind, #AttributeName, %rawHxAttributeForm⟪ { #HxSort1# : #HxSort2# } ⟫, #AttributeOptions], #SortName] → PG-SortName[#HxSort1#];
/// {#DM}AttributeKeySortName2[$[NotMatch,DME_ATTRIBUTE[#AttributeKind, #AttributeName, #AttributeForm, #AttributeOptions],#_], #SortName] → "" ;
/// 
/// 
/// /////////////////////////////////////////////////////////////////////
/// // Initialize otherwise unused maps.
/// 
/// {$String : DeclarationMapEntry} PG-InitOtherMaps[$List[HxAttribute], $String] :: Text;
/// 
/// {#DM; "$AllInheritedMapNames" : NAMES[#InheritedMapNames]}
/// PG-InitOtherMaps[#Attributes, #sep] → PG-InitOtherMaps1[FoldWhen[ok a ns.ThenRemoveAttributeName[ok, a, ns], #Attributes, #InheritedMapNames], #sep, $False] ;
/// 
/// {$String : DeclarationMapEntry} PG-CaptureOtherMaps[$List[HxAttribute]] :: Text;
/// {#DM; "$AllInheritedMapNames" : NAMES[#InheritedMapNames]}
/// PG-CaptureOtherMaps[#Attributes] → PG-InitOtherMaps1[FoldWhen[ok a ns.ThenRemoveAttributeName[ok, a, ns], #Attributes, #InheritedMapNames], "; ", $True] ;
/// 
/// ThenRemoveAttributeName[Ok, HxAttribute, NameSet] :: NameSet;
/// ThenRemoveAttributeName[OK, %rawHxAttribute⟪ #HxAttributeKind# #HxAttributeName# #HxAttributeValue# ⟫, #MapNames] → RemoveName[#MapNames, #HxAttributeName#] ;
/// 
/// PG-InitOtherMaps1[NameSet, $String, $Boolean] :: Text;
/// PG-InitOtherMaps1[#MapNames, #sep, #capture] → PG-InitOtherMaps2[NameSetList[#MapNames], #sep, #capture] ;
/// 
/// PG-InitOtherMaps2[$List[$String], $String, $Boolean] :: Text;
/// PG-InitOtherMaps2[(), #sep, #capture] → %n⟪⟫ ;
/// PG-InitOtherMaps2[(#a;#as), #sep, #capture] → %n⟪†«#sep»"†«#a»" : {« $[If, #capture, %n⟨#InheritedMap_†‹#a›⟩, %n⟨⟩] »}Inherited_†«#a»« PG-InitOtherMaps2[#as, "; ", #capture] »⟫ ;
/// 
/// /////////////////////////////////////////////////////////////////////
/// )]//CookN
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
