// CookPG: RULES FOR CONVERTING HX HACS FORMAT TO PG FORMAT.
//
// Reads the HACS (.hx) file as "Hx" term.
// Emits a CRSX3 ParserGenerator grammar (.pg as text) for the user's terms.
//
// Units:
// 1. Top level (PG)
// 2. Resolve imports (PG-ResolveImports).
// 3. Declaration maps (PG-MapDeclarations).
// 4. Text of all non-terminal productions (PG-Productions).


// 33. PG-Lexical: Text of Lexical Declarations.
// 37. Text naming conventions.

// x. Helpers.


PG[(

// Sorts for generated terms.
$CheckGrammar["org.crsx.hacs.HxRaw"];
///$Use["org/crsx/hacs/HxRaw-sorts.crs"];

// Syntax and sorts of text (%n⟪...⟫).
$CheckGrammar["net.sf.crsx.text.Text"];
$Use["net/sf/crsx/text/Text.crs"];

// Standard prelude.
$Use["org/crsx/hacs/Prelude.crs"];

// Insert options automatically.
$Lax;


/////////////////////////////////////////////////////////////////////
// 1. PG: TOP LEVEL
//
// Convert HACS tree to Text of .pg parser.
//
// PG1: Extract declarations from HACS hx term with all modules inlined.
// PG2: Generate actual text of .pg grammar.

PG[HxModule] :: Text;
PG[%HxModule⟦ module #ModuleName# { #Declarations# } ⟧]
→
PG1[#ModuleName#, PG-ResolveImports[#Declarations#, #ModuleName#]]
;

PG1[$String<!--ModuleName-->, $List[HxDeclaration]] :: Text;
PG1[#ModuleName, #Declarations]
→
PG2[{} PG-MapDeclarations[#Declarations, #ModuleName], #Declarations, #ModuleName]
;

PG2[DeclarationMap, $List[HxDeclaration], $String<!--ModuleName-->] :: Text ;
-[Data[#Declarations]]:
PG2[{#DM}DM, #Declarations, #ModuleName]
→
%n⟪/* PG Grammar for HACS module †« #ModuleName » (generated by %%%VERSION%%%). */

/* INTERFACE. */

class †« PG-ClassName[#ModuleName] » : <†« {#DM}PG-MainSymbol »>« MapTextWrap[n.%n⟨<†‹n›>⟩, {#DM}PG-NonMainSymbols, %n⟨,¶⟩, %n⟨,¶⟩, %n⟨⟩] »

prefix "†« PG-Prefix[#ModuleName] »"

/***METAPG: declarations ***/
/***METAPG: %{ ***/
/***METAPG: String unconcrete(String s) {return s.substring(1, s.length()-1).trim();} ***/
/***METAPG: String unmeta(String s, int skip) {return s.substring(1+skip, s.length()-1).trim();} ***/
/***METAPG: %} ***/

%{
TOKEN_MGR_DECLS : { int nesting; int nestedState;} /* Used by all nesting constructs. */
%}


/***METASORTS: /* META-TERM SORTS. */ ***/
/***METASORTS: ***/
/***METASORTS: †« PG-QN[#ModuleName, "NodeSort", "Term"] » ::= (⟦ ***/
« FoldNamesWhen[ok n t.PG-then-ConstructionSortCaseText[ok, #ModuleName, n, t], {#DM}PG-AllSortNames, %n⟨⟩] »⟧
/***METASORTS: ); ***/
/***METASORTS: †« PG-QN[#ModuleName, "NodeSort", "Scope"] » ::= (⟦ ***/
/***METASORTS: †« PG-QN[#ModuleName, "Tag", "Binder"] »[binder :: †« PG-QN[#ModuleName, "NodeSort", "Term"] » . †« PG-QN[#ModuleName, "NodeSort", "Scope"] »]; ***/
/***METASORTS: †« PG-QN[#ModuleName, "Tag", "Subterm"]»[†« PG-QN[#ModuleName, "NodeSort", "Term"] »]; ⟧ ***/
/***METASORTS: ); ***/


/* GRAMMAR. */
« {#DM}PG-Productions[#ModuleName] »

/* TOKENS. */

« PG-Lexical[#Declarations, #ModuleName] »
⟫
;

PG-then-ConstructionSortCaseText[OK, #ModuleName, #Name, #rest]
→
%n⟪/***METASORTS: †« PG-QN[#ModuleName, "Node", #Name] »[†« PG-QN[#ModuleName, "TagSort", #Name] », $List[†« PG-QN[#ModuleName, "NodeSort", "Scope"] »]]; ***/
« #rest»⟫
;

// ALTERNATE TOP LEVEL:

PG-GetModuleName[HxModule] :: Text;
PG-GetModuleName[%HxModule⟦ module #ModuleName# { #Declarations# } ⟧]
→
%n⟪†«$[Replace,#ModuleName#,"\"",""]»⟫
;



/////////////////////////////////////////////////////////////////////
// 2. PG-ResolveImports: RESOLVE IMPORTS.
//
// Echo full list of declarations with all imported modules inlined. 
// TODO: Alias MyPrefix$Symbol with ImportedPrefix$Symbol for the imported names.

PG-ResolveImports[$List[HxDeclaration], $String] :: $List[HxDeclaration];

Resolve-Import:
PG-ResolveImports[%HxDeclarations⟪ import #ModuleName# ( #SortNames# ) ; #Declarations# ⟫, #ModuleName]
→
PG-ResolveImports[%HxDeclarations⟪ %EmbeddedModule« $[ParseURL, "hxEmbeddedModule", $[Replace,#ModuleName#,"\"",""]] » ; #Declarations# ⟫, #ModuleName]
;

Resolve-Module:
PG-ResolveImports[%HxDeclarations⟪ module #ModuleName2# { #Declarations2# } ; #Declarations# ⟫, #ModuleName]
→
%HxDeclarations⟪
  module #ModuleName2# { %Declarations« PG-ResolveImports[#Declarations2#, #ModuleName2#] » } ;
  %Declarations« PG-ResolveImports[#Declarations#, #ModuleName] »
⟫
;

Resolve-Space:
PG-ResolveImports[%HxDeclarations⟪ space #RegExp# ; #Declarations# ⟫, #ModuleName]
→
%HxDeclarations⟪ space #RegExp# ; %Declarations« PG-ResolveImports[#Declarations#, #ModuleName] » ⟫
;

Resolve-Token:
PG-ResolveImports[%HxDeclarations⟪ token #SortName# | #RegExp# ; #Declarations# ⟫, #ModuleName]
→
%HxDeclarations⟪ token #SortName# | #RegExp# ; %Declarations« PG-ResolveImports[#Declarations#, #ModuleName] » ⟫
;

Resolve-Fragment:
PG-ResolveImports[%HxDeclarations⟪ fragment #FragmentName# | #RegExp# ; #Declarations# ⟫, #ModuleName]
→
%HxDeclarations⟪ fragment #FragmentName# | #RegExp# ; %Declarations« PG-ResolveImports[#Declarations#, #ModuleName] » ⟫
;

Resolve-Attribute:
PG-ResolveImports[%HxDeclarations⟪ attribute #AttributeKind# #AttributeName# #AttributeForm# #AttributeOptions# ; #Declarations# ⟫, #ModuleName]
→
%HxDeclarations⟪ attribute #AttributeKind# #AttributeName# #AttributeForm# #AttributeOptions# ; %Declarations« PG-ResolveImports[#Declarations#, #ModuleName] » ⟫
;

Resolve-Sort:
PG-ResolveImports[%HxDeclarations⟪ sort #SortName# #Repeat# #SortAbstraction# ; #Declarations# ⟫, #ModuleName]
→
%HxDeclarations⟪ sort #SortName# #Repeat# #SortAbstraction# ; %Declarations« PG-ResolveImports[#Declarations#, #ModuleName] » ⟫
;

Resolve-Main-Sort:
PG-ResolveImports[%HxDeclarations⟪ main sort #SortName# #Repeat# #SortAbstraction# ; #Declarations# ⟫, #ModuleName]
→
%HxDeclarations⟪ main sort #SortName# #Repeat# #SortAbstraction# ; %Declarations« PG-ResolveImports[#Declarations#, #ModuleName] » ⟫
;

Resolve-NakedAlternative:
PG-ResolveImports[%HxDeclarations⟪ #SortAlternatives# ; #Declarations# ⟫, #ModuleName]
→
%HxDeclarations⟪ #SortAlternatives# ; %Declarations« PG-ResolveImports[#Declarations#, #ModuleName] » ⟫
;

ResolveRule:
PG-ResolveImports[%HxDeclarations⟪ rule #Rule# ; #Declarations# ⟫, #ModuleName]
→
%HxDeclarations⟪ rule #Rule# ; %Declarations« PG-ResolveImports[#Declarations#, #ModuleName] » ⟫
;

ResolveNesting:
PG-ResolveImports[%HxDeclarations⟪ { #Declarations1# } #Declarations2# ⟫, #ModuleName]
→
%HxDeclarations⟪ { %Declarations« PG-ResolveImports[#Declarations1#, #ModuleName] » } %Declarations« PG-ResolveImports[#Declarations2#, #ModuleName] » ⟫
;

ResolveDone:
PG-ResolveImports[%HxDeclarations⟪ ⟫, #ModuleName]
→
%HxDeclarations⟪ ⟫
;


/////////////////////////////////////////////////////////////////////
// 3. DECLARATION MAPS (PG-MapDeclarations)
//
// Contains all declarations of tokens, attributes, sorts, and some extras,
// needed for grammar generation.

// Data sort for completed map.

{$String<!--Name--> : DeclarationMapEntry}
DeclarationMap ::=( DM; );

DeclarationMapEntry ::=(
 DME_TOKEN[$String<!--SortName-->];
 DME_ATTRIBUTE[HxAttributeKind, $String<!--AttributeName-->, HxAttributeForm, $List[HxAttributeOption]];
 DME_SORT[$List[Define], $String<!--FullSortName-->, NameSet<!--precs-->, Wrapper, Boolean<!--IsMainSort-->];
 DME_NONE;
 DME_ALIAS[HxSort];
 DME_STRING[$String];
 DME_NAMES[NameSet];
);

Wrapper ::=( NO_WRAPPER; WRAPPER[HxParsedForm]; );

{$String : $StringEntrySort}
Define ::=(
 D_ABSTRACTION[a::HxSortParam . Define];
 D_FORM[HxForm, FormKind];
 D_SYNTHESIZES[$String<!--AttributeName-->];
 D_RULE[HxRule, $String<!--sort-->, Boolean<!--IsDataEquivalence?-->];
 D_NONE;
);

FormKind ::=( FK_DATA[$List[$String]<!--Tags-->]; FK_SCHEME[NameSet<!--inherits-->]; FK_SYMBOL[$Boolean<!--IsStatic-->, $tring<!--token-->]; FK_SUGAR[HxTerm]; FK_ALIAS; );

// Extract all names.

{$String<!--SortName--> : DeclarationMapEntry} PG-AllSortNames :: NameSet;
{#DM; "$AllSortNames" : DME_NAMES[#Names]} PG-AllSortNames → #Names ;

// Extract main sort name.

{$String<!--SortName--> : DeclarationMapEntry} PG-MainSymbol :: $String ;
{#DM}PG-MainSymbol → {#DM}PG-MainSymbol1[NameSetList[{#DM}PG-AllSortNames], ""] ;

{$String<!--SortName--> : DeclarationMapEntry} PG-MainSymbol1[$List[$String], $String] :: $String ;
{#DM}PG-MainSymbol1[(), #main] → #main ;
-[Data[#n]]: {#DM}PG-MainSymbol1[(#n; #ns), #main] → {#DM}PG-MainSymbol2[$[{#DM}Get, #n, DME_NONE], #ns, #main] ;

{$String<!--SortName--> : DeclarationMapEntry} PG-MainSymbol2[DeclarationMapEntry, $List[$String]] :: $String ;
{#DM}PG-MainSymbol2[DME_SORT[#Defines, #Name, #Precs, #Wrapper, B_TRUE], #ns, #main] → #Name ;
-[Fallback]: {#DM}PG-MainSymbol2[#entry, #ns, #main] → {#DM}PG-MainSymbol1[#ns, #main] ;

// Extract all non-main symbols.

{$String<!--SortName--> : DeclarationMapEntry} PG-NonMainSymbols :: $List[$String] ;
{#DM}PG-NonMainSymbols → {#DM}PG-NonMainSymbols1[NameSetList[{#DM}PG-AllSortNames], {#DM}PG-MainSymbol, ()] ;

{$String<!--SortName--> : DeclarationMapEntry} PG-NonMainSymbols1[$List[$String], $String<!--main-->, NameSet] :: $List[$String] ;
{#DM}PG-NonMainSymbols1[(), #main, #accumulated] → #accumulated ;
-[Data[#n]]: {#DM}PG-NonMainSymbols1[(#n; #ns), #main, #accumulated] → {#DM}PG-NonMainSymbols2[$[{#DM}Get, #n, DME_NONE], #ns, #main, #accumulated] ;

{$String<!--SortName--> : DeclarationMapEntry} PG-NonMainSymbols2[DeclarationMapEntry, $List[$String], $String, NameSet] :: $List[$String] ;
{#DM}PG-NonMainSymbols2[DME_SORT[#Defines, #Name, #Precs, #Wrapper, #IsMain], #ns, #main, #accumulated]
→
If[SameString[#main, #Name],
  {#DM}PG-NonMainSymbols1[#ns, #main, #accumulated],
  (#Name; {#DM}PG-NonMainSymbols1[#ns, #main, #accumulated])
]
;
{#DM}PG-NonMainSymbols2[DME_TOKEN[#Name], #ns, #main, #accumulated]
→
(#Name; {#DM}PG-NonMainSymbols1[#ns, #main, #accumulated])
;
-[Fallback]:
{#DM}PG-NonMainSymbols2[#entry, #ns, #main, #accumulated]
→
{#DM}PG-NonMainSymbols1[#ns, #main, #accumulated]
;

// Extract token for symbol sorts...TODO: add sorts and complete patterns.

PG-ExtractSymbolFormToken[Hx_M_FormParsedSorted[#SortName, #ParsedForm, #prec, #InhRefs]] → PG-ExtractSymbolParsedFormToken[#ParsedForm];
PG-ExtractSymbolFormToken[Hx_M_FormParsed[#ParsedForm, #prec, #InhRefs]] → PG-ExtractSymbolParsedFormToken[#ParsedForm];

PG-ExtractSymbolParsedFormToken[Hx_M_ParsedFormSpace[#sp, #ParsedForm]] → PG-ExtractSymbolParsedFormToken[#ParsedForm];
PG-ExtractSymbolParsedFormToken[Hx_M_ParsedFormTerm[%HxScopeSortPrecRepeat⟪ #SortName# #FormPrec# #Repeat# ⟫, #ParsedForm]] → #SortName# ;

-[Data[#SortName]]:
{#DM}PG-SymbolSortTokenName[#SortName]
→
PG-SymbolSortTokenName2[$[{#DM}Get,#SortName,DME_NONE]]
;

PG-SymbolSortTokenName2[DME_SORT[(D_FORM[#Form, FK_SYMBOL[#static, #TokenName]];), #Name, #Precs, #Wrapper, #IsMain]] → #TokenName ;
PG-SymbolSortTokenName2[$[NotMatch,DME_SORT[(D_FORM[#Form, FK_SYMBOL[#static, #TokenName]];), #Name, #Precs, #Wrapper, #IsMain], #_]] → "" ;

// Start mapping...

PG-MapDeclarations[$List[HxDeclaration], $String<!--ModuleName-->] :: DeclarationMap ;
PG-MapDeclarations[#Declarations, #ModuleName]
→
{}
PG-MapDeclarations1[#Declarations, #ModuleName, "", NoNames, ok¹ s ss.PG-Finish[ss]] // data without required environment!
;

// Process declarations.

{$String<!--SortName--> : DeclarationMapEntry}
PG-MapDeclarations1[$List[HxDeclaration], $String<!--ModuleName-->, $String<!--LastSortName-->, NameSet<!--Names-->,
                    ok¹::Ok s::$String<!--SortName--> ss::NameSet<!--SortNames--> . DeclarationMap] :: DeclarationMap ;

{#DM}
PG-MapDeclarations1[%HxDeclarations⟪ module #ModuleName2# { #Declarations2# } ; #Declarations# ⟫, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
→
{#DM}
PG-MapDeclarations1[#Declarations2# , #ModuleName2#, "", #Names, ok¹ s ss.PG-then-Declarations1[ok¹, #Declarations#, #ModuleName, #LastSortName, ss, ok2¹ s2 ss2.#[ok2¹,s2,ss2]]]
;

Declarations-space:
{#DM}
PG-MapDeclarations1[%HxDeclarations⟪ space #RegExp# ; #Declarations# ⟫, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
→
{#DM}
PG-MapDeclarations1[#Declarations#, #ModuleName, "", #Names, ok¹ s ss.#[ok¹,s,ss]]
;

Declarations-token[Data[#SortName]]:
{#DM}
PG-MapDeclarations1[%HxDeclarations⟪ token #SortName# | #RegExp# ; #Declarations# ⟫, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
→
{#DM; #SortName# : DME_TOKEN[#SortName#]}
PG-MapDeclarations1[#Declarations#, #ModuleName, "", AddName[#Names, #SortName#], ok¹ s ss.#[ok¹,s,ss]]
;
/// {#DM}
/// PG-MapDeclarationsInsertToken[PG-QN[#ModuleName, "NodeSort", #SortName#], #Declarations#, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
/// ;
///     // Local helper to compute qualified token name and insert declaration.
///     -[Data[#QualifiedName]]:
///     {#DM}PG-MapDeclarationsInsertToken[#QualifiedName, #Declarations, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
///     →
///     {#DM; #QualifiedName : DME_TOKEN[#QualifiedName]}
///     PG-MapDeclarations1[#Declarations, #ModuleName, "", AddName[#Names, #QualifiedName], ok¹ s ss.#[ok¹,s,ss]]
///     ;

Declarations-fragment:
{#DM}
PG-MapDeclarations1[%HxDeclarations⟪ fragment #FragmentName# | #RegExp# ; #Declarations# ⟫, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
→
{#DM}
PG-MapDeclarations1[#Declarations#, #ModuleName, "", #Names, ok¹ s ss.#[ok¹,s,ss]]
;

Declarations-attribute[Data[#AttributeName#,#AttributeForm#]]:
{#DM}
PG-MapDeclarations1[%HxDeclarations⟪ attribute #AttributeKind# #AttributeName# #AttributeForm# #AttributeOptions# ; #Declarations# ⟫, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
→
{#DM; #AttributeName# : DME_ATTRIBUTE[#AttributeKind#, #AttributeName#, #AttributeForm#, #AttributeOptions#]}
PG-MapDeclarations1[#Declarations#, #ModuleName, "", AddName[#Names, #AttributeName#], ok¹ s ss.#[ok¹,s,ss]]
;
/// {#DM}
/// PG-MapDeclarationsInsertAttribute[PG-QN[#ModuleName, "Attribute" #AttributeName#], #AttributeKind#, #AttributeForm#, #AttributeOptions#, #Declarations#, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
/// ;
///     // Local helper to compute qualified attribute name and insert declaration.
///     -[Data[#QualifiedName]]:
///     {#DM}PG-MapDeclarationsInsertAttribute[#QualifiedName, #AttributeKind, #AttributeForm, #AttributeOptions, #Declarations, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
///     →
///     {#DM; #QualifiedName : DME_ATTRIBUTE[#AttributeKind, #QualifiedName, #AttributeForm, #AttributeOptions]}
///     PG-MapDeclarations1[#Declarations, #ModuleName, "", AddName[#Names, #QualifiedName], ok¹ s ss.#[ok¹,s,ss]]
///     ;

Declarations-sort:
{#DM}
PG-MapDeclarations1[%HxDeclarations⟪ sort #SortName# #Repeat# #SortAbstraction# ; #Declarations# ⟫, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
→
{#DM}
PG-SortAbstraction[#SortAbstraction#, B_FALSE, #ModuleName, PG-SortNameWithRepeat1[#SortName#, #Repeat#], #Names, ok¹ s ss.PG-then-Declarations1[ok¹, #Declarations#, #ModuleName, s, ss, ok2¹ s2 ss2.#[ok2¹,s2,ss2]]]
;
/// {#DM}
/// PG-MapDeclarationsInsertSort[PG-QN[#ModuleName, "NodeSort", #SortName#], #Repeat#, #SortAbstraction#, #Declarations#, B_TRUE, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
/// ;
///     // Local helper to compute qualified sort name and insert declaration.
///     -[Data[#QualifiedName]]:
///     {#DM}PG-MapDeclarationsInsertSort[#QualifiedName, #Repeat, #SortAbstraction, #Declarations, #IsMain, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
///     →
///     {#DM}
///     PG-SortAbstraction[#SortAbstraction, #IsMain, #ModuleName, PG-SortNameWithRepeat1[#QualifiedName, #Repeat], #Names, ok¹ s ss.PG-then-Declarations1[ok¹, #Declarations, #ModuleName, s, ss, ok2¹ s2 ss2.#[ok2¹,s2,ss2]]]
///     ;

Declarations-main-sort:
{#DM}
PG-MapDeclarations1[%HxDeclarations⟪ main sort #SortName# #Repeat# #SortAbstraction# ; #Declarations# ⟫, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
→
{#DM}
PG-SortAbstraction[#SortAbstraction#, B_TRUE, #ModuleName, PG-SortNameWithRepeat1[#SortName#, #Repeat#], #Names, ok¹ s ss.PG-then-Declarations1[ok¹, #Declarations#, #ModuleName, s, ss, ok2¹ s2 ss2.#[ok2¹,s2,ss2]]]
;
/// {#DM}
/// PG-MapDeclarationsInsertSort[PG-QN[#ModuleName, "NodeSort", #SortName#], #Repeat#, #SortAbstraction#, #Declarations#, B_FALSE, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
/// ;

Declarations-alternatives:
{#DM}
PG-MapDeclarations1[%HxDeclarations⟪ #SortAlternatives# ; #Declarations# ⟫, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
→
{#DM}
PG-SortAlternatives[#SortAlternatives#, #ModuleName, #LastSortName, #Names, ok¹ s ss.PG-then-Declarations1[ok¹, #Declarations#, #ModuleName, s, ss, ok2¹ s2 ss2.#[ok2¹,s2,ss2]]]
;

Declarations-rule:
{#DM}
PG-MapDeclarations1[%HxDeclarations⟪ rule #Rule# ; #Declarations# ⟫, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
→
{#DM}
PG-InsertDefine[D_RULE[#Rule#, PG-RuleTopSort[#Rule#, #LastSortName], B_FALSE], B_BALSE<!--NotMain-->, #ModuleName, PG-RuleTopSort[#Rule#, #LastSortName], #Names, ok¹ s ss.PG-then-Declarations1[ok¹, #Declarations#, #ModuleName, s, ss, ok2¹ s2 ss2.#[ok2¹,s2,ss2]]]
;

    // Local helper to extract sort of rule.
    //
    PG-RuleTopSort[HxRule, $String<!--FallBackName-->] :: $String;
    PG-RuleTopSort[%HxRule⟪ #Priority# [ #Options# ] #NotVariableTerm# → #Term# ⟫, #FallBack]
    →
    PG-TermTopSort[#NotVariableTerm#, #FallBack]
    ;
    //
    PG-TermTopSort[HxTerm, $String<!--FallBackName-->] :: $String;
    -[Free[v::Text]]:
    PG-TermTopSort[%HxTerm⟪ v #Attributes# ⟫, #FallbackSortName] → PG-CheckString[#FallbackSortName] ;
    -[Free[v::Text]]:
    PG-TermTopSort[%HxTerm⟪ #Constructor1# #Repeat1# v #Attributes# ⟫, #FallbackSortName] → PG-SortRepeatString[#Constructor1#, #Repeat1#] ;
    PG-TermTopSort[Hx_M_Unparsed[#Unparsed, #Attributes], #FallbackSortName] → PG-CheckString[#FallbackSortName] ;
    PG-TermTopSort[Hx_M_UnparsedSorted[#SortName, #Repeat, #Unparsed, #Attributes#], #FallbackSortName] → #SortName ;
    PG-TermTopSort[%HxTerm⟪ #Constructor# ( #Scopes# ) #Attributes# ⟫, #FallbackSortName] → PG-CheckString[#FallbackSortName] ;
    PG-TermTopSort[%HxTerm⟪ #Constructor1# #Repeat1# #Constructor2# ( #Scopes# ) #Attributes# ⟫, #FallbackSortName] → PG-SortRepeatString[#Constructor1#, #Repeat1#] ;
    PG-TermTopSort[%HxTerm⟪ #MetaVariable# [ #Terms# ] #Attributes# ⟫, #FallbackSortName] → PG-CheckString[#FallbackSortName] ;
    PG-TermTopSort[%HxTerm⟪ #Constructor1# #Repeat1# #MetaVariable# [ #Terms# ] #Attributes# ⟫, #FallbackSortName] → PG-SortRepeatString[#Constructor1#, #Repeat1#] ;
    PG-TermTopSort[%HxTerm⟪ #Literal# #Attributes# ⟫, #FallbackSortName] → PG-CheckString[#FallbackSortName] ;
    PG-TermTopSort[Hx_M_Special[#v, #Concrete], #FallbackSortName] → PG-CheckString[#FallbackSortName] ;
    //
    PG-CheckString[$String] :: $String;
    PG-CheckString[#String] → #String ; //$[IfEmpty, #String, CookError[$[:,"Impossible HACS component ",#String]], #String] ;
    //
    PG-SortRepeatString[$String, HxRepeat] :: $String;
    -[Data[#SortName]]: PG-SortRepeatString[#SortName, #Repeat] → $[IfEmpty, #SortName, "", PG-SortRepeatString2[#SortName, #Repeat]] ;
    PG-SortRepeatString2[$String, HxRepeat] :: $String;
    PG-SortRepeatString2[#SortName, %HxRepeat⟪ ⟫] → #SortName ;
    PG-SortRepeatString2[#SortName, %HxRepeat⟪ ? ⟫] → $[:,#SortName,"?"] ;
    PG-SortRepeatString2[#SortName, %HxRepeat⟪ * ⟫] → $[:,#SortName,"*"] ;
    PG-SortRepeatString2[#SortName, %HxRepeat⟪ + ⟫] → $[:,#SortName,"+"] ;
    PG-SortRepeatString2[#SortName, %HxRepeat⟪ + _ #RegExpLeaf# ⟫] → PG-RegExpLeafSuffix[#RegExpLeaf#, $[:,#SortName,"+_"]] ;
    //    
    PG-RegExpLeafSuffix[HxRegExpSimple, $String] :: $String;
    -[Data[#String#]]: PG-RegExpLeafSuffix[%HxRegExpLeaf⟪ #String# ⟫, #prefix] → $[:,#prefix,#String#] ;
    -[Data[#Word#]]:   PG-RegExpLeafSuffix[%HxRegExpLeaf⟪ #Word# ⟫,   #prefix] → $[:,#prefix,#Word#] ;
    //
    PG-RegExpLeafWord[HxRegExpSimple] :: $String;
    -[Data[#String#]]: PG-RegExpLeafWord[%HxRegExpLeaf⟪ #String# ⟫] → $[Rescape, #String#] ;
    -[Data[#Word#]]:   PG-RegExpLeafWord[%HxRegExpLeaf⟪ #Word# ⟫] → #Word# ;

Declarations-local:
{#DM}
PG-MapDeclarations1[%HxDeclarations⟪ { #Declarations2# } #Declarations# ⟫, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
→
{#DM}
PG-MapDeclarations1[#Declarations2# , #ModuleName, #LastSortName, #Names, ok¹ s ss.PG-then-Declarations1[ok¹, #Declarations#, #ModuleName, #LastSortName, ss, ok2¹ s2 ss2.#[ok2¹,s2,ss2]]]
;

Declarations-none:
{#DM}
PG-MapDeclarations1[%HxDeclarations⟪ ⟫, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
→
{#DM}
#[OK, #LastSortName, #Names]
;

// Delayed variant.
{$String<!--SortName--> : DeclarationMapEntry}
PG-then-Declarations1[Ok, $List[HxDeclaration], $String<!--ModuleName-->, $String<!--LastSortName-->, NameSet<!--SortNames-->,
                      ok¹::Ok s::$String<!--SortName--> ss::NameSet<!--SortNames--> . DeclarationMap] :: DeclarationMap ;
//
{#DM}
PG-then-Declarations1[OK, #Declaration*, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
→
{#DM}
PG-MapDeclarations1[#Declaration*, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
;

// Sort declarations factor any leading parameters over all declarations.

{$String<!--SortName--> : DeclarationMapEntry}
PG-SortAbstraction[HxSortAbstraction, Boolean<!--IsMain-->, $String<!--ModuleName-->, $String<!--SortName-->, NameSet<!--SortNames-->,
                   ok¹::Ok s::$String<!--SortName--> ss::NameSet<!--SortNames--> . DeclarationMap] :: DeclarationMap ;

{#DM}
PG-SortAbstraction[#SortAbstraction, #IsMain, #ModuleName, #Name, #Names, ok¹ s ss.#[ok¹, s, ss]]
→
{#DM}
PG-InsertDefines[PG-SortAbstractionDefines[#SortAbstraction], #IsMain, #ModuleName, #Name, #Names, ok¹ s ss.#[ok¹, s, ss]]
;
{$String<!--SortName--> : DeclarationMapEntry}
PG-SortAlternatives[$List[HxSortAlternative], $String<!--ModuleName-->, $String<!--SortName-->, NameSet<!--SortNames-->,
                   ok¹::Ok s::$String<!--SortName--> ss::NameSet<!--SortNames--> . DeclarationMap] :: DeclarationMap ;

{#DM}
PG-SortAlternatives[(), #ModuleName, #Name, #Names, ok¹ s ss.#[ok¹, s, ss]]
→
{#DM}
#[OK, #Name, #Names]
;

-[Data[#Name]]:
{#DM}
PG-SortAlternatives[(#sa;#sas), #ModuleName, #Name, #Names, ok¹ s ss.#[ok¹, s, ss]]
→
$[IfEmpty, #Name, PG-SortAlternatives-Error,
  {#DM}PG-InsertDefines[PG-SortAlternativesDefines[(#sa;#sas)], B_FALSE, #ModuleName, #Name, #Names, ok¹ s ss.#[ok¹, s, ss]]]
;
PG-SortAlternatives-Error :: DeclarationMap;
PG-SortAlternatives-Error → $[Error,"Error: cannot process stand-alone SortAlternatives with no current sort."];

PG-SortAbstractionDefines[HxSortAbstraction] :: $List[Define] ;
PG-SortAbstractionDefines[%HxSortAbstraction⟪ #SortAlternatives# ⟫] → PG-SortAlternativesDefines[#SortAlternatives#] ;
PG-SortAbstractionDefines[%HxSortAbstraction⟪ a #SortAbstraction#⦃a⦄  ⟫] → PG-SortAbstractionDefines2[a.PG-SortAbstractionDefines[#SortAbstraction#[a]]] ;

PG-SortAbstractionDefines2[a::HxSortParam.$List[Define]] :: $List[Define] ;
PG-SortAbstractionDefines2[a.$Nil] → () ;
PG-SortAbstractionDefines2[a.$Cons[#Define[a], #Defines[a]]] → ( D_ABSTRACTION[a.#Define[a]] ; PG-SortAbstractionDefines2[a.#Defines[a]] ) ;

PG-SortAlternativesDefines[$List[HxSortAlternative]] :: $List[Define] ;
PG-SortAlternativesDefines[%HxSortAlternatives⟪ ⟫] → () ;
PG-SortAlternativesDefines[%HxSortAlternatives⟪ #SortAlternative# #SortAlternatives# ⟫]
→
( PG-SortAlternativeDefine[#SortAlternative#] ; PG-SortAlternativesDefines[#SortAlternatives#] )
; 

PG-SortAlternativeDefine[HxSortAlternative] :: Define ;

PG-SortAlternativeDefine[{#LOC} %HxSortAlternative⟪ | scheme #Form#         ⟫] → {#LOC} D_FORM[#Form#, FK_SCHEME[PG-FormInheritedAttributes[#Form#]]] ;
PG-SortAlternativeDefine[{#LOC} %HxSortAlternative⟪ | data #Form# #Tagging# ⟫] → {#LOC} D_FORM[#Form#, FK_DATA[#Tagging#]];
PG-SortAlternativeDefine[{#LOC} %HxSortAlternative⟪ | symbol #Form#         ⟫] → {#LOC} D_FORM[#Form#, FK_SYMBOL[$False, PG-ExtractSymbolFormToken[#Form#]]];
PG-SortAlternativeDefine[{#LOC} %HxSortAlternative⟪ | static symbol #Form#  ⟫] → {#LOC} D_FORM[#Form#, FK_SYMBOL[$True, PG-ExtractSymbolFormToken[#Form#]]];
PG-SortAlternativeDefine[{#LOC} %HxSortAlternative⟪ | sugar #Form# → #Term# ⟫] → {#LOC} D_FORM[#Form#, FK_SUGAR[#Term#]] ;

PG-SortAlternativeDefine[{#LOC} %HxSortAlternative⟪ | ↑ #AttributeName# ⟫] → {#LOC} D_SYNTHESIZES[#AttributeName#] ;

    // Local helper to extract list of attributes from Form.
    //
    PG-FormInheritedAttributes[HxForm] :: NameSet;
    PG-FormInheritedAttributes[Hx_M_FormParsedSorted[#Name, #ParsedForm, #Prec, #InheritedRefs]] → PG-InheritedRefsList[#InheritedRefs] ;
    PG-FormInheritedAttributes[Hx_M_FormParsed[#ParsedForm, #Prec, #InheritedRefs]] → PG-InheritedRefsList[#InheritedRefs] ;
    PG-FormInheritedAttributes[Hx_M_FormConstruction[#Constructor, #ScopeSorts, #InheritedRefs]] → PG-InheritedRefsList[#InheritedRefs] ;
    //
    PG-InheritedRefsList[$List[HxInheritedRef]] :: NameSet;
    PG-InheritedRefsList[()] → NoNames ;
    PG-InheritedRefsList[(%HxInheritedRef⟪ ↓ #AttributeName1# ⟫; #refs)]
    →
    AddName[PG-InheritedRefsList[#refs], #AttributeName1#]
    ;

// Finish by inserting all precedence links. 

{$String<!--SortName--> : DeclarationMapEntry} PG-Finish[NameSet] :: DeclarationMap;
{#DM} PG-Finish[#Names] → {#DM} PG-Finish0[#Names, #Names] ;

// Process all sort names.

{$String<!--SortName--> : DeclarationMapEntry} PG-Finish0[NameSet, NameSet] :: DeclarationMap;
{#DM} PG-Finish0[#RestNames, #Names] → {#DM} PG-Finish1[HasNames[#RestNames], #RestNames, #Names] ;

{$String<!--SortName--> : DeclarationMapEntry} PG-Finish1[Boolean, NameSet, NameSet] :: DeclarationMap;
{#DM} PG-Finish1[B_FALSE, #RestNames, #Names] → {#DM} PG-Finish9[#Names, {#DM} InheritedNames, {#DM} InheritedMapNames, {#DM} SynthesizedNames, {#DM} SynthesizedMapNames] ;
{#DM} PG-Finish1[B_TRUE, #RestNames, #Names] → {#DM} PG-Finish2[FirstName[#RestNames], RemoveFirstName[#RestNames], #Names] ;

{$String<!--SortName--> : DeclarationMapEntry} PG-Finish2[$String, NameSet, NameSet] :: DeclarationMap;
-[Data[#Name]]: {#DM} PG-Finish2[#Name, #RestNames, #Names] → {#DM} PG-Finish3[$[{#DM}Get[DeclarationMapEntry], #Name, DME_NONE], #RestNames, #Names] ;

{$String<!--SortName--> : DeclarationMapEntry} PG-Finish3[DeclarationMapEntry, NameSet, NameSet] :: DeclarationMap;

{#DM} PG-Finish3[DME_NONE, #RestNames, #Names]
→
{#DM} PG-Finish0[#RestNames, #Names]
;

{#DM} PG-Finish3[DME_TOKEN[#Name], #RestNames, #Names]
→
{#DM} PG-Finish0[#RestNames, #Names]
;

{#DM} PG-Finish3[DME_ATTRIBUTE[#AttributeKind1, #AttributeName1, #AttributeForm1, #AttributeOptions1], #RestNames, #Names]
→
{#DM} PG-Finish0[#RestNames, #Names]
;

{#DM} PG-Finish3[DME_SORT[#Defines1, #Name1, #Precs1, #Wrapper1, #IsMain], #RestNames, #Names]
→
{#DM} PG-Finish4[#Precs1, 0, #Name1, #RestNames, #Names]
;

// Find largest precedences.

{$String<!--SortName--> : DeclarationMapEntry} PG-Finish4[NameSet, $Numeric, $String, NameSet, NameSet] :: DeclarationMap;
-[Data[#Precs]]:
{#DM} PG-Finish4[#Precs, #MaxPrec, #Name, #RestNames, #Names]
→
{#DM} PG-Finish5[HasNames[#Precs], #Precs, #MaxPrec, #Name, #RestNames, #Names]
;

{$String<!--SortName--> : DeclarationMapEntry} PG-Finish5[Boolean, NameSet, $Numeric, $String, NameSet, NameSet] :: DeclarationMap;

{#DM} PG-Finish5[B_FALSE, #Precs, #MaxPrec, #Name, #RestNames, #Names]
→
// Got the highest used precedence!
{#DM} PG-Finish7[#MaxPrec, #Name, #RestNames, #Names]
;

{#DM} PG-Finish5[B_TRUE, #Precs, #MaxPrec, #Name, #RestNames, #Names]
→
{#DM} PG-Finish6[FirstName[#Precs], RemoveFirstName[#Precs], #MaxPrec, #Name, #RestNames, #Names]
;

{$String<!--SortName--> : DeclarationMapEntry} PG-Finish6[$String, NameSet, $Numeric, $String, NameSet, NameSet] :: DeclarationMap;
-[Data[#Prec,#Precs,#MaxPrec]]:
{#DM} PG-Finish6[#Prec, #Precs, #MaxPrec, #Name, #RestNames, #Names]
→
{#DM} PG-Finish4[#Precs, $[If, $[GreaterThan, $[Decimal,#Prec], #MaxPrec], $[Decimal,#Prec], #MaxPrec], #Name, #RestNames, #Names]
;

// Add links for all precedences from max down to 0.

{$String<!--SortName--> : DeclarationMapEntry} PG-Finish7[$Numeric, $String, NameSet, NameSet] :: DeclarationMap;

-[Data[#Prec,#Name],Share[#RestNames,#Names]]:
{#DM} PG-Finish7[#Prec, #Name, #RestNames, #Names]
→
$[If, $[GreaterThan,#Prec,0],
  {#DM} PG-InsertDefine[PG-LinkDefine[#Name, #Prec], B_FALSE, "", #Name, #Names,
	ok¹ s ss.PG-then-Finish7[ok¹, $[Minus,#Prec,1], s, #RestNames, ss]],
  {#DM} PG-Finish0[#RestNames, #Names]]
;

{$String<!--SortName--> : DeclarationMapEntry} PG-then-Finish7[Ok, $Numeric, $String, NameSet, NameSet] :: DeclarationMap;
{#DM} PG-then-Finish7[OK, #Prec, #Name, #RestNames, #Names]
→
{#DM} PG-Finish7[#Prec, #Name, #RestNames, #Names]
;

{$String<!--SortName--> : DeclarationMapEntry} PG-Finish9[NameSet, NameSet, NameSet, NameSet, NameSet] :: DeclarationMap;
{#DM} PG-Finish9[#Names, #InheritedNames, #InheritedMapNames, #SynthesizedNames, #SynthesizedMapNames]
→
{#DM; "$AllSortNames" : DME_NAMES[#Names];
      "$AllInheritedNames" : DME_NAMES[#InheritedNames];
      "$AllInheritedMapNames" : DME_NAMES[#InheritedMapNames];
      "$AllSynthesizedNames" : DME_NAMES[#SynthesizedNames];
      "$AllSynthesizedMapNames" : DME_NAMES[#SynthesizedMapNames]}
DM[#Names]
;

PG-LinkDefine[$String, $Numeric] :: Define;
-[Data[#Name,#Prec]]:
PG-LinkDefine[#Name, #Prec]
→
// NOTE: hand-crafted!
{}
D_FORM[
  Hx_M_FormParsedSorted[
    #Name,
    Hx_M_ParsedFormTerm[
      Hx_M_ScopeSortPrecRepeat[  
        Hx_M_ScopeSort[Hx_M_Sort[Hx_M_SortName[#Name, '$Nil'], '$Nil'], Hx_M_RepeatSingle, '$Nil'],
        #Prec,
        Hx_M_RepeatSingle],
      Hx_M_ParsedFormDone],
    $[Minus,#Prec,1],
    ()],
  FK_ALIAS]
;

// Insert single define: get existing list (if any) and insert in proper sorted place.

{$String<!--SortName--> : DeclarationMapEntry}
PG-InsertDefine[Define<!--new-->, Boolean<!--IsMain-->, $String<!--ModuleName-->, $String<!--SortName-->, NameSet<!--SortNames-->,
                ok¹::Ok s::$String<!--SortName--> ss::NameSet<!--SortNames--> . DeclarationMap] :: DeclarationMap ;

-[Data[#Name],Share[#Define,#]]:
{#DM}
PG-InsertDefine[#Define, #IsMain, #ModuleName, #Name, #Names, ok¹ s ss.#[ok¹, s, ss]]
→
{#DM}
PG-InsertDefine1[$[{#DM}Get[DeclarationMapEntry], #Name, DME_NONE], #Define, #IsMain, #ModuleName, #Name, #Names, ok¹ s ss.#[ok¹, s, ss]]
;

{$String<!--SortName--> : DeclarationMapEntry}
PG-InsertDefine1[DeclarationMapEntry<!--existing-->, Define<!--new-->, Boolean<!--IsMain-->, $String<!--ModuleName-->, $String<!--SortName-->, NameSet<!--SortNames-->,
                 ok¹::Ok s::$String<!--SortName--> ss::NameSet<!--SortNames--> . DeclarationMap] :: DeclarationMap ;

{#DM}
PG-InsertDefine1[DME_SORT[#existingDefines1, #Name1, #Precs1, #Wrapper1, #IsMain1], #newDefine, #IsMain, #ModuleName, #Name, #Names, ok¹ s ss.#[ok¹, s, ss]]
→
{#DM}
PG-InsertDefine4[
	PG-InsertDefine2[#existingDefines1, #newDefine],
	AddNameNumber[#Precs1, PG-DefinePrec[#newDefine]],
	#Name1,
	#Names,
	PG-DefineWrapper[#newDefine, #Name, #Wrapper1],
	Or[#IsMain1, #IsMain],
	ok¹ s ss.#[ok¹, s, ss]]
;
//
{#DM}
PG-InsertDefine1[DME_NONE<!--not found-->, #newDefine, #IsMain, #ModuleName, #Name, #Names, ok¹ s ss.#[ok¹, s, ss]]
→
{#DM}
PG-InsertDefine1b[#Name, #Names, #newDefine, AddNameNumber[NoNames, PG-DefinePrec[#newDefine]], PG-DefineWrapper[#newDefine, #Name, NO_WRAPPER], #IsMain, ok¹ s ss.#[ok¹, s, ss]]
;

{$String<!--SortName--> : DeclarationMapEntry}
PG-InsertDefine1b[$String<!--SortName-->, NameSet<!--SortNames-->, Define, NameSet<!--Precs-->, Wrapper, Boolean<!--IsMain-->,
                ok¹::Ok s::$String<!--SortName--> ss::NameSet<!--SortNames--> . DeclarationMap] :: DeclarationMap ;
-[Data[#newDefine,#Name,#Precs,#Wrapper]]:
{#DM}
PG-InsertDefine1b[#Name, #Names, #newDefine, #Precs, #Wrapper, #IsMain, ok¹ s ss.#[ok¹, s, ss]]
→
{#DM; #Name : DME_SORT[(#newDefine;), #Name, #Precs, #Wrapper, #IsMain]}
#[OK, #Name, AddName[#Names, #Name]]
;

PG-InsertDefine2[$List[Define]<!--existing-->, Define<!--new-->] :: $List[Define]<!--merged-->;
//
PG-InsertDefine2[(), #newDefine] → (#newDefine;) ;
//
PG-InsertDefine2[(#Define1; #Defines), #newDefine]
→
PG-InsertDefine3[PG-DefineLessEqual[#newDefine, #Define1], #newDefine, #Define1, #Defines]
;

PG-InsertDefine3[Boolean<!--new goes before old-->, Define<!--new-->, Define<!--old-->, $List[Define]<!--old rest-->] :: $List[Define]<!--merged-->;
//,
PG-InsertDefine3[B_TRUE , #newDefine, #Define1, #Defines] → (#newDefine; #Define1; #Defines) ;
PG-InsertDefine3[B_FALSE, #newDefine, #Define1, #Defines] → (#Define1; PG-InsertDefine2[#Defines, #newDefine]) ;

{$String<!--SortName--> : DeclarationMapEntry}
PG-InsertDefine4[$List[Define], NameSet<!--precs-->, $String<!--SortName-->, NameSet<!--SortNames-->, Wrapper, Boolean<!--IsMain-->,
                 ok¹::Ok s::$String<!--SortName--> ss::NameSet<!--SortNames--> . DeclarationMap] :: DeclarationMap ;
//
-[Data[#Defines,#Name,#Precs,#Wrapper]]:
{#DM}
PG-InsertDefine4[#Defines, #Precs, #Name, #Names, #Wrapper, #IsMain, ok¹ s ss.#[ok¹, s, ss]]
→
{#DM; #Name : DME_SORT[#Defines, #Name, #Precs, #Wrapper, #IsMain]}
#[OK, #Name, #Names]
;

// Insert list of defines.

{$String<!--SortName--> : DeclarationMapEntry}
PG-InsertDefines[$List[Define], Boolean<!--IsMain-->, $String<!--ModuleName-->, $String<!--SortName-->, NameSet<!--SortNames-->,
                 ok¹::Ok s::$String<!--SortName--> ss::NameSet<!--SortNames--> . DeclarationMap] :: DeclarationMap ;

{#DM}
PG-InsertDefines[(), #IsMain, #ModuleName, #Name, #Names, ok¹ s ss.#[ok¹,s,ss]]
→
{#DM}
#[OK, #Name, #Names]
;

{#DM}
PG-InsertDefines[(#Define ; #Defines), #IsMain, #ModuleName, #Name, #Names, ok¹ s ss.#[ok¹,s,ss]]
→
{#DM}
PG-InsertDefine[#Define, #IsMain, #ModuleName, #Name, #Names,
	ok1¹ s1 ss1.PG-then-InsertDefines[ok1¹, #Defines, #IsMain, #ModuleName, s1, ss1, ok2¹ s2 ss2.#[ok2¹,s2,ss2]]]
;

{$String<!--SortName--> : DeclarationMapEntry}
PG-then-InsertDefines[Ok, Boolean<!--IsMain-->, $String<!--ModuleName-->, $List[Define], $String<!--SortName-->, NameSet<!--SortNames-->,
                      ok¹::Ok s::$String<!--SortName--> ss::NameSet<!--SortNames--> . DeclarationMap] :: DeclarationMap ;

{#DM}
PG-then-InsertDefines[OK, #Defines, #IsMain, #ModuleName, #Name, #Names, ok¹ s ss.#[ok¹,s,ss]]
→
{#DM}
PG-InsertDefines[#Defines, #IsMain, #ModuleName, #Name, #Names, ok¹ s ss.#[ok¹,s,ss]]
;

// Compare of defines.

PG-DefineLessEqual[Define, Define] :: Boolean ;

//-[Discard[#Define1, #Define2]]: PG-DefineLessEqual[#Define1, #Define2] → B_FALSE ;

// Compare (1) Basic constructs are in order Abstraction/Form-Rule-Attribute.

DLE-Abstraction-Rule     : PG-DefineLessEqual[D_ABSTRACTION[a.#D1[a]], D_RULE[#R2, #S2, #D2]] → B_TRUE ;
DLE-Rule-Abstraction     : PG-DefineLessEqual[D_RULE[#R1, #S1, #D1], D_ABSTRACTION[a.#D2[a]]] → B_FALSE ;
                         
DLE-Synthesizes-Rule: PG-DefineLessEqual[D_SYNTHESIZES[#A1], D_RULE[#R2, #S2, #D2]] → B_TRUE ;
DLE-Rule-Synthesizes: PG-DefineLessEqual[D_RULE[#R1, #S1, #D1], D_SYNTHESIZES[#A2]] → B_FALSE ;
                         
DLE-Form-Rule            : PG-DefineLessEqual[D_FORM[#F1, #K1], D_RULE[#R2, #S2, #D2]] → B_TRUE ;
DLE-Rule-Form            : PG-DefineLessEqual[D_RULE[#R1, #S1, #D1], D_FORM[#F2, #K2]] → B_FALSE ;

DLE-Abstraction-Synthesizes     : PG-DefineLessEqual[D_ABSTRACTION[a.#D1[a]], D_SYNTHESIZES[#A2]] → B_TRUE ;
DLE-Synthesizes-Abstraction     : PG-DefineLessEqual[D_SYNTHESIZES[#A1], D_ABSTRACTION[a.#D2[a]]] → B_FALSE ;

DLE-Abstraction-Form: PG-DefineLessEqual[D_ABSTRACTION[a.#D1[a]], D_FORM[#F2, #K2]] → B_TRUE ;
DLE-Form-Abstraction: PG-DefineLessEqual[D_FORM[#F1, #K1], D_ABSTRACTION[a.#D2[a]]] → B_FALSE ;

DLE-Form-Synthesizes: PG-DefineLessEqual[D_FORM[#F1, #K1], D_SYNTHESIZES[#A2]] → B_TRUE ;
DLE-Synthesizes-Form: PG-DefineLessEqual[D_SYNTHESIZES[#A1], D_FORM[#F2, #K2]] → B_FALSE ;

// Compare (2) Abstractions traversed in parallel.

PG-DefineLessEqual[D_ABSTRACTION[a.#Define1[a]], D_ABSTRACTION[a.#Define2[a]]]
→
PG-DefineLessEqual2[a.PG-DefineLessEqual[#Define1[a], #Define2[a]]]
;
PG-DefineLessEqual2[a::HxSortParam.Boolean] :: Boolean ;
PG-DefineLessEqual2[a.B_TRUE] → B_TRUE ;
PG-DefineLessEqual2[a.B_FALSE] → B_FALSE ;

// Compare (3) Forms sorted by precedence-tokens.

DLE-Form-Form: PG-DefineLessEqual[D_FORM[#F1, #FK1], D_FORM[#F2, #FK2]] → PG-FormLess[#F1, #F2] ;

    // Local helper to compare forms.
    //
    PG-FormLess[HxForm, HxForm] :: Boolean ;
    //    
    -[Data[#Prec1,#Prec2]]:
    PG-FormLess[Hx_M_FormParsedSorted[#Name1, #ParsedForm1, #Prec1, #InheritedRefs1], Hx_M_FormParsedSorted[#Name2, #ParsedForm2, #Prec2, #InheritedRefs2]]
    →
    $[If, $[NumericEqual, #Prec1, #Prec2], PG-ParsedFormLess[#ParsedForm1, #ParsedForm2], $[If, $[LessThan, #Prec1, #Prec2], B_TRUE, B_FALSE]]
    ;
    //
    -[Data[#Prec1,#Prec2]]:
    PG-FormLess[Hx_M_FormParsed[#ParsedForm1, #Prec1, #InheritedRefs1], Hx_M_FormParsedSorted[#Name2, #ParsedForm2, #Prec2, #InheritedRefs2]]
    →
    $[If, $[NumericEqual, #Prec1, #Prec2], PG-ParsedFormLess[#ParsedForm1, #ParsedForm2], $[If, $[LessThan, #Prec1, #Prec2], B_TRUE, B_FALSE]]
    ;
    //
    -[Data[#Prec1,#Prec2]]:
    PG-FormLess[Hx_M_FormParsedSorted[#Name1, #ParsedForm1, #Prec1, #InheritedRefs1], Hx_M_FormParsed[#ParsedForm2, #Prec2, #InheritedRefs2]]
    →
    $[If, $[NumericEqual, #Prec1, #Prec2], PG-ParsedFormLess[#ParsedForm1, #ParsedForm2], $[If, $[LessThan, #Prec1, #Prec2], B_TRUE, B_FALSE]]
    ;
    //
    -[Data[#Prec1,#Prec2]]:
    PG-FormLess[Hx_M_FormParsed[#ParsedForm1, #Prec1, #InheritedRefs1], Hx_M_FormParsed[#ParsedForm2, #Prec2, #InheritedRefs2]]
    →
    $[If, $[NumericEqual, #Prec1, #Prec2], PG-ParsedFormLess[#ParsedForm1, #ParsedForm2], $[If, $[LessThan, #Prec1, #Prec2], B_TRUE, B_FALSE]]
    ;
    //
    PG-FormLess[Hx_M_FormConstruction[#Constructor1, #ScopeSorts1, #InheritedRefs1], #Form2] → B_FALSE ;
    //
    PG-FormLess[Hx_M_FormParsedSorted[#Name1, #ParsedForm1, #Prec1, #InheritedRefs1], Hx_M_FormConstruction[#Constructor2, #ScopeSorts2, #InheritedRefs2]] → B_TRUE;
    PG-FormLess[Hx_M_FormParsed[#ParsedForm1, #Prec1, #InheritedRefs1], Hx_M_FormConstruction[#Constructor2, #ScopeSorts2, #InheritedRefs2]] → B_TRUE ;

    PG-ParsedFormLess[HxParsedForm, HxParsedForm] :: Boolean ;
    //
    PG-ParsedFormLess[Hx_M_ParsedFormDone, #PF2] → B_FALSE ;
    PG-ParsedFormLess[#PF1, Hx_M_ParsedFormDone] → B_TRUE ;
    //
    PG-ParsedFormLess[Hx_M_ParsedFormWord[#W1, #PF1], Hx_M_ParsedFormTerm[#SSPR2, #PF2]] → B_TRUE ;
    PG-ParsedFormLess[Hx_M_ParsedFormTerm[#SSPR1, #PF1], Hx_M_ParsedFormWord[#W2, #PF2]] → B_FALSE ;
    //
    -[Data[#W1,#W2]]:
    PG-ParsedFormLess[Hx_M_ParsedFormWord[#W1, #PF1], Hx_M_ParsedFormWord[#W2, #PF2]]
    →
    $[If, $[Equal, #W1, #W2], PG-ParsedFormLess[#PF1, #PF2], $[If, $[StringLessThan, #W1, #W2], B_TRUE, B_FALSE]]
    ;
    //
    PG-ParsedFormLess[Hx_M_ParsedFormTerm[#SSPR1, #PF1], Hx_M_ParsedFormTerm[#SSPR2, #PF2]]
    → 
    PG-ParsedFormLess[#PF1, #PF2] // to ensure short come last!
    ;
    //
    PG-ParsedFormLess[Hx_M_ParsedFormSpace[#S1, #PF1], #PF2] → PG-ParsedFormLess[#PF1, #PF2] ; 
    -[Data[#PF1]]: PG-ParsedFormLess[$[NotMatch,Hx_M_ParsedFormSpace[#S1, #_], #PF1], Hx_M_ParsedFormSpace[#W2, #PF2]] → PG-ParsedFormLess[#PF1, #PF2] ;
    //
    ///PG-ParsedFormLess[Hx_M_ParsedFormAttribute[#K1, #N1, #PF1], Hx_M_ParsedFormAttribute[#K2, #N2, #PF2]]
    ///→
    ///PG-ParsedFormLess[#PF1, #PF2] // to ensure short come last!
    ///;

// Compare (4) Rules are not sorted.

DLE-Rule-Rule: PG-DefineLessEqual[D_RULE[#R1, #S1, #D1], D_RULE[#R2, #S2, #D2]] → B_FALSE ;
DLE-Syntesizes-Synthesizes: PG-DefineLessEqual[D_SYNTHESIZES[#A1], D_SYNTHESIZES[#A2]] → B_FALSE ;

// Precedence extraction.

PG-DefinePrec[Define] :: $Numeric;
-[Fresh[dummy::HxSortParam]] : PG-DefinePrec[D_ABSTRACTION[a.#Define[a]]] → PG-DefinePrec[#Define[dummy]] ;
PG-DefinePrec[D_FORM[Hx_M_FormParsedSorted[#Name, #ParsedForm, #Precedence, #InheritedRefs], #Kind]] → #Precedence ;
PG-DefinePrec[D_FORM[Hx_M_FormParsed[#ParsedForm, #Precedence, #InheritedRefs], #Kind]] → #Precedence ;
PG-DefinePrec[D_FORM[Hx_M_FormConstruction[#Constructor, #ScopeSorts, #InheritedRefs], #Kind]] → 0 ;
PG-DefinePrec[D_SYNTHESIZES[#AttributeName]] → 0 ;
PG-DefinePrec[D_RULE[#Rule, #SortName, #IsData]] → 0 ;

// Wrapper extraction.

PG-DefineWrapper[Define, $String<!--SortName-->, Wrapper] :: Wrapper ;
-[Fresh[dummy::HxSortParam]] : PG-DefineWrapper[D_ABSTRACTION[a.#Define[a]], #Name, #Wrapper] → PG-DefineWrapper[#Define[dummy], #Name, #Wrapper] ;
PG-DefineWrapper[D_FORM[Hx_M_FormParsedSorted[#Name, #ParsedForm, #Prec, #InheritedRefs], #Kind], #Name, #Wrapper] → PG-DefineWrapperForm[#ParsedForm, #Prec, #Kind, #Name, #Wrapper] ;
PG-DefineWrapper[D_FORM[Hx_M_FormParsed[#ParsedForm, #Prec, #InheritedRefs], #Kind], #Name, #Wrapper] → PG-DefineWrapperForm[#ParsedForm, #Prec, #Kind, #Name, #Wrapper] ;

PG-DefineWrapper[D_FORM[Hx_M_FormConstruction[#Constructor, #ScopeSorts, #InheritedRefs], #Kind], #Name, #Wrapper] →  #Wrapper ;
PG-DefineWrapper[D_SYNTHESIZES[#AttributeName], #Name, #Wrapper] → #Wrapper ;
PG-DefineWrapper[D_RULE[#Rule, #SortName, #IsData], #Name, #Wrapper] → #Wrapper ;

PG-DefineWrapperForm[HxParsedForm, $Numeric, FormKind, $String<!--SortName-->, Wrapper] :: Wrapper ;
PG-DefineWrapperForm[#ParsedForm, #Prec, FK_SUGAR[#Term], #Name, #OldWrapper] → PG-DefineWrapperSugar[#ParsedForm, $False<!--NotCandidate-->, #ParsedForm, #Prec, #Term, #Name, #OldWrapper] ;
PG-DefineWrapperForm[#ParsedForm, #Prec, $[NotMatch,FK_SUGAR[#Term],#Kind], #Name, #OldWrapper] → #OldWrapper ;

PG-DefineWrapperSugar[HxParsedForm, $Boolean<!--IsCandidate-->, HxParsedForm, $Numeric<!--Prec-->, HxTerm, $String<!--SortName-->, Wrapper] :: Wrapper ;

-[Data[#Prec1,#Prec]]:
PG-DefineWrapperSugar[Hx_M_ParsedFormTerm[Hx_M_ScopeSortPrecRepeat[#ScopeSort1, #Prec1, #Repeat1], #ParsedForm1], #Candidate, #TopParsedForm, #TopPrec, #TopTerm, #Name, #OldWrapper]
→
$[If, #Candidate,
  #OldWrapper, // not a candidate anyway (has at least two nonterminals)
  $[If, $[LessThan, #TopPrec, #Prec1],
    #OldWrapper, // not a candidate anyway (inner has higher precedence than outer)
    PG-DefineWrapperSugar[#ParsedForm1, $True, #TopParsedForm, #TopPrec, #TopTerm, #Name, #OldWrapper]
]];
// TODO: include #Name in comparison. 

PG-DefineWrapperSugar[Hx_M_ParsedFormWord[#Word, #ParsedForm], #Candidate, #TopParsedForm, #TopPrec, #TopTerm, #Name, #OldWrapper]
→
PG-DefineWrapperSugar[#ParsedForm, #Candidate, #TopParsedForm, #TopPrec, #TopTerm, #Name, #OldWrapper]
;

PG-DefineWrapperSugar[Hx_M_ParsedFormSpace[#Space, #ParsedForm], #Candidate, #TopParsedForm, #TopPrec, #TopTerm, #Name, #OldWrapper]
→
PG-DefineWrapperSugar[#ParsedForm, #Candidate, #TopParsedForm, #TopPrec, #TopTerm, #Name, #OldWrapper]
;

PG-DefineWrapperSugar[Hx_M_ParsedFormDone, $False, #TopParsedForm, #TopPrec, #TopTerm, #Name, #OldWrapper] → #OldWrapper ;
PG-DefineWrapperSugar[Hx_M_ParsedFormDone, $True,  #TopParsedForm, #TopPrec, #TopTerm, #Name, #OldWrapper] → WRAPPER[#TopParsedForm] ;


/////////////////////////////////////////////////////////////////////
// 4. TEXT OF ALL PG NON-TERMINAL PRODUCTIONS.
//
// Productions are extracted by sort and for each sort grouped by precedence,
// each group producing a PG production.

// Iterate through all productions.

{$String<!--SortName--> : DeclarationMapEntry} PG-Productions[$String<!--ModuleName-->] :: Text;
{#DM; "$AllSortNames" : DME_NAMES[#Names]} PG-Productions[#ModuleName] → {#DM} PG-Productions0[#ModuleName, #Names] ;

{$String<!--SortName--> : DeclarationMapEntry} PG-Productions0[$String<!--ModuleName-->, NameSet] :: Text;
{#DM} PG-Productions0[#ModuleName, #Names] → {#DM} PG-Productions1[HasNames[#Names], #ModuleName, #Names] ;

{$String<!--SortName--> : DeclarationMapEntry} PG-Productions1[Boolean, $String<!--ModuleName-->, NameSet] :: Text;
{#DM} PG-Productions1[B_TRUE , #ModuleName, #Names] → %n⟪« {#DM} PG-Production[#ModuleName, FirstName[#Names]] »« {#DM} PG-Productions0[#ModuleName, RemoveFirstName[#Names]] »⟫ ;
{#DM} PG-Productions1[B_FALSE, #ModuleName, #Names] → %n⟪⟫ ;

// Emit text for one production.

{$String<!--Name--> : DeclarationMapEntry} PG-Production[$String<!--ModuleName-->, $String<!--Name-->] :: Text;
-[Data[#Name]]:
{#DM} PG-Production[#ModuleName, #Name] 
→
{#DM} PG-Production1[#ModuleName, $[{#DM}Get, #Name, DME_NONE]]
;

{$String<!--SortName--> : DeclarationMapEntry} PG-Production1[$String<!--ModuleName-->, DeclarationMapEntry] :: Text;

{#DM} PG-Production1[#ModuleName, DME_NONE]
→
%n⟪⟫
;

{#DM}
PG-Production1[#ModuleName, DME_TOKEN[#SortName]]
→
%n⟪

/* Productions for †«#SortName» token. */

«PG-GenerateNonterminalDeclaration[PG-ProductionNameText[#SortName], %n⟨‹ {#DM}PG-MetaHead[B_TRUE, #ModuleName, #SortName, #SortName, B_FALSE, 0]›(‹PG-TokenNameText[#SortName]›$)⟩]»
« {#DM}PG-MetaTail[B_TRUE, #SortName, #SortName] »
/***METAPG: /* Hx terms of †«#SortName» token sort. */ ***/
/***METAPG: <Hx_†«#SortName»> (Hx) ::= (Hx_TOKEN_†«#SortName»)?  <HxPresorted_†«#SortName»> . ***/
/***METAPG: <HxSorted_†«#SortName»> (Hx) ::= Hx_TOKEN_†«#SortName» <HxPresorted_†«#SortName»> . ***/
/***METAPG: <HxPresorted_†«#SortName»> (Hx) ::= ***/
/***METAPG:   {Hx_M_VariableUseSorted} ({†«#SortName»}) ({Hx_M_RepeatSingle}) (Hx_VARIABLE!!!) <HxAttributes> ***/
/***METAPG: | {Hx_M_MetaApplicationSorted} ({†«#SortName»}) ({Hx_M_RepeatSingle}) (Hx_META_VARIABLE$) ( Hx_LBRACKET <HxTerms>  Hx_RBRACKET | {$Nil} ) <HxAttributes> ***/
/***METAPG: | {Hx_M_UnparsedSorted} ({†«#SortName»}) ({Hx_M_RepeatSingle}) (Hx_CONCRETE$:unconcrete) <HxAttributes> ***/
/***METAPG: . ***/
/***METAPG: token Hx_TOKEN_†«#SortName» (Hx) ::= "†«#SortName»" . ***/
⟫
;

PG-GenerateNonterminalDeclaration[Text, Text] → Text;
PG-GenerateNonterminalDeclaration[#Name, #Alternatives] → %n⟪<«#Name»> ::= ⟦«#Alternatives»⟧ .⟫ ;
//TODO: use for all production declarations.

{#DM} PG-Production1[#ModuleName, DME_ATTRIBUTE[#Kind, #Name, #AttributeForm, #AttributeOptions]]
→
PG-Production-Attribute[#ModuleName, #Kind, #Name, #AttributeForm, #AttributeOptions]
;

    // Handle an attribute definition.

    PG-Production-Attribute[$String<!--ModuleName-->, HxAttributeKind, $String, HxAttributeForm, $List[HxAttributeOption]] :: Text;
    PG-Production-Attribute[#ModuleName, #Kind, #Name, #AttributeForm, #AttributeOptions]
    →
    %n⟪
    /***METAPG: <HxAttribute« AttributeKindCategory[#Kind] »_†«#Name»> (Hx) ::= {Hx_M_Attribute} « AttributeKindIndicator[#Kind] » (Hx_TOKEN_†«#Name»$) « AttributeFormSyntax[#ModuleName, #AttributeForm, #AttributeOptions] » . ***/
    /***METAPG: token Hx_TOKEN_†«#Name» (Hx) ::= "†«#Name»" .  ***/
    ⟫
    ;

    AttributeKindCategory[HxAttributeKind] :: Text ;
    AttributeKindCategory[%HxAttributeKind⟪ ↑ ⟫] → %n⟪Synthesized⟫ ;
    AttributeKindCategory[%HxAttributeKind⟪ ↓ ⟫] → %n⟪Inherited⟫ ;

    AttributeKindIndicator[HxAttributeKind] :: Text ;
    AttributeKindIndicator[%HxAttributeKind⟪ ↑ ⟫] → %n⟪({Hx_M_AttributeKindUp})⟫ ;
    AttributeKindIndicator[%HxAttributeKind⟪ ↓ ⟫] → %n⟪({Hx_M_AttributeKindDown})⟫ ;

    AttributeFormSyntax[$String<!--ModuleName-->, HxAttributeForm, $List[HxAttributeOption]] :: Text ;
    AttributeFormSyntax[#ModuleName, %HxAttributeForm⟪ ( #Sort# ) ⟫, #AttributeOptions] → %n⟪Hx_LPAREN {Hx_M_AttributeValue} <Hx_†« PG-SortName[#Sort#] »> Hx_RPAREN⟫ ;
    AttributeFormSyntax[#ModuleName, %HxAttributeForm⟪ { #Sort# } ⟫, #AttributeOptions] → %n⟪Hx_LBRACE {Hx_M_AttributeKey} <Hx_†« PG-SortName[#Sort#] »> Hx_RBRACE⟫ ;
    AttributeFormSyntax[#ModuleName, %HxAttributeForm⟪ { #Sort1# : #Sort2# } ⟫, #AttributeOptions] → %n⟪Hx_LBRACE {Hx_M_AttributeKeyValue} <Hx_†« PG-SortName[#Sort1#] »> Hx_COLON <Hx_†« PG-SortName[#Sort2#] »> Hx_RBRACE⟫ ;

    AttributeKindToken[HxAttributeKind] :: Text ;
    AttributeKindToken[%HxAttributeKind⟪ ↑ ⟫] → %n⟪Hx_UP⟫ ;
    AttributeKindToken[%HxAttributeKind⟪ ↓ ⟫] → %n⟪Hx_DOWN⟫ ;

{#DM} PG-Production1[#ModuleName, DME_SORT[#Defines, #SortName, #Precs, #Wrapper, #IsMain]]
→
%n⟪« {#DM} PG-Production-Defines[#ModuleName, #Defines, #SortName, 0, ()] »« {#DM} PG-Production-HxDefines[#ModuleName, #Defines, #SortName] »⟫
;

// Handle a sort definition.

{$String<!--SortName--> : DeclarationMapEntry} PG-Production-Defines[$List[Define], $String, $Numeric, $List[PFK_SORT]] :: Text;

// Helper for ParsedForm and FK.
PFK_SORT ::=( PFK[HxParsedForm, FormKind]; );

{#DM} PG-Production-Defines[#ModuleName, (), #SortName, #Prec, ()]
→
%n⟪⟫
;

{#DM} PG-Production-Defines[#ModuleName, (), #SortName, #Prec, (#PFK1;#PFKs)]
→
%n⟪

/* Productions for †«#SortName» sort with (highest) precedence †«$[FormatNumber,#Prec]». */
« {#DM} PG-Expand[#ModuleName, (#PFK1;#PFKs), #SortName, #Prec, B_TRUE] »⟫
;

-[Fresh[dummy::HxSortParam]]:
{#DM} PG-Production-Defines[#ModuleName, (D_ABSTRACTION[a.#Define1[a]]; #Defines), #SortName, #Prec, #PrecPFKs]
→
{#DM} PG-Production-Defines[#ModuleName, (#Define1[dummy]; #Defines), #SortName, #Prec, #PrecPFKs]
;

{#DM} PG-Production-Defines[#ModuleName, (D_RULE[#Rule, #RuleSort, #IsData]; #Defines), #SortName, #Prec, #PrecPFKs]
→
{#DM} PG-Production-Defines[#ModuleName, #Defines, #SortName, #Prec, #PrecPFKs]
;

{#DM} PG-Production-Defines[#ModuleName, (D_FORM[#Form1, #Kind1]; #Defines), #SortName, #Prec, #PrecPFKs]
→
{#DM} PG-Production-Defines2[#ModuleName, #Form1, #Kind1, #Defines, #SortName, #Prec, #PrecPFKs]
;

{#DM} PG-Production-Defines[#ModuleName, (D_SYNTHESIZES[#AttributeName1]; #Defines), #SortName, #Prec, #PrecPFKs]
→
{#DM} PG-Production-Defines[#ModuleName, #Defines, #SortName, #Prec, #PrecPFKs]
;

{$String<!--SortName--> : DeclarationMapEntry} PG-Production-Defines2[HxForm, FormKind, $List[Define], $String, $Numeric, $List[PFK_SORT]] :: Text;

{#DM} PG-Production-Defines2[#ModuleName, Hx_M_FormParsedSorted[#Sort1, #ParsedForm1, #Prec1, #InheritedRefs], #Kind1, #Defines, #SortName, #Prec, #PrecPFKs]
→
{#DM} PG-Production-Defines3[#ModuleName, #ParsedForm1, #Prec1, #Kind1, #Defines, #SortName, #Prec, #PrecPFKs]
;

{#DM} PG-Production-Defines2[#ModuleName, Hx_M_FormParsed[#ParsedForm1, #Prec1, #InheritedRefs], #Kind1, #Defines, #SortName, #Prec, #PrecPFKs]
→
{#DM} PG-Production-Defines3[#ModuleName, #ParsedForm1, #Prec1, #Kind1, #Defines, #SortName, #Prec, #PrecPFKs]
;

{#DM} PG-Production-Defines2[#ModuleName, Hx_M_FormConstruction[#Constructor, #ScopeSortList, #InheritedRefs], #Kind1, #Defines, #SortName, #Prec, #PrecPFKs]
→
{#DM} PG-Production-Defines[#ModuleName, #Defines, #SortName, #Prec, #PrecPFKs]
;

{$String<!--SortName--> : DeclarationMapEntry} PG-Production-Defines3[HxParsedForm, $Numeric, FormKind, $List[Define], $String, $Numeric, $List[PFK_SORT]] :: Text;

-[Data[#Prec1,#Prec],Share[#ParsedForm1,#Kind1,#Defines]]:
{#DM} PG-Production-Defines3[#ModuleName, #ParsedForm1, #Prec1, #Kind1, #Defines, #SortName, #Prec, ()]
→
$[If, $[NumericEqual,#Prec1,#Prec],
  {#DM} PG-Production-Defines[#ModuleName, #Defines, #SortName, #Prec, (PFK[#ParsedForm1, #Kind1];)],
  %n⟪
<«PG-ProductionNameWithPrecText[#SortName,#Prec]»> ::= <«PG-ProductionNameWithPrecText[#SortName,#Prec1]»> .
« {#DM} PG-Production-Defines[#ModuleName, #Defines, #SortName, #Prec1, (PFK[#ParsedForm1, #Kind1];)] »⟫]
;

-[Data[#Prec1,#Prec],Share[#ParsedForm1,#Kind1,#Defines,#PFK,#PFKs]]:
{#DM} PG-Production-Defines3[#ModuleName, #ParsedForm1, #Prec1, #Kind1, #Defines, #SortName, #Prec, (#PFK;#PFKs)]
→
$[If, $[NumericEqual,#Prec1,#Prec],
  {#DM} PG-Production-Defines[#ModuleName, #Defines, #SortName, #Prec, Append[(#PFK;#PFKs), (PFK[#ParsedForm1, #Kind1];)]],
  %n⟪/* Productions for †«#SortName» sort with precedence †«$[FormatNumber,#Prec]». */
« {#DM} PG-Expand[#ModuleName, (#PFK;#PFKs), #SortName, #Prec, B_FALSE] »
« {#DM} PG-Production-Defines[#ModuleName, #Defines, #SortName, #Prec1, (PFK[#ParsedForm1, #Kind1];)] »
⟫]
;

{$String<!--SortName--> : DeclarationMapEntry} PG-Production-HxDefines[$String<!--<ModuleName-->, $List[Define], $String] :: Text;

{#DM}
PG-Production-HxDefines[#ModuleName, #Defines, #SortName]
→
%n⟪
/***METAPG: /* Hx terms of †«#SortName» production sort. */ ***/
/***METAPG: <Hx_†«#SortName»> (Hx) ::= (Hx_TOKEN_†«#SortName»)?  <HxPresorted_†«#SortName»> . ***/
/***METAPG: <HxSorted_†«#SortName»> (Hx) ::= Hx_TOKEN_†«#SortName» <HxPresorted_†«#SortName»> . ***/
/***METAPG: <HxPresorted_†«#SortName»> (Hx) ::= ***/
/***METAPG:   {Hx_M_VariableUseSorted} ({†«#SortName»}) ({Hx_M_RepeatSingle}) (Hx_VARIABLE!!!) <HxAttributes> ***/
/***METAPG: | {Hx_M_MetaApplicationSorted} ({†«#SortName»}) ({Hx_M_RepeatSingle}) (Hx_META_VARIABLE$) ( Hx_LBRACKET <HxTerms> Hx_RBRACKET | {$Nil} ) <HxAttributes> ***/
/***METAPG: | {Hx_M_ConstructionSorted} ({†«#SortName»}) ({Hx_M_RepeatSingle}) (Hx_CONSTRUCTOR$) ( Hx_LBRACKET <HxScopes> Hx_RBRACKET | Hx_LPAREN <HxTerms> Hx_RPAREN | {$Nil} ) <HxAttributes> ***/
/***METAPG: | {Hx_M_UnparsedSorted} ({†«#SortName»}) ({Hx_M_RepeatSingle}) (Hx_CONCRETE$:unconcrete) <HxAttributes> ***/
/***METAPG: « {#DM} PG-Production-HxDefines1[#ModuleName, #Defines, #SortName] » ***/
/***METAPG: . ***/
/***METAPG: token Hx_TOKEN_†«#SortName» (Hx) ::= "†«#SortName»" . ***/
/***METAPG: « {#DM} PG-Production-HxDefinesTokens[#ModuleName, #Defines, #SortName] » ***/

⟫;

{$String<!--SortName--> : DeclarationMapEntry} PG-Production-HxDefines1[$String<!--ModuleName-->, $List[Define], $String] :: Text;

-[Fresh[dummy::HxSortParam]]:
{#DM} PG-Production-HxDefines1[#ModuleName, (D_ABSTRACTION[a.#Define1[a]]; #Defines), #SortName]
→
{#DM} PG-Production-HxDefines1[#ModuleName, (#Define1[dummy]; #Defines), #SortName]
;

{#DM} PG-Production-HxDefines1[#ModuleName, (D_RULE[#Rule, #RuleSort, #IsData]; #Defines), #SortName]
→
{#DM} PG-Production-HxDefines1[#ModuleName, #Defines, #SortName]
;

{#DM} PG-Production-HxDefines1[#ModuleName, (D_FORM[#Form1, #Kind1]; #Defines), #SortName]
→
%n⟪« {#DM} PG-Production-HxForm[#ModuleName, #Form1, #Kind1, #SortName] »« {#DM} PG-Production-HxDefines1[#ModuleName, #Defines, #SortName] »⟫
;

{#DM} PG-Production-HxDefines1[#ModuleName, (D_SYNTHESIZES[#AttributeName1]; #Defines), #SortName]
→
{#DM} PG-Production-HxDefines1[#ModuleName, #Defines, #SortName]
;

{#DM} PG-Production-HxDefines1[#ModuleName, (), #SortName]
→
%n⟪⟫
;

{$String<!--SortName--> : DeclarationMapEntry} PG-Production-HxForm[HxForm, FormKind, $String] :: Text;

{#DM} PG-Production-HxForm[#ModuleName, Hx_M_FormParsedSorted[#Sort1, #ParsedForm1, #Prec1, #InheritedRefs], #Kind1, #SortName]
→
%n⟪⟫
;

{#DM} PG-Production-HxForm[#ModuleName, Hx_M_FormParsed[#ParsedForm1, #Prec1, #InheritedRefs], #Kind1, #SortName]
→
%n⟪⟫
;

{#DM} PG-Production-HxForm[#ModuleName, Hx_M_FormConstruction[#Constructor, #ScopeSortList, #InheritedRefs], #Kind1, #SortName]
→
%n⟪| Hx_TOKEN_†«#Constructor»$ « IfEmpty[#ScopeSortList, %n⟨( Hx_LPAREN Hx_RPAREN )? ⟩, %n⟨ Hx_LPAREN ‹ {#DM} PG-Production-HxScopeSortList[#ModuleName, #ScopeSortList, #SortName, B_TRUE] › Hx_RPAREN ⟩] »
⟫;

{$String<!--SortName--> : DeclarationMapEntry} PG-Production-HxScopeSortList[$List[HxScopeSort], $String, Boolean] :: Text;

{#DM} PG-Production-HxScopeSortList[#ModuleName, (%HxScopeSort⟪ #Sort# #Repeat# [ #SubstituteSorts# ] ⟫ ; #ScopeSortList), #SortName, #first]
→
%n⟪« If[#first, %n⟨⟩, %n⟨ Hx_COMMA ⟩] »« {#DM} PG-Production-HxScopeSort[#ModuleName, #Sort#, #SubstituteSorts#, #SortName] »« {#DM} PG-Production-HxScopeSortList[#ModuleName, #ScopeSortList, #SortName, B_FALSE] »⟫
;  //note: ignores #Repeat because arguments to Hx terms cannot use repeat-forms...or should they?

-[Free[v::Text]]:
{#DM} PG-Production-HxScopeSortList[#ModuleName, (%HxBindersScopeSort⟪ [ v : #Sort# ] #BindersScopeSort# ⟫ ; #ScopeSortList), #SortName, #first]
→
{#DM} PG-Production-HxScopeSortList[#ModuleName, (#BindersScopeSort# ; #ScopeSortList), #SortName, #first]
;

-[Free[v::Text]]:
{#DM} PG-Production-HxScopeSortList[#ModuleName, (%HxScopeSort⟪ [ v : #Sort# ] ⟫ ; #ScopeSortList), #SortName, #first]
→
$[Error, "There should not be binder subterm sorts."]
;

{#DM} PG-Production-HxScopeSortList[#ModuleName, (), #SortName, #first] → %n⟪⟫ ;

{$String<!--SortName--> : DeclarationMapEntry} PG-Production-HxScopeSort[HxSort, $List[HxSubstituteSort], $String] :: Text;

{#DM} PG-Production-HxScopeSort[#ModuleName, #Sort#, #SubstituteSorts#, #SortName]
→
IfEmpty[#SubstituteSorts#,
  %n⟪<Hx_†«PG-SortName[#Sort#]»>⟫,
  %n⟪« {#DM}PG-Production-HxScope[#ModuleName, #SubstituteSorts#, %n⟨<Hx_†‹PG-SortName[#Sort#]›>⟩, %n⟨⟩, %n⟨Hx_LBRACKET⟩, %n⟨[⟩] »⟫]  //start:[
;

{$String<!--SortName--> : DeclarationMapEntry} PG-Production-HxScope[$List[HxSubstituteSort], Text, Text, Text, Text] :: Text;

-[Fresh[x::Text]]:
{#DM}PG-Production-HxScope[#ModuleName, (#SubstituteSort ; #SubstituteSorts), #SortRef, #ScopedVars, #sep, #argsep]
→ 
%n⟪ «#sep» Hx_VARIABLE^«x» « {#DM}PG-Production-HxScope[#ModuleName, #SubstituteSorts, #SortRef, %n⟨‹#ScopedVars›‹#argsep›‹x›⟩, %n⟨Hx_COMMA⟩, %n⟨¸⟩] »⟫
; 

{#DM}PG-Production-HxScope[#ModuleName, (), #SortRef, #ScopedVars, #sep, #argsep] → %n⟪ Hx_RBRACKET « #SortRef »« #ScopedVars »]⟫ ;  //end:]

{$String<!--SortName--> : DeclarationMapEntry} PG-Production-HxDefinesTokens[#ModuleName, $List[Define], $String] :: Text;

-[Fresh[dummy::HxSortParam]]:
{#DM} PG-Production-HxDefinesTokens[#ModuleName, (D_ABSTRACTION[a.#Define1[a]]; #Defines), #SortName]
→
{#DM} PG-Production-HxDefinesTokens[#ModuleName, (#Define1[dummy]; #Defines), #SortName]
;

{#DM} PG-Production-HxDefinesTokens[#ModuleName, (D_RULE[#Rule, #RuleSort, #IsData]; #Defines), #SortName]
→
{#DM} PG-Production-HxDefinesTokens[#ModuleName, #Defines, #SortName]
;

{#DM} PG-Production-HxDefinesTokens[#ModuleName, (D_FORM[#Form1, #Kind1]; #Defines), #SortName]
→
%n⟪« {#DM} PG-Production-HxFormToken[#ModuleName, #Form1, #Kind1, #SortName] »« {#DM} PG-Production-HxDefinesTokens[#ModuleName, #Defines, #SortName] »⟫
;

{#DM} PG-Production-HxDefinesTokens[#ModuleName, (D_SYNTHESIZES[#AttributeName1]; #Defines), #SortName]
→
{#DM} PG-Production-HxDefinesTokens[#ModuleName, #Defines, #SortName]
;

{#DM} PG-Production-HxDefinesTokens[#ModuleName, (), #SortName]
→
%n⟪⟫
;

{$String<!--SortName--> : DeclarationMapEntry} PG-Production-HxFormToken[HxForm, FormKind, $String] :: Text;
{#DM} PG-Production-HxFormToken[#ModuleName, Hx_M_FormParsedSorted[#Sort1, #ParsedForm1, #Prec1, #InheritedRefs], #Kind1, #SortName] → %n⟪⟫ ;
{#DM} PG-Production-HxFormToken[#ModuleName, Hx_M_FormParsed[#ParsedForm1, #Prec1, #InheritedRefs], #Kind1, #SortName] → %n⟪⟫ ;
{#DM} PG-Production-HxFormToken[#ModuleName, Hx_M_FormConstruction[#Constructor, #ScopeSortList, #InheritedRefs], #Kind1, #SortName] → %n⟪token Hx_TOKEN_†«#Constructor» (Hx) ::= "†«#Constructor»" .
⟫;


// Meta-definitions for sorts.

{$String<!--SortName--> : DeclarationMapEntry} PG-MetaHead[Boolean, $String<!--ModuleName-->, $String, $String, Boolean, $Numeric] :: Text;

PG-MetaHead[B_FALSE, #ModuleName, #SortName, #Name, #isLeftRecursive, #Prec] → %n⟪⟫ ;

-[Data[#SortName],Discard[#Prec]]:
{#DM}
PG-MetaHead[B_TRUE, #ModuleName, #SortName, #Name, B_FALSE, #Prec] →
 %n⟪
/***METAPG: meta1_«PG-TokenNameText[#Name] »:unconcrete | ***/
/***METAPG: meta2_«PG-TokenNameText[#Name] »$$:[[unmeta(#,†«$[FormatNumber,$[Length,#SortName]]»)]]:{ [[ hxornaked("†«PG-Prefix[#ModuleName]»HxPresorted_†«#SortName»") ]] } | ***/
⟫ ;

-[Data[#SortName]]:
{#DM}
PG-MetaHead[B_TRUE, #ModuleName, #SortName, #Name, B_TRUE, #Prec] →
 %n⟪
/***METAPG: meta1_«PG-TokenNameText[#Name]»$:unconcrete:#1 <« PG-ProductionNameWithPrecText[#SortName, #Prec] »LR #1> | ***/
/***METAPG: meta2_«PG-TokenNameText[#Name]»$$:[[unmeta(#,†«$[FormatNumber,$[Length,#SortName]]»)]]:{ [[ hxornaked("†«PG-Prefix[#ModuleName]»HxPresorted_†«#SortName»") ]] }:#1 <« PG-ProductionNameWithPrecText[#SortName, #Prec] »LR #1> | ***/
⟫ ;


PG-MetaTail[Boolean, $String, $String] :: Text;

PG-MetaTail[B_FALSE, #SortName, #Name] → %n⟪⟫ ;

-[Data[#SortName]]: PG-MetaTail[B_TRUE, #SortName, #Name] → %n⟪
/***METAPG: %{ ***/
/***METAPG: /* Meta token for †«#SortName». */  ***/
/***METAPG: <Hx> TOKEN : { < T_meta1_«PG-TokenNameText[#Name]» : ("\u27e8" (" ")* †« Stringify[#SortName] » (" ")* "\u27e9") > } ***/
/***METAPG: <Hx> MORE : { < "\u27e8" (" ")* †« Stringify[#SortName] » (" ")* ~["\u27e8","\u27e9"] > { nesting = 0; nestedState = curLexState; } : IN_META_«PG-TokenNameText[#Name]» } ***/
/***METAPG: <IN_META_«PG-TokenNameText[#Name]»> MORE : { "\u27e8" { nesting = 1; } : IN_NESTED_META_«PG-TokenNameText[#Name]» } ***/
/***METAPG: <IN_NESTED_META_«PG-TokenNameText[#Name]»> MORE : { "\u27e8" { nesting++; } } ***/
/***METAPG: <IN_NESTED_META_«PG-TokenNameText[#Name]»> MORE : { "\u27e9" { if (--nesting <= 0) SwitchTo(IN_META_«PG-TokenNameText[#Name]»); } } ***/
/***METAPG: <IN_META_«PG-TokenNameText[#Name]»> TOKEN : { < T_meta2_«PG-TokenNameText[#Name]» : "\u27e9" > { SwitchTo(nestedState); } } ***/
/***METAPG: <IN_META_«PG-TokenNameText[#Name]»,IN_NESTED_META_«PG-TokenNameText[#Name]»> MORE : { < ~[] > } ***/
/***METAPG: %} ***/
⟫ ;



// Text of single sort+precedence production expansion.
//
// Emits the left recursion handler, if any, and the PG grammar production
// for the sort+precedence combination, with left factored buffering.

CONSUMPTION_SORT ::=( C_BUFFER[$String<!--SortName-->, $Numeric<!--precedence-->]; C_LEFTRECURSIVE[$String<!--SortName-->, $Numeric<!--precedence-->]; <!--C_INLINE;--> );
/// C_INLINE DISABLED.

{$String<!--SortName--> : DeclarationMapEntry} PG-Expand[$List[PFK_SORT], $String, $Numeric, Boolean<!--Last-->] :: Text;
{#DM} PG-Expand[#ModuleName, #PrecPFKs, #SortName, #Prec, #Last?]
→
{#DM} PG-LeftRecursive[#ModuleName, #PrecPFKs, #SortName, #Prec, #Last?, (), ()]
;

// Generate optional left recursion production helper, normal production, and optional meta-production.

{$String<!--SortName--> : DeclarationMapEntry} PG-LeftRecursive[$List[PFK_SORT], $String, $Numeric, Boolean, $List[PFK_SORT], $List[PFK_SORT]] :: Text;
{$String<!--SortName--> : DeclarationMapEntry} PG-LeftRecursive2[Boolean, PFK_SORT, $List[PFK_SORT], $String, $Numeric, Boolean, $List[PFK_SORT], $List[PFK_SORT]] :: Text;

{#DM} PG-LeftRecursive[#ModuleName, (#PFK1; #PFKs), #SortName, #Prec, #Last?, #LeftRecursivePFKs, #OtherPFKs]
→
{#DM} PG-LeftRecursive2[#ModuleName, PG-isLeftRecursive[#SortName, #Prec, #PFK1], #PFK1, #PFKs, #SortName, #Prec, #Last?, #LeftRecursivePFKs, #OtherPFKs]
;

    // HAND-CODED HACK to recognize and strip left recursive production (because Hx.pg cannot match parsed forms...). 

    PG-isLeftRecursive[$String, $Numeric, PFK_SORT] :: Boolean;

    PG-isLeftRecursive[#SortName, #Prec, PFK[Hx_M_ParsedFormSpace[#Space, #ParsedForm1], #Kind]]
    →
    PG-isLeftRecursive[#SortName, #Prec, PFK[#ParsedForm1, #Kind]]
    ;

    PG-isLeftRecursive[#SortName, #Prec, PFK[Hx_M_ParsedFormWord[#Word, #ParsedForm1], #Kind]]
    →
    B_FALSE
    ;

    -[Data[#Sort]]:
    PG-isLeftRecursive[#SortName, #Prec, PFK[Hx_M_ParsedFormTerm[Hx_M_ScopeSortPrecRepeat[#Sort1, #Prec1, #Repeat1], #ParsedForm1], #Kind]]
    →
    $[If, $[NumericEqual,#Prec,#Prec1], PG-isLeftRecursive1[#SortName, #Sort1], B_FALSE]
    ;

    PG-isLeftRecursive[#SortName, #Prec, PFK[Hx_M_ParsedFormDone, #Kind]]
    →
    B_FALSE
    ;

    PG-isLeftRecursive1[$String, HxScopeSort] :: Boolean;

    PG-isLeftRecursive1[#SortName,
      Hx_M_ScopeSort[
	Hx_M_Sort[Hx_M_SortName[#SortName1, #_1], '$Nil'],
	Hx_M_RepeatSingle,
	'$Nil']]
    →
    SameString[#SortName,#SortName1]
    ;

    -[Data[#Kind]]:
    PG-isLeftRecursive1[#SortName, $[NotMatch,
      Hx_M_ScopeSort[
	Hx_M_Sort[Hx_M_SortName[#SortName1, #_1], '$Nil'],
	Hx_M_RepeatSingle,
	'$Nil'],#_]]
    →
    B_FALSE
    ;

    PG-stripLeftRecursion[PFK_SORT] :: PFK_SORT;
    PG-stripLeftRecursion[PFK[Hx_M_ParsedFormSpace[#Space, #ParsedForm1], #Kind]]
    →
    PG-stripLeftRecursion[PFK[#ParsedForm1, #Kind]]
    ;
    PG-stripLeftRecursion[
      PFK[
	Hx_M_ParsedFormTerm[
	  Hx_M_ScopeSortPrecRepeat[
	    Hx_M_ScopeSort[
	      Hx_M_Sort[Hx_M_SortName[#SortName, #_], '$Nil'],
	      Hx_M_RepeatSingle,
	      '$Nil'],
	    #Prec,
	    #Repeat],
	      #ParsedForm],
	#Kind]]
    →
    PFK[#ParsedForm, #Kind]
    ;





{#DM} PG-LeftRecursive2[#ModuleName, B_TRUE, #PFK1, #PFKs, #SortName, #Prec, #Last?, #LeftRecursivePFKs, #OtherPFKs]
→
{#DM} PG-LeftRecursive[#ModuleName, #PFKs, #SortName, #Prec, #Last?, Append[#LeftRecursivePFKs, (PG-stripLeftRecursion[#PFK1];)], #OtherPFKs]
;

{#DM} PG-LeftRecursive2[#ModuleName, B_FALSE, #PFK1, #PFKs, #SortName, #Prec, #Last?, #LeftRecursivePFKs, #OtherPFKs]
→
{#DM} PG-LeftRecursive[#ModuleName, #PFKs, #SortName, #Prec, #Last?, #LeftRecursivePFKs, Append[#OtherPFKs, (#PFK1;)]]
;

{#DM} PG-LeftRecursive[#ModuleName, (), #SortName, #Prec, #Last?, #LeftRecursivePFKs, #OtherPFKs]
→
IfEmpty[#LeftRecursivePFKs,
  // There is no left recursion -- use the plain expansion.
  {#DM} PG-Produce[#ModuleName, #SortName, #Prec, #Last?, #OtherPFKs, C_BUFFER[#SortName, #Prec]],
  // There is left recursion...
  {#DM} PG-ProduceBody[#ModuleName, #SortName, #LeftRecursivePFKs, 2, (%n⟨#1⟩;), (%n⟨LR⟩;), C_LEFTRECURSIVE[#SortName, #Prec], in funs tags after .
    %n⟪/* Handle left recursion. */
<«PG-ProductionNameWithPrecText[#SortName, #Prec]»LR #1> ::= ⟦«in»
| {{#1}}⟧
.
/***SORTS: †«PG-QN[#ModuleName, "NodeSort", #SortName]» ::= ( «tags» ); ***/

«funs»
« TextJoinMap[after, %n⟨
⟩] »
« {#DM} PG-Produce[#ModuleName, #SortName, #Prec, #Last?, #OtherPFKs, C_LEFTRECURSIVE[#SortName, #Prec]] »⟫]]
;

{$String<!--SortName--> : DeclarationMapEntry} PG-Produce[$String<!--ModuleName-->, $String<!--SortName-->, $Numeric<!--Prec-->, Boolean<!--Last?-->, $List[PFK_SORT], CONSUMPTION_SORT] :: Text;

{#DM} PG-Produce[#ModuleName, #SortName, #Prec, #Last?, #PFKs, C_LEFTRECURSIVE[#SortName9, #Prec9]]
→
{#DM} PG-ProduceBody[#ModuleName, #SortName, #PFKs, 1, (), (), C_LEFTRECURSIVE[#SortName9, #Prec9], in funs tags after .
  %n⟪
<«PG-ProductionNameWithPrecText[#SortName, #Prec]»> ::= ⟦« {#DM}PG-MetaHead[#Last?, #ModuleName, #SortName, #SortName, B_TRUE, #Prec] »«in»⟧ .

/***SORTS: †«PG-QN[#ModuleName, "NodeSort", #SortName]» ::= ( «tags» ); ***/
«funs»
« {#DM}PG-MetaTail[#Last?, #SortName, #SortName] »« TextJoinMap[after, %n⟨
⟩] »⟫]
;

-[Data[#consumer]]:
{#DM} PG-Produce[#ModuleName, #SortName, #Prec, #Last?, #PFKs, $[NotMatch,C_LEFTRECURSIVE[#_SortName, #_Prec],#consumer]]
→
{#DM} PG-ProduceBody[#ModuleName, #SortName, #PFKs, 1, (), (), #consumer, in funs tags after .
  %n⟪
<«PG-ProductionNameWithPrecText[#SortName,#Prec]»> ::= ⟦« {#DM}PG-MetaHead[#Last?, #ModuleName, #SortName, #SortName, B_FALSE, #Prec] »«in» .⟧ 

« PG-TagSortDeclaration[#ModuleName, #SortName, funs, tags] »
« {#DM}PG-MetaTail[#Last?, #SortName, #SortName] »« TextJoinMap[after, %n⟨
⟩] »⟫]
;


PG-TagSortDeclaration[#ModuleName, #SortName, #funs, #tags]
→
%n⟪
/***SORTS: †«PG-QN[#ModuleName, "TagSort", #SortName]» ::= ( « #tags » ); ***/
«#funs»⟫
;

///PG-MetaHead[#dontcare, #SortName, #Name, #isLeftRecursive, #Prec] → %n⟪⟫ ;
///PG-MetaTail[#dontcare, #SortName, #Name] → %n⟪⟫ ;


{$String<!--SortName--> : DeclarationMapEntry} PG-ProduceBody[$String<!--ModuleName-->, $String<!--HostSort-->, $List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

-[Data[#PFKs]]:
{#DM} PG-ProduceBody[#ModuleName, #SortName, #PFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBody1[#ModuleName, #SortName, #PFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

// Pick branching kind.

{$String<!--SortName--> : DeclarationMapEntry} PG-ProduceBody1[$String<!--ModuleName-->, $String<!--HostSort-->, $List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

{#DM} PG-ProduceBody1[#ModuleName, #SortName, (), #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
#[%n⟪⟫, %n⟪⟫, %n⟪⟫, EmptyTextMap]
;

{#DM} PG-ProduceBody1[#ModuleName, #SortName, (PFK[Hx_M_ParsedFormWord[#word, #ParsedForm], #Kind]; #Rest), #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyWord1[#ModuleName, #SortName, #Rest, (), #word, (PFK[#ParsedForm, #Kind];), #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{#DM} PG-ProduceBody1[#ModuleName, #SortName, (PFK[Hx_M_ParsedFormTerm[Hx_M_ScopeSortPrecRepeat[#ScopeSort, #Prec, #Repeat], #ParsedForm], #Kind]; #Rest), #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyTerm1[#ModuleName, #SortName, #Rest, (), #ScopeSort, #Prec, #Repeat, #Kind, (PFK[#ParsedForm, #Kind];), #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{#DM} PG-ProduceBody1[#ModuleName, #SortName, (PFK[Hx_M_ParsedFormSpace[#space, #ParsedForm], #Kind]; #Rest), #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBody1[#ModuleName, #SortName, (PFK[#ParsedForm, #Kind]; #Rest), #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{#DM} PG-ProduceBody1[#ModuleName, #SortName, (PFK[Hx_M_ParsedFormDone, #Kind]; #Rest), #n, #terms, #words, C_BUFFER[#SortName, #Prec], in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBody2[#ModuleName, #SortName, #Rest, #n, #terms, #words, C_BUFFER[#SortName, #Prec], in funs tags after . #[in,funs,tags,after],
  PG-AttributeCollection[#ModuleName, #Kind, #SortName, #Prec, PG-ProductionConstructionText[#ModuleName, #SortName, #Prec, #Kind, #words, #terms], B_FALSE],
  PG-ProductionSortFunsText[#ModuleName, #SortName, #Prec, #Kind, #words, #terms],
  PG-ProductionSortTagsText[#ModuleName, #SortName, #Prec, #Kind, #words, #terms],
  PG-AttributeProduction[#ModuleName, #Kind, #SortName, #Prec, B_FALSE]]
;

{#DM} PG-ProduceBody1[#ModuleName, #SortName, (PFK[Hx_M_ParsedFormDone, #Kind]; #Rest), #n, #terms, #words, C_LEFTRECURSIVE[#SortName, #Prec], in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBody2[#ModuleName, #SortName, #Rest, #n, #terms, #words, C_LEFTRECURSIVE[#SortName, #Prec], in funs tags after . #[in,funs,tags,after],
  PG-AttributeCollection[#ModuleName, #Kind, #SortName, #Prec, PG-ProductionConstructionText[#ModuleName, #SortName, #Prec, #Kind, #words, #terms], B_TRUE],
  PG-ProductionSortFunsText[#ModuleName, #SortName, #Prec, #Kind, #words, #terms],
  PG-ProductionSortTagsText[#ModuleName, #SortName, #Prec, #Kind, #words, #terms],
  PG-AttributeProduction[#ModuleName, #Kind, #SortName, #Prec, B_TRUE]]
;

{$String<!--SortName--> : DeclarationMapEntry} PG-ProduceBody2[$String<!--ModuleName-->, $String<!--HostSort-->, $List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text, Text, TextMapSort] :: Text;
-[Data[#in2,#sort2,#after2]]:
{#DM} PG-ProduceBody2[#ModuleName, #SortName, #Rest, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after], #in2, #funs2, #tags2, #after2]
→
{#DM} PG-ProduceBody1[#ModuleName, #SortName, #Rest, #n, #terms, #words, #consumer, in funs tags after . #[%n⟪« #in2 »«in»⟫, %n⟪« #funs2 »«funs»⟫, %n⟪« #tags2 »«tags»⟫, JoinTextMaps[#after2, after]]]
;

PG-AttributeCollection[FormKind, $String, $Numeric, Text, Boolean] :: Text;

PG-AttributeCollection[#ModuleName, #Kind, #SortName, #Prec, #Construct, B_FALSE] → #Construct ;
PG-AttributeCollection[#ModuleName, #Kind, #SortName, #Prec, #Construct, B_TRUE] → %n⟪<«PG-ProductionNameWithPrecText[#SortName,#Prec]»LR «#Construct»>⟫ ;

PG-AttributeProduction[FormKind, $String, $Numeric, Boolean] :: TextMapSort;
PG-AttributeProduction[#ModuleName, #dontcare, #SortName, #Prec, #IsLeftRecursive]
→
EmptyTextMap //TODO: eliminate?
;

PG-ProductionSortFunsText[$String<!--ModuleName-->, $String, $Numeric, FormKind, $List[Text], $List[Text]] :: Text;

-[Data[#SortName,#Prec],Data[#words]]:
PG-ProductionSortFunsText[#ModuleName, #SortName, #Prec, #scheme, #words, #terms]
→
%n⟪
/***METAELIM: †«PG-QN[#ModuleName, "Node", #SortName]»[†« PG-QN[#ModuleName, "Tag", StringJoin[(PG-ProductionNameWithPrec[#SortName, #Prec]; IfEmpty[#words, "EMPTY", MapWhen[ok x.TextToStringWhen[ok, x], #words]]), "_"]] »« WrappedTextJoin[#terms, %n⟨, (⟩, %n⟨; ⟩, %n⟨;)⟩] »]; ***/
⟫;

PG-ProductionSortTagsText[$String<!--ModuleName-->, $String, $Numeric, FormKind, $List[Text], $List[Text]] :: Text;

-[Data[#SortName,#Prec],Data[#words]]:
PG-ProductionSortTagsText[#ModuleName, #SortName, #Prec, #scheme, #words, #terms]
→
%n⟪†« PG-QN[#ModuleName, #SortName, StringJoin[(PG-ProductionNameWithPrec[#SortName, #Prec]; IfEmpty[#words, "EMPTY", MapWhen[ok x.TextToStringWhen[ok, x], #words]]), "_"]] »; ⟫
;

PG-ProductionConstructionText[$String<!--ModuleName-->, $String, $Numeric, FormKind, $List[Text], $List[Text]] :: Text;

-[Data[#SortName,#Prec],Data[#words]]:
PG-ProductionConstructionText[#ModuleName, #SortName, #Prec, FK_SCHEME[#Inh], #words, #terms]
→
%n⟪⟦ {{
/***PG: '†« PG-QN[#ModuleName, PG-ProductionNameWithPrec[#SortName, #Prec], IfEmpty[#words, "EMPTY", MapStringConcatWhen[ok x.TextToStringWhen[ok, x], #words]]] »'« WrappedTextJoin[#terms, %n⟨[⟩, %n⟨, ⟩, %n⟨]⟩] » ***/
/***METAPG: '†« PG-QN[#ModuleName, "Node", #SortName] »[†« PG-QN[#ModuleName, "Tag", StringJoin[(PG-ProductionNameWithPrec[#SortName, #Prec]; IfEmpty[#words, "EMPTY", MapWhen[ok x.TextToStringWhen[ok, x], #words]]), "_"]] »'« WrappedTextJoin[#terms, %n⟨, (⟩, %n⟨; ⟩, %n⟨;)⟩] »] ***/
}}⟧
⟫
;

-[Data[#SortName,#Prec],Data[#words]]:
PG-ProductionConstructionText[#ModuleName, #SortName, #Prec, FK_SUGAR[#Inh], #words, #terms]
→
%n⟪⟦ {{ « WrappedTextJoin[#terms, %n⟨⟩, %n⟨ ⟩, %n⟨⟩] » }}⟧
⟫
;

-[Data[#SortName,#Prec,#Kind],Data[#words]]:
PG-ProductionConstructionText[#ModuleName, #SortName, #Prec, $[NotMatch,FK_SCHEME[#_Inh],$[NotMatch,FK_SUGAR[#_term],#Kind]], #words, #terms]
→
IfAliasKind[#Kind, WrappedTextJoin[#terms, %n⟨ {{⟩, %n⟨ ⟩, %n⟨}}⟩],
  %n⟪⟦ {{
/***PG: '†« PG-QN[#ModuleName, PG-ProductionNameWithPrec[#SortName, #Prec], IfEmpty[#words, "EMPTY", MapStringConcatWhen[ok x.TextToStringWhen[ok, x], #words]]] »'« WrappedTextJoin[#terms, %n⟨[⟩, %n⟨, ⟩, %n⟨]⟩] » ***/
/***METAPG: '†« PG-QN[#ModuleName, "Node", #SortName] »[†« PG-QN[#ModuleName, "Tag", StringJoin[(PG-ProductionNameWithPrec[#SortName, #Prec]; IfEmpty[#words, "EMPTY", MapWhen[ok x.TextToStringWhen[ok, x], #words]]), "_"]] »'« WrappedTextJoin[#terms, %n⟨, (⟩, %n⟨; ⟩, %n⟨;)⟩] »] ***/
}}⟧
⟫]
;

∀ a . IfAliasKind[FormKind, a, a] :: a;
IfAliasKind[FK_ALIAS, #1, #2] → #1 ;
IfAliasKind[FK_SYMBOL[#IsStatic, #t], #1, #2] → #1 ;
-[Data[#Kind]]: IfAliasKind[$[NotMatch,FK_ALIAS,$[NotMatch,FK_SYMBOL[#IsStatic, #t],#Kind]], #1, #2] → #2 ;

// (1) Constant Token Case: (a) collect productions starting with the constant token and ...

{$String<!--SortName--> : DeclarationMapEntry} PG-ProduceBodyWord1[$String<!--ModuleName-->, $String<!--HostSort-->, $List[PFK_SORT], $List[PFK_SORT], $String, $List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

-[Data[#word1,#word],Share[#ParsedForm1,#Kind1,#Rest,#wordPFKs,#n,#terms,#words,#consumer]]:
{#DM} PG-ProduceBodyWord1[#ModuleName, #SortName, (PFK[Hx_M_ParsedFormWord[#word1, #ParsedForm1], #Kind1]; #Rest), #Failed, #word, #wordPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
$[If, $[Equal, #word, #word1],
  {#DM} PG-ProduceBodyWord1[#ModuleName, #SortName, #Rest, #Failed, #word, Append[#wordPFKs, (PFK[#ParsedForm1, #Kind1];)], #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]],
  {#DM} PG-ProduceBodyWord1[#ModuleName, #SortName, #Rest, Append[#Failed, (PFK[Hx_M_ParsedFormWord[#word1, #ParsedForm1], #Kind1];)], #word, #wordPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]]
;

{#DM} PG-ProduceBodyWord1[#ModuleName, #SortName, (PFK[Hx_M_ParsedFormTerm[#ScopeSortPrecRepeat1, #ParsedForm1], #Kind]; #Rest), #Failed, #word, #wordPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyWord1[#ModuleName, #SortName, #Rest, Append[#Failed, (PFK[Hx_M_ParsedFormTerm[#ScopeSortPrecRepeat1, #ParsedForm1], #Kind];)], #word, #wordPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{#DM} PG-ProduceBodyWord1[#ModuleName, #SortName, (PFK[Hx_M_ParsedFormSpace[#space1, #ParsedForm1], #Kind1]; #Rest), #Failed, #word, #wordPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyWord1[#ModuleName, #SortName, (PFK[#ParsedForm1, #Kind1]; #Rest), #Failed, #word, #wordPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{#DM} PG-ProduceBodyWord1[#ModuleName, #SortName, (PFK[Hx_M_ParsedFormDone, #Kind]; #Rest), #Failed, #word, #wordPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyWord1[#ModuleName, #SortName, #Rest, Append[#Failed, (PFK[Hx_M_ParsedFormDone, #Kind];)], #word, #wordPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{#DM} PG-ProduceBodyWord1[#ModuleName, #SortName, (), #Failed, #word, #wordPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyWord2[#ModuleName, #SortName, #Failed, #word, #wordPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

// ... (b) emit constant token branch.

{$String<!--SortName--> : DeclarationMapEntry} PG-ProduceBodyWord2[$String<!--ModuleName-->, $String<!--HostSort-->, $List[PFK_SORT], $String, $List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

{#DM} PG-ProduceBodyWord2[#ModuleName, #SortName, (), #word, #wordPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBody[#ModuleName, #SortName, #wordPFKs, #n, #terms, Append[#words, (%n⟨†‹$[Mangle,#word]›⟩;)], #consumer, in1 funs1 tags1 after1 . #[%n⟪« ProductionWord[#word] »⟦« in1 »⟧⟫, funs1, tags1, after1]]
;

{#DM} PG-ProduceBodyWord2[#ModuleName, #SortName, (#PFK1;#PFKs), #word, #wordPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBody[#ModuleName, #SortName, #wordPFKs, #n, #terms, Append[#words, (%n⟨†‹$[Mangle,#word]›⟩;)], #consumer, in1 funs1 tags1 after1 .
  {#DM} PG-ProduceBody[#ModuleName, #SortName, (#PFK1;#PFKs), #n, #terms, #words, #consumer, in2 funs2 tags2 after2 .
    #[%n⟪(« ProductionWord[#word] »« in1 »
| « in2 »)⟫, %n⟪«funs1»«funs2»⟫, %n⟪«tags1»«tags2»⟫, JoinTextMaps[after1, after2]]]]
;

    ProductionWord[$String] :: Text;
    ProductionWord[#word] → %n⟪†« Stringify[#word] »⟫ ;

// (2) Common Nonterminal: (a) collect productions starting with the nonterminal and...

{$String : DeclarationMapEntry} PG-ProduceBodyTerm1[$String<!--ModuleName-->, $String<!--HostSort-->,
	$List[PFK_SORT], $List[PFK_SORT], HxScopeSort, $Numeric, HxRepeat, FormKind, $List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

{#DM} PG-ProduceBodyTerm1[#ModuleName, #SortName, (PFK[Hx_M_ParsedFormWord[#word1, #ParsedForm1], #Kind1]; #Rest), #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyTerm1[#ModuleName, #SortName, #Rest, Append[#Failed, (PFK[Hx_M_ParsedFormWord[#word1, #ParsedForm1], #Kind1];)], #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{#DM} PG-ProduceBodyTerm1[#ModuleName, #SortName, (PFK[Hx_M_ParsedFormTerm[Hx_M_ScopeSortPrecRepeat[#ScopeSort1, #Prec1, #Repeat1], #ParsedForm1], #Kind1]; #Rest), #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyTerm1x[#ModuleName, #SortName, PG-SameScopeSort[#ScopeSort1, #Prec1, #Repeat1, #ScopeSort, #Prec, #Repeat], #ScopeSort1, #Prec1, #Repeat1, #ParsedForm1, #Kind1, #Rest, #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

    // Local test if two ScopeSorts are the same.
    
    PG-SameScopeSort[HxScopeSort, $Numeric, HxRepeat, HxScopeSort, $Numeric, HxRepeat] :: Boolean;
    PG-SameScopeSort[#Sort1, #Prec1, #Repeat1, #Sort2, #Prec2, #Repeat2] → PG-SameScopeSort2[#Sort1, #Sort2, #Prec1, #Repeat1, #Prec2, #Repeat2] ;
    
    PG-SameScopeSort2[HxScopeSort, HxScopeSort, $Numeric, HxRepeat, $Numeric, HxRepeat] :: Boolean;
    
    PG-SameScopeSort2[%HxScopeSort⟪ #Sort1# [ #SubstituteSorts1# ] ⟫, %HxScopeSort⟪ #Sort2# [ #SubstituteSorts2# ] ⟫, #Prec1, #Repeat1, #Prec2, #Repeat2]
    →
    And[PG-SameSort[#Sort1#, #Sort2#], And[PG-SamePrec[#Prec1, #Prec2], PG-SubRepeat[#Repeat1, #Repeat2]]]
    ;
    -[Free[v1::Text]]:
    PG-SameScopeSort2[%HxScopeSort⟪ [ v1 : #Sort1# ] ⟫                   , %HxScopeSort⟪ #Sort2# [ #SubstituteSorts2# ] ⟫, #P1, #R1, #P2, #R2] → B_FALSE ;
    -[Free[v2::Text]]:
    PG-SameScopeSort2[%HxScopeSort⟪ #Sort1# [ #SubstituteSorts1# ] ⟫, %HxScopeSort⟪ [ v2 : #Sort2# ] ⟫, #P1, #R1, #P2, #R2] → B_FALSE ;
    -[Free[v1::Text,v2::Text]]:
    PG-SameScopeSort2[%HxScopeSort⟪ [ v1 : #Sort1# ] ⟫                   , %HxScopeSort⟪ [ v2 : #Sort2# ] ⟫, #P1, #R1, #P2, #R2] → PG-SameSort[#Sort1#, #Sort2#] ;
    
    PG-SameSort[HxSort, HxSort] :: Boolean;
    -[Data[#1,#2]]: PG-SameSort[#1, #2] → PG-SameSort2[#1, #2] ;
    
    PG-SameSort2[HxSort, HxSort] :: Boolean;
    
    -[Data[#SortName1#,#SortName2#]]:
    PG-SameSort2[%HxSort⟪ #SortName1# #MetaVariables1# #SimpleSorts1# ⟫, %HxSort⟪ #SortName2# #MetaVariables2# #SimpleSorts2# ⟫]
    →
    $[If, $[Equal, #SortName1#, #SortName2#], B_TRUE, B_FALSE]
    ;
    
    PG-SameSort2[$[NotMatch,%HxSort⟪ #SortName1# #MetaVariables1# #SimpleSorts1# ⟫,#1], #2]
    →
    B_FALSE
    ;
    
    PG-SameSort2[#1,$[NotMatch,%HxSort⟪ #SortName2# #MetaVariables2# #SimpleSorts2# ⟫,#2]]
    →
    B_FALSE
    ;
    
    PG-SamePrec[$Numeric, $Numeric] :: Boolean;
    -[Data[#Prec1,#Prec2]]: PG-SamePrec[#Prec1, #Prec2] → $[If, $[NumericEqual, #Prec1, #Prec2], B_TRUE, B_FALSE] ;
    
    PG-SubRepeat[HxRepeat, HxRepeat] :: Boolean;
    
    PG-SubRepeat-single: PG-SubRepeat[%HxRepeat⟪ ⟫, #Repeat2] → B_TRUE ;
    
    PG-SubRepeat-maybe-single: PG-SubRepeat[%HxRepeat⟪ ? ⟫, %HxRepeat⟪ ⟫] → B_FALSE;
    PG-SubRepeat-maybe-maybe: PG-SubRepeat[%HxRepeat⟪ ? ⟫, %HxRepeat⟪ ? ⟫] → B_TRUE;
    PG-SubRepeat-maybe-many: PG-SubRepeat[%HxRepeat⟪ ? ⟫, %HxRepeat⟪ * ⟫] → B_TRUE;
    PG-SubRepeat-maybe-some: PG-SubRepeat[%HxRepeat⟪ ? ⟫, %HxRepeat⟪ + ⟫] → B_FALSE;
    PG-SubRepeat-maybe-somesep: PG-SubRepeat[%HxRepeat⟪ ? ⟫, %HxRepeat⟪ + _ #RegExpLeaf2# ⟫] → B_FALSE;
    
    PG-SubRepeat-some-single: PG-SubRepeat[%HxRepeat⟪ + ⟫, %HxRepeat⟪ ⟫] → B_FALSE;
    PG-SubRepeat-some-maybe: PG-SubRepeat[%HxRepeat⟪ + ⟫, %HxRepeat⟪ ? ⟫] → B_FALSE;
    PG-SubRepeat-some-many: PG-SubRepeat[%HxRepeat⟪ + ⟫, %HxRepeat⟪ * ⟫] → B_TRUE;
    PG-SubRepeat-some-some: PG-SubRepeat[%HxRepeat⟪ + ⟫, %HxRepeat⟪ + ⟫] → B_TRUE;
    PG-SubRepeat-some-somesep: PG-SubRepeat[%HxRepeat⟪ + ⟫, %HxRepeat⟪ + _ #RegExpLeaf2# ⟫] → B_FALSE;
    
    PG-SubRepeat-many-many: PG-SubRepeat[%HxRepeat⟪ * ⟫, %HxRepeat⟪ * ⟫] → B_TRUE ;
    PG-SubRepeat-many-other[Data[#_]]: PG-SubRepeat[%HxRepeat⟪ * ⟫, $[NotMatch,%HxRepeat⟪ * ⟫,#_]] → B_FALSE;
    
    PG-SubRepeat-somesep-single: PG-SubRepeat[%HxRepeat⟪ + _ #RegExpLeaf1# ⟫, %HxRepeat⟪ ⟫] → B_FALSE;
    PG-SubRepeat-somesep-maybe: PG-SubRepeat[%HxRepeat⟪ + _ #RegExpLeaf1# ⟫, %HxRepeat⟪ ? ⟫] → B_FALSE;
    PG-SubRepeat-somesep-many: PG-SubRepeat[%HxRepeat⟪ + _ #RegExpLeaf1# ⟫, %HxRepeat⟪ * ⟫] → B_FALSE;
    PG-SubRepeat-somesep-some: PG-SubRepeat[%HxRepeat⟪ + _ #RegExpLeaf1# ⟫, %HxRepeat⟪ + ⟫] → B_FALSE;
    
    PG-SubRepeat-somesep-string-string: PG-SubRepeat[%HxRepeat⟪ + _ #String1# ⟫, %HxRepeat⟪ + _ #String2# ⟫] → SameString[UnString[#String1#], UnString[#String2#]] ;
    PG-SubRepeat-somesep-string-word: PG-SubRepeat[%HxRepeat⟪ + _ #String1# ⟫, %HxRepeat⟪ + _ #Word2# ⟫] → SameString[UnString[#String1#], #Word2#] ;
    PG-SubRepeat-somesep-word-string: PG-SubRepeat[%HxRepeat⟪ + _ #Word1# ⟫, %HxRepeat⟪ + _ #String2# ⟫] → SameString[#Word1#, UnString[#String2#]] ;
    PG-SubRepeat-somesep-word-word: PG-SubRepeat[%HxRepeat⟪ + _ #Word1# ⟫, %HxRepeat⟪ + _ #Word2# ⟫] → SameString[#Word1#, #Word2#] ;







{#DM} PG-ProduceBodyTerm1[#ModuleName, #SortName, (PFK[Hx_M_ParsedFormSpace[#space1, #ParsedForm1], #Kind1]; #Rest), #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyTerm1[#ModuleName, #SortName, (PFK[#ParsedForm1, #Kind1]; #Rest), #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{#DM} PG-ProduceBodyTerm1[#ModuleName, #SortName, (PFK[Hx_M_ParsedFormDone, #Kind1]; #Rest), #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyTerm1[#ModuleName, #SortName, #Rest, Append[#Failed, (PFK[Hx_M_ParsedFormDone, #Kind1];)], #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{#DM} PG-ProduceBodyTerm1[#ModuleName, #SortName, (), #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyTerm2[#ModuleName, #SortName, #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

// ... helper to filter identical scope sorts...

{$String : DeclarationMapEntry}
PG-ProduceBodyTerm1x[$String<!--ModuleName-->, $String<!--HostSort-->, Boolean, HxScopeSort, $Numeric, HxRepeat, HxParsedForm, FormKind,
	$List[PFK_SORT], $List[PFK_SORT], HxScopeSort, $Numeric, HxRepeat, FormKind, $List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

{#DM} PG-ProduceBodyTerm1x[#ModuleName, #SortName, B_FALSE, #ScopeSort1, #Prec1, #Repeat1, #ParsedForm1, #Kind1, #Rest, #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyTerm1[#ModuleName, #SortName, #Rest, Append[#Failed, (PFK[Hx_M_ParsedFormTerm[Hx_M_ScopeSortPrecRepeat[#ScopeSort1, #Prec1, #Repeat1], #ParsedForm1], #Kind1];)], #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{#DM} PG-ProduceBodyTerm1x[#ModuleName, #SortName, B_TRUE, #ScopeSort1, #Prec1, #Repeat1, #ParsedForm1, #Kind1, #Rest, #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyTerm1[#ModuleName, #SortName, #Rest, #Failed, #ScopeSort, #Prec, #Repeat, #Kind, Append[#nonterminalPFKs, (PFK[#ParsedForm1, #Kind1];)], #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

// ... (b) emit branch (with recursive nesting of tail).

{$String : DeclarationMapEntry} PG-ProduceBodyTerm2[$String<!--ModuleName-->, $String<!--HostSort-->, $List[PFK_SORT], HxScopeSort, $Numeric, HxRepeat, FormKind, $List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

{#DM} PG-ProduceBodyTerm2[#ModuleName, #SortName, (), #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyTerm3[#ModuleName, #SortName, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{#DM} PG-ProduceBodyTerm2[#ModuleName, #SortName, (#PFK1;#PFKs), #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyTerm3[#ModuleName, #SortName, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in1 funs1 tags1 after1 .
  {#DM} PG-ProduceBody[#ModuleName, #SortName, (#PFK1;#PFKs), #n, #terms, #words, #consumer, in2 funs2 tags2 after2 .
    #[%n⟪(« in1 »
| « in2 »)⟫, %n⟪«funs1»«funs2»⟫, %n⟪«tags1»«tags2»⟫, JoinTextMaps[after1, after2]]]]
;

{$String : DeclarationMapEntry} PG-ProduceBodyTerm3[$String<!--ModuleName-->, $String<!--HostSort-->, HxScopeSort, $Numeric, HxRepeat, FormKind, $List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

-[Free[v::Text]]:
{#DM} PG-ProduceBodyTerm3[#ModuleName, #SortName, %HxScopeSort⟪ [ v : #Sort# ] ⟫, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
IfSingletonRepeat[#Repeat,
  {#DM} PG-ProduceBody[#ModuleName, #SortName, #nonterminalPFKs, #n, #terms,  Append[#words, (%n⟨†‹SortVar[#Sort#]›⟩;)], #consumer, in funs tags after .
    #[%n⟪⟦ <«PG-ProductionNameWithPrecText[{#DM}PG-SymbolSortTokenName[PG-SortName[#Sort#]], #Prec]»>^«v» ⟦« in »⟧ ⟧⟫, funs, tags, after]],
  CookError["Cannot use repeat specification on binder"]]
;

    SortVar[HxSort] :: $String;
    -[Data[#Sort]]: SortVar[#Sort] → SortVar2[#Sort] ;
    SortVar2[HxSort] :: $String;
    -[Data[#SortName]]: SortVar2[           %HxSort⟪ #SortName# #MetaVariables# #SimpleSorts# ⟫] → SortVar3[#SortName#, #MetaVariables#] ;
                        SortVar2[$[NotMatch,%HxSort⟪ #SortName# #MetaVariables# #SimpleSorts# ⟫,#]] →  "bad" ;
    SortVar3[$String, $List[$String]] :: $String;
    SortVar3[#SortName, ()] → $[:,"v",#SortName] ;
    SortVar3[#SortName, (#MetaVar;)] → $[:,"v",#SortName,$[Replace,#MetaVar,"#",""]] ;

{#DM} PG-ProduceBodyTerm3[#ModuleName, #SortName, %HxScopeSort⟪ #Sort# #Repeat# [ #SubstituteSorts# ] ⟫, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyTerm4[#ModuleName, #SortName, #Sort#, #SubstituteSorts#, PG-ProductionNameWithPrecRepeatText[PG-SortName[#Sort#], #Prec, NestedRepeat[#Repeat#, #Repeat]], #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{$String : DeclarationMapEntry} PG-ProduceBodyTerm4[$String<!--ModuleName-->, $String<!--HostSort-->, HxSort, $List[HxSubstituteSort], Text, $Numeric, HxRepeat, FormKind, $List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

-[Data[#consumer]]:
{#DM} PG-ProduceBodyTerm4[#ModuleName, #SortName, #Sort#, #SubstituteSorts#, #ProductionName, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, <!--$[NotMatch,C_INLINE,-->#consumer<!--]-->, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBody[#ModuleName, #SortName, #nonterminalPFKs, $[Plus,#n,1],
  Append[#terms, (%n⟨†‹ PG-SortMetaVar[#Sort#, #n] ›⟩;)],
  Append[#words, (%n⟨†‹ PG-SortName[#Sort#] ›⟩;)],
  #consumer,
  in funs tags after .
    #[%n⟪⟦( « PG-VariablePrefix[#Kind, #ModuleName, #SortName, #ProductionName] » <« #ProductionName »>«
	WrappedTextJoin[Map[s.PG-ExtractSubstitutedSort[s], #SubstituteSorts#], %n⟨[⟩, %n⟨,⟩, %n⟨]⟩] »«
	PG-VariableMarker[#Kind, %n⟨:†‹ PG-SortMetaVar[#Sort#, #n] ›⟩] » ⟦« in »⟧ )
      ⟧⟫, funs, tags, after]]
;

    PG-SortMetaVar[HxSort, $Numeric] :: $String;
    -[Data[#Sort]]: PG-SortMetaVar[#Sort, #n] → PG-SortMetaVar2[#Sort, #n] ;
    PG-SortMetaVar2[HxSort, $Numeric] :: $String;
    PG-SortMetaVar2[           %HxSort⟪ #SortName# #MetaVariable# #SimpleSorts# ⟫,    #n] → #MetaVariable# ;
    PG-SortMetaVar2[           %HxSort⟪ #SortName#                #SimpleSorts# ⟫,    #n] → $[:,"#_",#SortName#,"_",$[FormatNumber,#n]] ;
    PG-SortMetaVar2[$[NotMatch,%HxSort⟪ #SortName# #MetaVariables# #SimpleSorts# ⟫,#], #n] →  "#bad" ;
    
    // TODO: Eliminate redundant repeat productions!

    PG-ExtractSubstitutedSort[HxSubstituteSort] :: Text;
    -[Free[v1::Text]]:
    PG-ExtractSubstitutedSort[%HxSubstituteSort⟪ v1 : #Sort2# ⟫] → %n⟪«v1»⟫ ;

    PG-VariablePrefix[FormKind, $String<!--ModuleName-->, $String<!--SortName-->, Text<!--Other-->] :: Text;
    -[Data[#Kind,#ModuleName,#SortName]]: PG-VariablePrefix[#Kind, #ModuleName, #SortName, #Other] → PG-VariablePrefix2[#Kind, #ModuleName, #SortName, #Other] ;

    PG-VariablePrefix2[FormKind, $String<!--ModuleName-->, $String<!--SortName-->, Text<!--Other-->] :: Text;
    PG-VariablePrefix2[FK_SYMBOL[#free, #t], #ModuleName, #SortName, #Other] → %n⟪/***METAPG:{†« PG-QN[#ModuleName,"Var", #SortName] »_«#Other»}***/⟫ ;
    PG-VariablePrefix2[$[NotMatch,FK_SYMBOL[#IsStatic,#t],#Kind], #ModuleName, #SortName, #Other] → %n⟪⟫ ;

    PG-VariableMarker[FormKind, Text] :: Text;
    -[Data[#Kind]]: PG-VariableMarker[#Kind, #Other] → PG-VariableMarker2[#Kind, #Other] ;

    PG-VariableMarker2[FormKind, Text] :: Text;
    PG-VariableMarker2[FK_SYMBOL[$False,#t], #Other] → %n⟪!!!« #Other »⟫ ;
    PG-VariableMarker2[FK_SYMBOL[$True,#t], #Other] → %n⟪!!« #Other »⟫ ;
    PG-VariableMarker2[$[NotMatch,FK_SYMBOL[#IsStatic,#t],#Kind], #Other] → #Other ;


// REPEATS.

∀ a . IfSingletonRepeat[HxRepeat, a, a] :: a;
IfSingletonRepeat[%HxRepeat⟪ ⟫, #1, #2] → #1 ;
IfSingletonRepeat[%HxRepeat⟪ ? ⟫, #1, #2] → #2 ;
IfSingletonRepeat[%HxRepeat⟪ * ⟫, #1, #2] → #2 ;
IfSingletonRepeat[%HxRepeat⟪ + ⟫, #1, #2] → #2 ;
IfSingletonRepeat[%HxRepeat⟪ + _ #RegExpLeaf# ⟫, #1, #2] → #2 ;

NestedRepeat[HxRepeat, HxRepeat] :: HxRepeat;
NestedRepeat-single-single:   NestedRepeat[%HxRepeat⟪ ⟫, %HxRepeat⟪ ⟫]                                     → %HxRepeat⟪ ⟫ ;
NestedRepeat-single-maybe :   NestedRepeat[%HxRepeat⟪ ⟫, %HxRepeat⟪ ? ⟫]                                   → %HxRepeat⟪ ? ⟫ ;
NestedRepeat-single-many:     NestedRepeat[%HxRepeat⟪ ⟫, %HxRepeat⟪ * ⟫]                                   → %HxRepeat⟪ * ⟫ ;
NestedRepeat-single-some:     NestedRepeat[%HxRepeat⟪ ⟫, %HxRepeat⟪ + ⟫]                                   → %HxRepeat⟪ + ⟫ ;
NestedRepeat-single-somesep:  NestedRepeat[%HxRepeat⟪ ⟫, %HxRepeat⟪ + _ #RegExpLeaf2# ⟫]                   → %HxRepeat⟪ + _ #RegExpLeaf2# ⟫ ;
NestedRepeat-maybe-single:    NestedRepeat[%HxRepeat⟪ ? ⟫, %HxRepeat⟪ ⟫]                                   → %HxRepeat⟪ ? ⟫ ;
NestedRepeat-maybe-maybe :    NestedRepeat[%HxRepeat⟪ ? ⟫, %HxRepeat⟪ ? ⟫]                                 → %HxRepeat⟪ ? ⟫ ;
NestedRepeat-maybe-many:      NestedRepeat[%HxRepeat⟪ ? ⟫, %HxRepeat⟪ * ⟫]                                 → %HxRepeat⟪ * ⟫ ;
NestedRepeat-maybe-some:      NestedRepeat[%HxRepeat⟪ ? ⟫, %HxRepeat⟪ + ⟫]                                 → %HxRepeat⟪ * ⟫ ;
NestedRepeat-maybe-somesep:   NestedRepeat[%HxRepeat⟪ ? ⟫, %HxRepeat⟪ + _ #RegExpLeaf2# ⟫]                 → $[Error,"Cannot nest ? in +_'...' repeater."] ;
NestedRepeat-many-single:     NestedRepeat[%HxRepeat⟪ * ⟫, %HxRepeat⟪ ⟫]                                   → %HxRepeat⟪ * ⟫ ;
NestedRepeat-many-maybe :     NestedRepeat[%HxRepeat⟪ * ⟫, %HxRepeat⟪ ? ⟫]                                 → %HxRepeat⟪ * ⟫ ;
NestedRepeat-many-many:       NestedRepeat[%HxRepeat⟪ * ⟫, %HxRepeat⟪ * ⟫]                                 → %HxRepeat⟪ * ⟫ ;
NestedRepeat-many-some:       NestedRepeat[%HxRepeat⟪ * ⟫, %HxRepeat⟪ + ⟫]                                 → %HxRepeat⟪ * ⟫ ;
NestedRepeat-many-somesep:    NestedRepeat[%HxRepeat⟪ * ⟫, %HxRepeat⟪ + _ #RegExpLeaf2# ⟫]                 → $[Error,"Cannot nest * in +_'...' repeater."] ;
NestedRepeat-some-single:     NestedRepeat[%HxRepeat⟪ + ⟫, %HxRepeat⟪ ⟫]                                   → %HxRepeat⟪ + ⟫ ;
NestedRepeat-some-maybe :     NestedRepeat[%HxRepeat⟪ + ⟫, %HxRepeat⟪ ? ⟫]                                 → %HxRepeat⟪ * ⟫ ;
NestedRepeat-some-many:       NestedRepeat[%HxRepeat⟪ + ⟫, %HxRepeat⟪ * ⟫]                                 → %HxRepeat⟪ * ⟫ ;
NestedRepeat-some-some:       NestedRepeat[%HxRepeat⟪ + ⟫, %HxRepeat⟪ + ⟫]                                 → %HxRepeat⟪ + ⟫ ;
NestedRepeat-some-somesep:    NestedRepeat[%HxRepeat⟪ + ⟫, %HxRepeat⟪ + _ #RegExpLeaf2# ⟫]                 → %HxRepeat⟪ + _ #RegExpLeaf2# ⟫ ;
NestedRepeat-somesep-single:  NestedRepeat[%HxRepeat⟪ + _ #RegExpLeaf1# ⟫, %HxRepeat⟪ ⟫]                   → %HxRepeat⟪ + _ #RegExpLeaf1# ⟫ ;
NestedRepeat-somesep-maybe :  NestedRepeat[%HxRepeat⟪ + _ #RegExpLeaf1# ⟫, %HxRepeat⟪ ? ⟫]                 → $[Error,"Cannot nest +_'...' in ? repeater."] ;
NestedRepeat-somesep-many:    NestedRepeat[%HxRepeat⟪ + _ #RegExpLeaf1# ⟫, %HxRepeat⟪ * ⟫]                 → $[Error,"Cannot nest +_'...' in * repeater."] ;
NestedRepeat-somesep-some:    NestedRepeat[%HxRepeat⟪ + _ #RegExpLeaf1# ⟫, %HxRepeat⟪ + ⟫]                 → $[Error,"Cannot nest +_'...' in + repeater."] ;
NestedRepeat-somesep-somesep: NestedRepeat[%HxRepeat⟪ + _ #RegExpLeaf1# ⟫, %HxRepeat⟪ + _ #RegExpLeaf2# ⟫] → $[Error,"Cannot nest +_'...' in another +_'...' repeater."] ;








/////////////////////////////////////////////////////////////////////
// 33. TEXT OF LEXICAL DECLARATIONS.

// a.

// Instantiate CPS processing.
PG-Lexical[$List[HxDeclaration], $String<!--ModuleName-->] :: Text ;
PG-Lexical[#Declarations, #ModuleName] → PG-Lexical2[#Declarations, #ModuleName, B_FALSE, hasskip.PG-Lexical2Tail[hasskip]] ;

// Generate PG token instructions per HACS declaration.

PG-Lexical2[$List[HxDeclaration], $String, Boolean, ha::Boolean.Text] :: Text ;

Lexical-module:
PG-Lexical2[%HxDeclarations⟪ module #ModuleName2# { #Declarations2# } ; #Declarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
PG-Lexical2[#Declarations2#, #ModuleName2#, #hasSkip, hasskip.PG-Lexical2[#Declarations#, #ModuleName, hasskip, hasskip2.#[hasskip2]]]
;

Lexical-space:
PG-Lexical2[%HxDeclarations⟪ space #RegExp# ; #Declarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
%n⟪skip ::= ' ' | ⟦« PG-InlineRegExp[#RegExp#, #ModuleName, "space$"] »⟧ .
« PG-DeclareRegExp[#RegExp#, #ModuleName, "space$"] »« PG-Lexical2[#Declarations#, #ModuleName, B_TRUE, hasskip.#[hasskip]] »⟫
;

Lexical-token:
PG-Lexical2[%HxDeclarations⟪ token #SortName# | #RegExp# ; #Declarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
%n⟪token «PG-TokenNameText[#SortName#]»/***METAPG: (DEFAULT,Hx)***/ ::= ⟦« PG-InlineRegExp[#RegExp#, #ModuleName, #SortName#] »⟧ .
« PG-DeclareRegExp[#RegExp#, #ModuleName, #SortName#] »« PG-Lexical2[#Declarations#, #ModuleName, #hasSkip, hasskip.#[hasskip]] »⟫
;

Lexical-fragment:
PG-Lexical2[%HxDeclarations⟪ fragment #FragmentName# | #RegExp# ; #Declarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
%n⟪token fragment «PG-TokenNameText[#FragmentName#]» ::= ⟦« PG-InlineRegExp[#RegExp#, #ModuleName, #FragmentName#] »⟧ . 
« PG-DeclareRegExp[#RegExp#, #ModuleName, #FragmentName#] »« PG-Lexical2[#Declarations#, #ModuleName, #hasSkip, hasskip.#[hasskip]] »⟫
;

Lexical-attribute:
PG-Lexical2[%HxDeclarations⟪ attribute #AttributeKind# #AttributeName# #AttributeForm# #AttributeOptions# ; #Declarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
PG-Lexical2[#Declarations#, #ModuleName, #hasSkip, hasskip.#[hasskip]]
;

Lexical-sort:
PG-Lexical2[%HxDeclarations⟪ sort #SortName# #Repeat# #SortAbstraction# ; #Declarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
PG-Lexical2[#Declarations#, #ModuleName, #hasSkip, hasskip.#[hasskip]]
;

Lexical-main-sort:
PG-Lexical2[%HxDeclarations⟪ main sort #SortName# #Repeat# #SortAbstraction# ; #Declarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
PG-Lexical2[#Declarations#, #ModuleName, #hasSkip, hasskip.#[hasskip]]
;

Lexical-alternatives:
PG-Lexical2[%HxDeclarations⟪ #SortAlternatives# ; #Declarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
PG-Lexical2[#Declarations#, #ModuleName, #hasSkip, hasskip.#[hasskip]]
;

Lexical-rule:
PG-Lexical2[%HxDeclarations⟪ rule #Rule# ; #Declarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
PG-Lexical2[#Declarations#, #ModuleName, #hasSkip, hasskip.#[hasskip]]
;

Lexical-nest:
PG-Lexical2[%HxDeclarations⟪ { #Declarations2# } #Declarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
PG-Lexical2[#Declarations2#, #ModuleName, #hasSkip, hasskip.PG-Lexical2[#Declarations#, #ModuleName, hasskip, hasskip2.#[hasskip2]]]
;

Lexical-done:
PG-Lexical2[%HxDeclarations⟪ ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
#[#hasSkip]
;

// The final continuation.
PG-Lexical2Tail[Boolean] :: Text;
PG-Lexical2Tail[B_TRUE] → %n⟪⟫ ;
PG-Lexical2Tail[B_FALSE] → %n⟪skip ::= " " .
⟫ ;

// b. Inline Text of Regular Expression.

//

PG-InlineRegExp[$List[HxRegExpChoice], $String<!--ModuleName-->, $String<!--identifier-->] :: Text ;
PG-InlineRegExp[(#RegExpChoice; #RegExp), #ModuleName, #id]
→
%n⟪⟦« PG-InlineRegExpChoice[#RegExpChoice, #ModuleName, #id] »⟧ « PG-InlineRegExp2[#RegExp, #ModuleName, #id] »⟫
;

PG-InlineRegExp2[$List[HxRegExpChoice], $String<!--ModuleName-->, $String<!--identifier-->] :: Text ;
PG-InlineRegExp2[(#RegExpChoice; #RegExp), #ModuleName, #id]
→
%n⟪| ⟦« PG-InlineRegExpChoice[#RegExpChoice, #ModuleName, #id] »⟧ « PG-InlineRegExp2[#RegExp, #ModuleName, #id] »⟫
;
PG-InlineRegExp2[(), #ModuleName, #id]
→
%n⟪⟫
;

//

PG-InlineRegExpChoice[HxRegExpChoice, $String<!--ModuleName-->, $String] :: Text;

PG-InlineRegExpChoice[%HxRegExpChoice⟪ nested #RegExpSimple1# #RegExpSimple2# ⟫, #ModuleName, #id]
→
%n⟪NESTED_«PG-TokenNameText[#id]»⟫
;
PG-InlineRegExpChoice[%HxRegExpChoice⟪ #RegExpUnits# ⟫, #ModuleName, #id]
→
PG-InlineRegExpUnits[#RegExpUnits#, #ModuleName, #id]
;

//

PG-InlineRegExpUnits[$List[HxRegExpUnit], $String<!--ModuleName-->, $String] :: Text;

PG-InlineRegExpUnits[%HxRegExpUnits⟪ #RegExpUnit# #RegExpUnits# ⟫, #ModuleName, #id]
→
%n⟪« PG-InlineRegExpUnit[#RegExpUnit#, #ModuleName, #id] » « PG-InlineRegExpUnits[#RegExpUnits#, #ModuleName, #id] »⟫
;
PG-InlineRegExpUnits[%HxRegExpUnits⟪ ⟫, #ModuleName, #id]
→
%n⟪⟫
;

//

PG-InlineRegExpUnit[HxRegExpUnit, $String<!--ModuleName-->, $String] :: Text;

PG-InlineRegExpUnit[%HxRegExpUnit⟪ #RegExpSimple# ⟫, #ModuleName, #id]
→
PG-InlineRegExpSimple[#RegExpSimple#, #ModuleName, #id]
;

PG-InlineRegExpUnit[%HxRegExpUnit⟪ #RegExpSimple# ? ⟫, #ModuleName, #id]
→
%n⟪( « PG-InlineRegExpSimple[#RegExpSimple#, #ModuleName, #id] » )?⟫
;

PG-InlineRegExpUnit[%HxRegExpUnit⟪ #RegExpSimple# * ⟫, #ModuleName, #id]
→
%n⟪( « PG-InlineRegExpSimple[#RegExpSimple#, #ModuleName, #id] » )*⟫
;

PG-InlineRegExpUnit[%HxRegExpUnit⟪ #RegExpSimple# + ⟫, #ModuleName, #id]
→
%n⟪( « PG-InlineRegExpSimple[#RegExpSimple#, #ModuleName, #id] » )+⟫
;

PG-InlineRegExpUnit[%HxRegExpUnit⟪ #RegExpSimple# + _ #RegExpLeaf# ⟫, #ModuleName, #id]
→
%n⟪( « PG-InlineRegExpSimple[#RegExpSimple#, #ModuleName, #id] » ( « PG-InlineRegExpSimple[#RegExpLeaf#, #ModuleName, #id] » « PG-InlineRegExpSimple[#RegExpSimple#, #ModuleName, #id] » )* )⟫
;

//

PG-InlineRegExpSimple[HxRegExpSimple, $String<!--ModuleName-->, $String] :: Text;

PG-InlineRegExpSimple[%HxRegExpSimple⟪ #String# ⟫, #ModuleName, #id]
→
%n⟪†«#String#»⟫ // TODO: manually decode HACS and recode PG escapes (or at least check)!
;

PG-InlineRegExpSimple[%HxRegExpSimple⟪ #Word# ⟫, #ModuleName, #id]
→
%n⟪†« Stringify[#Word#] »⟫
;

PG-InlineRegExpSimple[%HxRegExpSimple⟪ #FragmentRef# ⟫, #ModuleName, #id]
→
%n⟪«PG-TokenNameText[#FragmentRef#]»⟫
;

PG-InlineRegExpSimple[%HxRegExpSimple⟪ . ⟫, #ModuleName, #id]
→
PG-InlineRegExpSimple[%HxRegExpSimple⟪ [^\n\r\f] ⟫, #ModuleName, #id]
;

PG-InlineRegExpSimple[%HxRegExpSimple⟪ #RegExpClass# ⟫, #ModuleName, #id]
→
PG-InlineRegExpClass1[#RegExpClass#, #ModuleName, #id]
;

PG-InlineRegExpSimple[%HxRegExpSimple⟪ ( #RegExp# ) ⟫, #ModuleName, #id]
→
%n⟪( « PG-InlineRegExp[#RegExp#, #ModuleName, #id] » )⟫
;

//

PG-InlineRegExpClass1[HxRegExpClass, $String<!--ModuleName-->, $String] :: Text;

PG-InlineRegExpClass1[Hx_M_RegExpClassNot[#RegExpClass], #ModuleName, #id]
→
%n⟪~[« PG-InlineRegExpClass2[#RegExpClass, #ModuleName, #id, %n⟨⟩] »]⟫
;

PG-InlineRegExpClass1[$[NotMatch,Hx_M_RegExpClassNot[#_],#RegExpClass], #ModuleName, #id]
→
%n⟪[« PG-InlineRegExpClass2[#RegExpClass, #ModuleName, #id, %n⟨⟩] »]⟫
;

PG-InlineRegExpClass2[HxRegExpClass, $String<!--ModuleName-->, $String, Text] :: Text;

PG-InlineRegExpClass2[Hx_M_RegExpClassChar[#Char, #RegExpClass], #ModuleName, #id, #sep]
→
%n⟪«#sep»« PG-InlineRegExpRangeChar[#Char, #ModuleName, #id] »« PG-InlineRegExpClass2[#RegExpClass, #ModuleName, #id, %n⟨,⟩] »⟫
;

PG-InlineRegExpClass2[Hx_M_RegExpClassRange[#lo, #hi, #RegExpClass], #ModuleName, #id, #sep]
→
%n⟪«#sep»« PG-InlineRegExpRangeChar[#lo, #ModuleName, #id] »-« PG-InlineRegExpRangeChar[#hi, #ModuleName, #id] »« PG-InlineRegExpClass2[#RegExpClass, #ModuleName, #id, %n⟨,⟩] »⟫
;

PG-InlineRegExpClass2[Hx_M_RegExpClassDone, #ModuleName, #id, #sep]
→
%n⟪⟫
;
PG-InlineRegExpRangeChar[$String, $String<!--ModuleName-->, $String] :: Text;
-[Data[#RegExpRangeStartChar#]]:
PG-InlineRegExpRangeChar[#RegExpRangeStartChar#, #ModuleName, #id]
→
$[If, $[Equal,#RegExpRangeStartChar#,"'"], %n⟪"'"⟫, %n⟪'†« #RegExpRangeStartChar# »'⟫]
;

// 

PG-DeclareRegExp[$List[HxRegExpChoice], $String<!--ModuleName-->, $String<!--identifier-->] :: Text ;
PG-DeclareRegExp[(#RegExpChoice; #RegExp), #ModuleName, #id]
→
%n⟪« PG-DeclareRegExpChoice[#RegExpChoice, #ModuleName, #id] »« PG-DeclareRegExp[#RegExp, #ModuleName, #id] »⟫
;
PG-DeclareRegExp[(), #ModuleName, #id]
→
%n⟪⟫
;

PG-DeclareRegExpChoice[HxRegExpChoice, $String<!--ModuleName-->, $String] :: Text;
PG-DeclareRegExpChoice[%HxRegExpChoice⟪ nested #RegExpSimple1# #RegExpSimple2# ⟫, #ModuleName, #id]
→
%n⟪
%{
/* token †«#id». */
MORE : { < « PG-InlineRegExpSimple[#RegExpSimple1#, #ModuleName, #id] » > { nesting = 0; nestedState = curLexState; } : IN_«PG-TokenNameText[#id]» }
<IN_«PG-TokenNameText[#id]»> MORE : { < « PG-InlineRegExpSimple[#RegExpSimple1#, #ModuleName, #id] » > { nesting = 1; } : IN_NESTED_«PG-TokenNameText[#id]» }
<IN_NESTED_«PG-TokenNameText[#id]»> MORE : { < « PG-InlineRegExpSimple[#RegExpSimple1#, #ModuleName, #id] » > { nesting++; } }
<IN_NESTED_«PG-TokenNameText[#id]»> MORE : { < « PG-InlineRegExpSimple[#RegExpSimple2#, #ModuleName, #id] » > { if (--nesting <= 0) SwitchTo(IN_«PG-TokenNameText[#id]»); } }
<IN_«PG-TokenNameText[#id]»> †« $[If,$[Equal,#id,"space$"],"SKIP","TOKEN"] » : { < T_NESTED_«PG-TokenNameText[#id]» : « PG-InlineRegExpSimple[#RegExpSimple2#, #ModuleName, #id] » > { SwitchTo(nestedState); } }
<IN_«PG-TokenNameText[#id]»,IN_NESTED_«PG-TokenNameText[#id]»> MORE : { < ~[] > }
%}
⟫
;
PG-DeclareRegExpChoice[%HxRegExpChoice⟪ #RegExpUnits# ⟫, #ModuleName, #id]
→
PG-DeclareRegExpUnits[#RegExpUnits#, #ModuleName, #id]
;

PG-DeclareRegExpUnits[$List[HxRegExpUnit], $String<!--ModuleName-->, $String] :: Text;
PG-DeclareRegExpUnits[%HxRegExpUnits⟪ #RegExpUnit# #RegExpUnits# ⟫, #ModuleName, #id]
→
%n⟪« PG-DeclareRegExpUnit[#RegExpUnit#, #ModuleName, #id] »« PG-DeclareRegExpUnits[#RegExpUnits#, #ModuleName, #id] »⟫
;
PG-DeclareRegExpUnits[%HxRegExpUnits⟪ ⟫, #ModuleName, #id]
→
%n⟪⟫
;

PG-DeclareRegExpUnit[HxRegExpUnit, $String<!--ModuleName-->, $String] :: Text;
PG-DeclareRegExpUnit[%HxRegExpUnit⟪ #RegExpSimple# ⟫, #ModuleName, #id] → PG-DeclareRegExpSimple[#RegExpSimple#, #ModuleName, #id] ;
PG-DeclareRegExpUnit[%HxRegExpUnit⟪ #RegExpSimple# ? ⟫, #ModuleName, #id] → PG-DeclareRegExpSimple[#RegExpSimple#, #ModuleName, #id] ;
PG-DeclareRegExpUnit[%HxRegExpUnit⟪ #RegExpSimple# * ⟫, #ModuleName, #id] → PG-DeclareRegExpSimple[#RegExpSimple#, #ModuleName, #id] ;
PG-DeclareRegExpUnit[%HxRegExpUnit⟪ #RegExpSimple# + ⟫, #ModuleName, #id] → PG-DeclareRegExpSimple[#RegExpSimple#, #ModuleName, #id] ;
PG-DeclareRegExpUnit[%HxRegExpUnit⟪ #RegExpSimple# + _ #RegExpLeaf# ⟫, #ModuleName, #id] → %n⟪« PG-DeclareRegExpSimple[#RegExpSimple#, #ModuleName, #id] »« PG-DeclareRegExpSimple[#RegExpLeaf#, #ModuleName, #id] »⟫ ;

PG-DeclareRegExpSimple[HxRegExpSimple, $String<!--ModuleName-->, $String] :: Text;
PG-DeclareRegExpSimple[%HxRegExpSimple⟪ #String# ⟫, #ModuleName, #id] → %n⟪⟫ ;
PG-DeclareRegExpSimple[%HxRegExpSimple⟪ #Word# ⟫, #ModuleName, #id] → %n⟪⟫ ;
PG-DeclareRegExpSimple[%HxRegExpSimple⟪ #FragmentRef# ⟫, #ModuleName, #id] → %n⟪⟫ ;
PG-DeclareRegExpSimple[%HxRegExpSimple⟪ . ⟫, #ModuleName, #id] → %n⟪⟫ ;
PG-DeclareRegExpSimple[%HxRegExpSimple⟪ #RegExpClass# ⟫, #ModuleName, #id] → %n⟪⟫ ;
PG-DeclareRegExpSimple[%HxRegExpSimple⟪ ( #RegExp# ) ⟫, #ModuleName, #id] → PG-DeclareRegExp[#RegExp#, #ModuleName, #id] ;





/////////////////////////////////////////////////////////////////////
// 37. PG TEXT NAMING CONVENTIONS.

// PG token name and constructor.

PG-TokenNameText[$String] :: Text;
-[Data[#Name]]: PG-TokenNameText[#Name] → %n⟪†«#Name»⟫ ; ///%n⟪T†« $[Mangle,$[Trim,#Name]] »⟫ ;

PG-TokenConstructorText[$String<!--ModuleName-->, $String] :: Text;
PG-TokenConstructorText[#ModuleName, #Name] → %n⟪†« PG-QN[#ModuleName, "Token", #Name] »⟫ ;

// PG production (= non-terminal = sort) name and constructor.

PG-ProductionNameText[$String] :: Text;
-[Data[#Name]]: PG-ProductionNameText[#Name] → %n⟪†« #Name »⟫ ;

// PG special production name for non-terminals with precedence.

PG-ProductionNameWithPrecText[$String, $Numeric] :: Text;
-[Data[#Name,#Prec],Copy[#Name,#Prec]]: PG-ProductionNameWithPrecText[#Name, #Prec] → PG-ProductionNameText[$[If, $[NumericEqual,#Prec,0], #Name, $[:,#Name,$[FormatNumber,#Prec]]]] ;

PG-ProductionNameWithPrec[$String, $Numeric] :: $String;
-[Data[#Name,#Prec],Copy[#Name,#Prec]]: PG-ProductionNameWithPrec[#Name, #Prec] → $[If, $[NumericEqual,#Prec,0], #Name, $[:,#Name,$[FormatNumber,#Prec]]] ;

// PG special production name for non-terminals with precedence and repeat...

PG-ProductionNameWithPrecRepeatText[$String, $Numeric, HxRepeat] :: Text;
PG-ProductionNameWithPrecRepeatText[#Name, #Prec, %HxRepeat⟪ ⟫] → PG-ProductionNameWithPrecText[#Name, #Prec] ;
PG-ProductionNameWithPrecRepeatText[#Name, #Prec, %HxRepeat⟪ ? ⟫]→ %n⟪« PG-ProductionNameWithPrecText[#Name, #Prec] »_Maybe⟫ ;
PG-ProductionNameWithPrecRepeatText[#Name, #Prec, %HxRepeat⟪ * ⟫]→ %n⟪« PG-ProductionNameWithPrecText[#Name, #Prec] »_MaybeSome⟫ ;
-[Data[#RegExpSimple#]]:
PG-ProductionNameWithPrecRepeatText[#Name, #Prec, %HxRepeat⟪ + ⟫]→ %n⟪« PG-ProductionNameWithPrecText[#Name, #Prec] »_Some⟫ ;
-[Data[#RegExpLeaf#]]:
PG-ProductionNameWithPrecRepeatText[#Name, #Prec, %HxRepeat⟪ + _ #RegExpLeaf# ⟫]→ %n⟪« PG-ProductionNameWithPrecText[#Name, #Prec] »« PG-RegExpLeafNameText["", #RegExpLeaf#] »⟫ ;

    // Convert regular expression to name fragment...
    PG-RegExpLeafNameText[$String, HxRegExpSimple] :: Text;
    -[Data[#Name,#String#]]:      PG-RegExpLeafNameText[#Name, %HxRegExpLeaf⟪ #String# ⟫] → %n⟪†«#Name»_SomeS†« $[Mangle,#String#] »⟫ ;
    -[Data[#Name,#Word#]]:        PG-RegExpLeafNameText[#Name, %HxRegExpLeaf⟪ #Word# ⟫] → %n⟪†«#Name»_SomeW†« $[Mangle,#Word#] »⟫ ;


/////////////////////////////////////////////////////////////////////
// X. HELPERS.

// Convert hx module name string to Java style class name.

PG-ClassName[$String] :: $String;
-[Data[#Name]]: PG-ClassName[#Name] → $[:,$[Replace, $[Replace, #Name, "/","."], "\"", ""], "/***METAPG:Meta***/"] ;

// Convert hx module name to lower case prefix.

PG-Prefix[$String] :: $String;
-[Data[#Name]]: PG-Prefix[#Name] → $[If, $[Contains,#Name,"."], PG-Prefix[$[AfterFirst,#Name,"."]], $[:,$[Replace,#Name,"\"",""],'/***METAPG:Meta***/$']] ;

// Extract last component of module name.

PG-LastName[$String] :: $String;
-[Data[#Name]]: PG-LastName[#Name]  → $[If, $[Contains,#Name,"."], PG-LastName[$[AfterFirst,#Name,"."]], $[Replace,#Name,"\"",""]] ;
// TODO: Sanity check that it is a capitalized word!

// Create qualified name.

PG-QN[$String<!--ModuleName-->, $String<!--Kind-->, $String<!--LocalName-->] :: $String ;
PG-QN[#ModuleName, #Kind, #Name] → PG-QN2[PG-LastName[#ModuleName], #Kind, #Name] ;
-[Data[#ModuleBase,#Kind,#Name]]: PG-QN2[#ModuleBase, #Kind, #Name] → $[If, $[Contains,#Name,'$'], $[:,#Kind,'_',#Name], $[:,#ModuleBase,'$',#Kind,'_',#Name]] ;

// Local name.

PG-LN[$String<!--BaseName-->, $String<!--Type-->] :: $String ;
-[Data[#BaseName,#Kind]] : PG-LN[#BaseName, #Kind] → $[:,#BaseName,'_',#Kind] ;

// Generate sort name for sort with repetition.

PG-SortNameWithRepeat[HxSort, HxRepeat] :: $String;
PG-SortNameWithRepeat[#Sort, #Repeat] → PG-SortNameWithRepeat1[PG-SortName[#Sort], #Repeat] ;
PG-SortNameWithRepeat1[$String, HxRepeat] :: $String;
-[Data[#FullSortName]] : PG-SortNameWithRepeat1[#FullSortName, #Repeat] → If[SameString["", #FullSortName], "", PG-SortNameWithRepeat2[#FullSortName, #Repeat]] ;
PG-SortNameWithRepeat2[$String, HxRepeat] :: $String;
PG-SortNameWithRepeat2[#FullSortName, %HxRepeat⟪ ⟫] → #FullSortName ;
PG-SortNameWithRepeat2[#FullSortName, %HxRepeat⟪ ? ⟫] → $[:,#FullSortName,"_Maybe"] ;
PG-SortNameWithRepeat2[#FullSortName, %HxRepeat⟪ * ⟫] → $[:,#FullSortName,"_MaybeSome"] ;
PG-SortNameWithRepeat2[#FullSortName, %HxRepeat⟪ + ⟫] → $[:,#FullSortName,"_Some"] ;
PG-SortNameWithRepeat2[#FullSortName, %HxRepeat⟪ + _ #RegExpLeaf# ⟫] → RegExpLeafSuffix[#RegExpLeaf#, $[:,#FullSortName,"_Some_"]] ;

// Extract sort name from sort.

PG-SortName[HxSort] :: $String;
-[Data[#Sort]]: PG-SortName[#Sort] → PG-SortName2[#Sort] ;

PG-SortName2[HxSort] :: $String;
PG-SortName2[           %HxSort⟪ #SortName# #MetaVariables# #SimpleSorts# ⟫] → #SortName# ;
PG-SortName2[$[NotMatch,%HxSort⟪ #SortName# #MetaVariables# #SimpleSorts# ⟫,#]] →  $[Show,#] ;

PG-BaseSortName[HxSort] :: $String;
-[Data[#Sort]]: PG-BaseSortName[#Sort] → PG-BaseSortName2[#Sort] ;
PG-BaseSortName2[HxSort] :: $String;
PG-BaseSortName2[           %HxSort⟪ #SortName# #MetaVariables# #SimpleSorts# ⟫] → #SortName# ;
PG-BaseSortName2[$[NotMatch,%HxSort⟪ #SortName# #MetaVariables# #SimpleSorts# ⟫,#]] →  "BAD" ;

// Extract inherited map attribute names (from all schemes).

{$String : DeclarationMapEntry} InheritedNames :: NameSet ;
{#DM} InheritedNames → FoldWhen[ok k ns.{#DM} KeepInheritedEntry[ok, k, ns], $[{#DM}Keys[$String]], NoNames] ;

{$String : DeclarationMapEntry} KeepInheritedEntry[Ok, $String, NameSet] :: NameSet;
{#DM} KeepInheritedEntry[OK, #name, #synthesized] → KeepInheritedEntry1[$[{#DM}Get[DeclarationMapEntry], #name, DME_NONE], #synthesized] ;

KeepInheritedEntry1[DeclarationMapEntry, NameSet] :: NameSet;
-[Data[#entry]]:
KeepInheritedEntry1[#entry, #synthesized] → KeepInheritedEntry2[#entry, #synthesized] ;

KeepInheritedEntry2[DeclarationMapEntry, NameSet] :: NameSet;
KeepInheritedEntry2[DME_ATTRIBUTE[%HxAttributeKind⟪ ↓ ⟫, #name, #form, #options], #synthesized] → AddName[#synthesized, #name] ;
KeepInheritedEntry2[$[NotMatch,DME_ATTRIBUTE[%HxAttributeKind⟪ ↓ ⟫, #name, #form, #options], #_], #synthesized] → #synthesized ;

{$String : DeclarationMapEntry} InheritedMapNames :: NameSet ;
{#DM} InheritedMapNames → FoldWhen[ok k ns.{#DM} KeepInheritedMapEntry[ok, k, ns], $[{#DM}Keys[$String]], NoNames] ;

{$String : DeclarationMapEntry} KeepInheritedMapEntry[Ok, $String, NameSet] :: NameSet;
{#DM} KeepInheritedMapEntry[OK, #name, #inheritedmaps] → KeepInheritedMapEntry1[$[{#DM}Get[DeclarationMapEntry], #name, DME_NONE], #inheritedmaps] ;

KeepInheritedMapEntry1[DeclarationMapEntry, NameSet] :: NameSet;
-[Data[#entry]]:
KeepInheritedMapEntry1[#entry, #inheritedmaps] → KeepInheritedMapEntry2[#entry, #inheritedmaps] ;

KeepInheritedMapEntry2[DeclarationMapEntry, NameSet] :: NameSet;
KeepInheritedMapEntry2[DME_ATTRIBUTE[%HxAttributeKind⟪ ↓ ⟫, #name, %HxAttributeForm⟪ { #Sort1# : #Sort2# } ⟫, #options], #inheritedmaps] → AddName[#inheritedmaps, #name] ;
KeepInheritedMapEntry2[$[NotMatch,DME_ATTRIBUTE[%HxAttributeKind⟪ ↓ ⟫, #name, %HxAttributeForm⟪ { #Sort1# : #Sort2# } ⟫, #options], #_], #inheritedmaps] → #inheritedmaps ;

{$String : DeclarationMapEntry} SynthesizedNames :: NameSet ;
{#DM} SynthesizedNames → FoldWhen[ok k ns.{#DM} KeepSynthesizedEntry[ok, k, ns], $[{#DM}Keys[$String]], NoNames] ;

{$String : DeclarationMapEntry} KeepSynthesizedEntry[Ok, $String, NameSet] :: NameSet;
{#DM} KeepSynthesizedEntry[OK, #name, #synthesized] → KeepSynthesizedEntry1[$[{#DM}Get[DeclarationMapEntry], #name, DME_NONE], #synthesized] ;

KeepSynthesizedEntry1[DeclarationMapEntry, NameSet] :: NameSet;
-[Data[#entry]]:
KeepSynthesizedEntry1[#entry, #synthesized] → KeepSynthesizedEntry2[#entry, #synthesized] ;

KeepSynthesizedEntry2[DeclarationMapEntry, NameSet] :: NameSet;
KeepSynthesizedEntry2[DME_ATTRIBUTE[%HxAttributeKind⟪ ↑ ⟫, #name, #form, #options], #synthesized] → AddName[#synthesized, #name] ;
KeepSynthesizedEntry2[$[NotMatch,DME_ATTRIBUTE[%HxAttributeKind⟪ ↑ ⟫, #name, #form, #options], #_], #synthesized] → #synthesized ;

{$String : DeclarationMapEntry} SynthesizedMapNames :: NameSet ;
{#DM} SynthesizedMapNames → FoldWhen[ok k ns.{#DM} KeepSynthesizedMapEntry[ok, k, ns], $[{#DM}Keys], NoNames] ;

{$String : DeclarationMapEntry} KeepSynthesizedMapEntry[Ok, $String, NameSet] :: NameSet;
{#DM} KeepSynthesizedMapEntry[OK, #name, #synthesizedmaps] → KeepSynthesizedMapEntry1[$[{#DM}Get[DeclarationMapEntry], #name, DME_NONE], #synthesizedmaps] ;

KeepSynthesizedMapEntry1[DeclarationMapEntry, NameSet] :: NameSet;
-[Data[#entry]]:
KeepSynthesizedMapEntry1[#entry, #synthesizedmaps] → KeepSynthesizedMapEntry2[#entry, #synthesizedmaps] ;

KeepSynthesizedMapEntry2[DeclarationMapEntry, NameSet] :: NameSet;
KeepSynthesizedMapEntry2[DME_ATTRIBUTE[%HxAttributeKind⟪ ↑ ⟫, #name, %HxAttributeForm⟪ { #Sort1# : #Sort2# } ⟫, #options], #synthesizedmaps] → AddName[#synthesizedmaps, #name] ;
KeepSynthesizedMapEntry2[$[NotMatch,DME_ATTRIBUTE[%HxAttributeKind⟪ ↑ ⟫, #name, %HxAttributeForm⟪ { #Sort1# : #Sort2# } ⟫, #options], #_], #synthesizedmaps] → #synthesizedmaps ;







// Errors.

∀ a . CookError[$String] :: a;
-[Data[#message]]: CookError[#message] → $[Error, #message] ;






)] //PG


/// /////////////////////////////////////////////////////////////////////
/// // PG-ProductionNames: Extract top level productions.
/// //
/// // Only include productions for tokens and sorts that have syntax.
/// 
/// {$String<!--SortName--> : DeclarationMapEntry} PG-ProductionNames[$List[$String]] :: $List[$String];
/// {#DM}PG-ProductionNames[()] → () ;
/// {#DM}PG-ProductionNames[(#1;#s)] → {#DM}PG-ProductionNames2[$[{#DM}Get[DeclarationMapEntry],#1,DME_NONE], #1, #s] ;
/// 
/// {$String<!--SortName--> : DeclarationMapEntry} PG-ProductionNames2[DeclarationMapEntry, $String, $List[$String]] :: $List[$String];
/// {#DM}PG-ProductionNames2[DME_NONE, #1, #s] → {#DM}PG-ProductionNames[#s] ;
/// {#DM}PG-ProductionNames2[DME_TOKEN[#SortName], #1, #s] → (#1 ; {#DM}PG-ProductionNames[#s]) ;
/// {#DM}PG-ProductionNames2[DME_ATTRIBUTE[#Kind, #Name, #AttributeForm, #AttributeOptions], #1, #s] → {#DM}PG-ProductionNames[#s] ;
/// {#DM}PG-ProductionNames2[DME_SORT[#Defines, #SortName, #Precs, #Wrapper], #1, #s] → {#DM}PG-ProductionNames3[#Defines, #1, #s] ;
/// 
/// {$String<!--SortName--> : DeclarationMapEntry} PG-ProductionNames3[$List[Define], $String, $List[$String]] :: $List[$String];
/// -[Fresh[dummy::HxSortParam]]:
/// {#DM} PG-ProductionNames3[(D_ABSTRACTION[a.#Define1[a]]; #Defines), #1, #s] → {#DM} PG-ProductionNames3[(#Define1[dummy]; #Defines), #1, #s] ;
/// {#DM} PG-ProductionNames3[(D_RULE[#Rule, #RuleSort, #IsData]; #Defines), #1, #s] → {#DM} PG-ProductionNames3[#Defines, #1, #s] ;
/// {#DM} PG-ProductionNames3[(D_FORM[#Form1, #Kind1]; #Defines), #1, #s] → {#DM} PG-ProductionNames4[#Form1, #Defines, #1, #s] ;
/// {#DM} PG-ProductionNames3[(D_NONE; #Defines), #1, #s] → {#DM} PG-ProductionNames3[#Defines, #1, #s] ;
/// {#DM} PG-ProductionNames3[(), #1, #s] → {#DM}PG-ProductionNames[#s] ;
/// 
/// {$String<!--SortName--> : DeclarationMapEntry} PG-ProductionNames4[HxForm, $List[Define], $String, $List[$String]] :: $List[$String];
/// {#DM} PG-ProductionNames4[Hx_M_FormParsedSorted[#Sort1, #ParsedForm1, #Prec1, #InheritedRefs], #Defines, #1, #s] → (#1; {#DM}PG-ProductionNames[#s]) ;
/// {#DM} PG-ProductionNames4[Hx_M_FormParsed[#ParsedForm1, #Prec1, #InheritedRefs], #Defines, #1, #s] → (#1; {#DM}PG-ProductionNames[#s]) ;
/// {#DM} PG-ProductionNames4[Hx_M_FormConstruction[#Constructor, #ScopeSortList, #InheritedRefs], #Defines, #1, #s] → {#DM} PG-ProductionNames3[#Defines, #1, #s] ;
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// /////////////////////////////////////////////////////////////////////
/// 
/// 
/// /////////////////////////////////////////////////////////////////////
/// // TEXT LIST OF REPEAT-DERIVED DECLARATIONS.
/// 
/// PG-ProduceDerived[DERIVED_SORT] :: TextMapSort;
/// PG-ProduceDerived[DERIVED[#SortName, #Prec, #Repeat]] → PG-ProduceRepeat[#Repeat, #SortName, #Prec, PG-ProductionNameWithPrecRepeatText[#SortName, #Prec, #Repeat]] ; 
/// 
/// PG-ProduceRepeat[HxRepeat, $String, $Numeric, Text] :: TextMapSort;
/// 
/// PG-ProduceRepeat[%HxRepeat⟪ ⟫, #s, #p, #name] → EmptyTextMap ;
/// 
/// -[Data[#s]]:
/// PG-ProduceRepeat[%HxRepeat⟪ ? ⟫, #s, #p, #name]
/// →
/// SingletonTextMap[TextToString[#name], %n⟪
/// <«#name»> ::= «
///   PG-MetaHead[B_TRUE, #ModuleName, $[:,#s,"?"], TextToString[#name], B_FALSE, 0]
/// »( <«PG-ProductionNameWithPrecText[#s, #p]»>:#1 {{ $Cons[#1,$Nil] }} | {{ $Nil }} ).
/// « PG-MetaTail[B_TRUE, $[:,#s,"?"], TextToString[#name]] »⟫]
/// ;
/// 
/// -[Data[#s]]:
/// PG-ProduceRepeat[%HxRepeat⟪ * ⟫, #s, #p, #name]
/// →
/// SingletonTextMap[TextToString[#name], %n⟪
/// <«#name»> ::= «
///   PG-MetaHead[B_TRUE, #ModuleName, $[:,#s,"*"], TextToString[#name], B_FALSE, 0]
/// »( <«PG-ProductionNameWithPrecText[#s, #p]»>:#1 <«#name»>:#2 {{ $Cons[#1,#2] }} | {{ $Nil }} ).
/// « PG-MetaTail[B_TRUE, $[:,#s,"*"], TextToString[#name]] »⟫]
/// ;
/// 
/// -[Data[#s]]:
/// PG-ProduceRepeat[%HxRepeat⟪ + ⟫, #s, #p, #name]
/// →
/// SingletonTextMap[TextToString[#name], %n⟪
/// <«#name»> ::= «
///   PG-MetaHead[B_TRUE, #ModuleName, $[:,#s,"+"], TextToString[#name], B_FALSE, 0]
/// » <«PG-ProductionNameWithPrecText[#s, #p]»>:#1 ( <«#name»>:#2 {{ $Cons[#1,#2] }} | {{ $Cons[#1,$Nil] }} ) .
/// « PG-MetaTail[B_TRUE, $[:,#s,"+"], TextToString[#name]] »⟫]
/// ;
/// 
/// -[Data[#s]]:
/// PG-ProduceRepeat[%HxRepeat⟪ + _ #RegExpLeaf# ⟫, #s, #p, #name]
/// →
/// SingletonTextMap[TextToString[#name], %n⟪
/// <«#name»> ::= «
///   PG-MetaHead[B_TRUE, #ModuleName, RegExpLeafSuffix[#RegExpLeaf#, $[:,#s,"+_"]], TextToString[#name], B_FALSE, 0]
/// » <«PG-ProductionNameWithPrecText[#s, #p]»>:#1 ( « PG-InlineRegExpSimple[#RegExpLeaf#, ""] » <«#name»>:#2 {{ $Cons[#1,#2] }} | {{ $Cons[#1,$Nil] }} ) .
/// « PG-MetaTail[B_TRUE, RegExpLeafSuffix[#RegExpLeaf#, $[:,#s,"+_"]], TextToString[#name]] »⟫]
/// ;
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// /////////////////////////////////////////////////////////////////////
/// /////////////////////////////////////////////////////////////////////
/// 
/// // CookBase.crs: CRSX3 SUPPORT LIBRARY FOR HACS PREPROCESSOR OPERATIONS.
/// //
/// // Declarations here depend only on the Prelude and the Hx syntax.
/// //
/// CookBase[(
/// 
/// $Use["org/crsx/hacs/Prelude.crs"];
/// 
/// // Syntax and sorts of hx terms (%Hx...⟪...⟫).
/// $Use["org/crsx/hacs/Hx.crs"];
/// 
/// // Syntax and sorts of text (%n⟪...⟫).
/// $CheckGrammar["net.sf.crsx.text.Text"];
/// $Use["net/sf/crsx/text/Text.crs"];
/// 
/// $Lax;
/// 
/// /////////////////////////////////////////////////////////////////////
/// // LOCATION EXTRACTION.
/// 
/// $StringEntrySort ::=( STRING[$String]; );
/// 
/// {$String : $StringEntrySort}MakeLocation :: $String;
/// {#L}MakeLocation → MakeLocation2[$[{#L}Get[$StringEntrySort],"$FileLocation",STRING[""]], $[{#L}Get[$StringEntrySort],"$LineLocation",STRING[""]], $[{#L}Get[$StringEntrySort],"$ColumnLocation",STRING[""]]] ;
/// MakeLocation2[$StringEntrySort, $StringEntrySort, $StringEntrySort] :: $String;
/// MakeLocation2[STRING[#file], STRING[#line], STRING[#column]] → $[:,#file," ",#line,":",#column] ;
/// 
/// 
/// 
/// /////////////////////////////////////////////////////////////////////
/// // SORT EXTRACTION.
/// 
/// ScopePG-SortName[HxScopeSort] :: $String;
/// ScopePG-SortName[%HxScopeSort⟪ #Sort# #Repeat# [ #SubstituteSorts# ] ⟫] → SortNameWithRepeat[#Sort#, #Repeat#] ;
/// -[Free[v::Text]]:
/// ScopePG-SortName[%HxScopeSort⟪ [ v : #Sort# ] ⟫                  ] → PG-SortName[#Sort#] ;
/// -[Free[v::Text]]:
/// ScopePG-SortName[%HxBindersScopeSort⟪ [ v : #Sort# ] #BindersScopeSort# ⟫] → ScopePG-SortName[#BindersScopeSort#] ;
/// 
/// ScopeSortMetaVar[HxScopeSort, $Numeric] :: $String;
/// -[Discard[#SubstituteSorts#]]: ScopeSortMetaVar[%HxScopeSort⟪ #Sort# [ #SubstituteSorts# ] ⟫, #n] → SortMetaVar[#Sort#, #n] ;
/// -[Free[v::Text]]: ScopeSortMetaVar[%HxScopeSort⟪ [ v : #Sort# ] ⟫                  , #n] → SortMetaVar[#Sort#, #n] ;
/// 

/// 
/// 
/// 
/// 
/// 
/// /////////////////////////////////////////////////////////////////////
/// // PRODUCTION NAMES.
/// 
/// 
/// /////////////////////////////////////////////////////////////////////
/// // ERRORS.
/// 
/// 
/// /////////////////////////////////////////////////////////////////////
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 


/// 
/// 
/// /////////////////////////////////////////////////////////////////////
/// // COMPARISON OF FORMS.
/// 
/// 
/// 
/// 
/// 
/// /////////////////////////////////////////////////////////////////////
/// // Extract all repeat-derived sort forms from DM structure.
/// 
/// DERIVED_SORT ::=( DERIVED[$String, $Numeric<!--Precedence-->, HxRepeat]; );
/// 
/// {$String<!--SortName--> : DeclarationMapEntry} DerivedSorts[NameSet] :: $List[DERIVED_SORT];
/// {#DM} DerivedSorts[#Names] → FoldNamesWhen[ok x y.{#DM} Then-DerivedSorts2[ok, x, y], #Names, ()] ;
/// 
/// {$String<!--SortName--> : DeclarationMapEntry} Then-DerivedSorts2[Ok, $String, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// {#DM} Then-DerivedSorts2[OK, #name, #derived] → DerivedSorts2[$[{#DM}Get[DeclarationMapEntry], #name, DME_NONE], #derived];
/// 
/// DerivedSorts2[DeclarationMapEntry, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// 
/// DerivedSorts2[DME_NONE, #derived] → #derived ;
/// DerivedSorts2[DME_TOKEN[#name], #derived] → #derived ;
/// DerivedSorts2[DME_ATTRIBUTE[#kind, #name, #form, #options], #derived] → #derived ;
/// 
/// DerivedSorts2[DME_SORT[#Defines, #Name, #Precs, #Wrapper], #derived]
/// →
/// FoldWhen[ok defined derived.Then-DerivedSorts-Defines[ok, defined, derived], #Defines, #derived]
/// ;
/// 
/// Then-DerivedSorts-Defines[Ok, Define, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// -[Fresh[dummy::HxSortParam]]: Then-DerivedSorts-Defines[OK, D_ABSTRACTION[a . #Define[a]], #derived] → Then-DerivedSorts-Defines[OK, #Define[dummy], #derived] ;
/// Then-DerivedSorts-Defines[OK, D_FORM[#Form, #Kind], #derived] → DerivedSorts-Form[#Form, #derived] ;
/// Then-DerivedSorts-Defines[OK, D_RULE[#Rule, #SortName, #IsDataEquivalence], #derived] → DerivedSorts-Rule[#Rule, #derived] ;
/// Then-DerivedSorts-Defines[OK, D_SYNTHESIZES[#AttributeName], #derived] → #derived ;
/// Then-DerivedSorts-Defines[OK, D_NONE, #derived] → #derived ;
/// 
/// DerivedSorts-Form[HxForm, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-Form[Hx_M_FormParsedSorted[#Sort#, #ParsedForm#, #Prec#, #InheritedRefs], #derived] → DerivedSorts-ParsedForm[#ParsedForm#, #derived] ;
/// DerivedSorts-Form[Hx_M_FormParsed[#ParsedForm#, #Prec#, #InheritedRefs], #derived] → DerivedSorts-ParsedForm[#ParsedForm#, #derived] ;
/// DerivedSorts-Form[Hx_M_FormConstruction[#Constructor#, #ScopeSorts#, #InheritedRefs], #derived] → #derived ;
/// 
/// DerivedSorts-ParsedForm[HxParsedForm, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-ParsedForm[Hx_M_ParsedFormWord[#Word, #ParsedForm], #derived] → DerivedSorts-ParsedForm[#ParsedForm, #derived] ;
/// DerivedSorts-ParsedForm[Hx_M_ParsedFormSpace[#Space, #ParsedForm], #derived] → DerivedSorts-ParsedForm[#ParsedForm, #derived] ;
/// DerivedSorts-ParsedForm[Hx_M_ParsedFormDone, #derived] → #derived ;
/// DerivedSorts-ParsedForm[Hx_M_ParsedFormTerm[Hx_M_ScopeSortPrecRepeat[#ScopeSort, #Precedence, #Repeat], #ParsedForm], #derived]
/// →
/// DerivedSorts-ScopeSort[#ScopeSort, #Precedence, #Repeat, DerivedSorts-ParsedForm[#ParsedForm, #derived]]
/// ;
/// 
/// DerivedSorts-ScopeSort[HxScopeSort, $Numeric, HxRepeat, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-ScopeSort[%HxScopeSort⟪ #Sort# #Repeat# [ #SubstituteSorts1# ] ⟫, #Precedence, #Repeat, #derived] → DerivedSorts-Sort[#Sort#, #Precedence, NestedRepeat[#Repeat#, #Repeat], #derived] ;
/// -[Free[v::Text]]:
/// DerivedSorts-ScopeSort[%HxScopeSort⟪ [ v : #Sort# ] ⟫, #Precedence, #Repeat, #derived] → #derived ;
/// 
/// DerivedSorts-Sort[HxSort, $Numeric, HxRepeat, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// -[Data[#Repeat]]:
/// DerivedSorts-Sort[#Sort, #Precedence, #Repeat, #derived] → DerivedSorts-Sort2[#Repeat, #Precedence, PG-BaseSortName[#Sort], #derived] ;
/// 
/// DerivedSorts-Sort2[HxRepeat, $Numeric, $String, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-Sort2[%HxRepeat⟪ ⟫, #Precedence, #Name, #derived] → #derived ;
/// -[Data[#Repeat,#Name]]:
/// DerivedSorts-Sort2[$[NotMatch,%HxRepeat⟪ ⟫,#Repeat], #Precedence, #Name, #derived]
/// →
/// $[IfEmpty, #Name, #derived, (DERIVED[#Name, #Precedence, #Repeat] ; #derived)]
/// ;
/// 
/// DerivedSorts-Rule[HxRule, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-Rule[%HxRule⟪ #Priority# #Construction# : #Construction_Pattern# → #Term_Contraction# ⟫, #derived]
/// →
/// DerivedSorts-Term[#Construction_Pattern#, DerivedSorts-Term[#Term_Contraction#, #derived]]
/// ;
/// 
/// DerivedSorts-Term[HxTerm, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// 
/// DerivedSorts-Term[Hx_M_OMITTED, #derived] → #derived ;
/// 
/// -[Free[v::Text]]:
/// DerivedSorts-Term[%HxTerm⟪ v #Attributes# ⟫, #derived] → DerivedSorts-Attributes[#Attributes#, #derived] ;
/// 
/// -[Free[v::Text]]:
/// DerivedSorts-Term[%HxTerm⟪ #Constructor# #Repeat# v #Attributes# ⟫, #derived]
/// →
/// DerivedSorts-Repeat[#Constructor#, #Repeat#, DerivedSorts-Attributes[#Attributes#, #derived]] ;
/// 
/// DerivedSorts-Term[%HxTerm⟪ #Literal# #Attributes# ⟫, #derived] → DerivedSorts-Attributes[#Attributes#, #derived] ;
/// 
/// DerivedSorts-Term[Hx_M_Unparsed[#Unparsed, #Attributes], #derived] → #derived ;
/// DerivedSorts-Term[Hx_M_UnparsedSorted[#Name, #Repeat, #Unparsed, #Attributes], #derived] → #derived ;
/// 
/// DerivedSorts-Term[%HxTerm⟪ #Constructor# (#Scopes#) #Attributes# ⟫, #derived] → DerivedSorts-Scopes[#Scopes#, DerivedSorts-Attributes[#Attributes#, #derived]] ;
/// 
/// DerivedSorts-Term[%HxTerm⟪ #Constructor1# #Repeat# #Constructor# (#Scopes#) #Attributes# ⟫, #derived]
/// →
/// DerivedSorts-Repeat[#Constructor1#, #Repeat#, DerivedSorts-Scopes[#Scopes#, DerivedSorts-Attributes[#Attributes#, #derived]]]
/// ;
/// 
/// DerivedSorts-Term[%HxTerm⟪ #MetaVariable# [#Terms#] #Attributes# ⟫, #derived]
/// →
/// DerivedSorts-Terms[#Terms#, DerivedSorts-Attributes[#Attributes#, #derived]]
/// ;
/// 
/// DerivedSorts-Term[%HxTerm⟪ #Constructor_Sort# #Repeat# #MetaVariable# [#Terms#] #Attributes# ⟫, #derived]
/// →
/// DerivedSorts-Repeat[#Constructor_Sort#, #Repeat#, DerivedSorts-Terms[#Terms#, #derived]]
/// ;
/// 
/// DerivedSorts-Term[Hx_M_Special[#v, #Concrete], #derived] → #derived ;
/// 
/// DerivedSorts-Repeat[$String, HxRepeat, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-Repeat[#Name, %HxRepeat⟪ ⟫, #derived] → #derived ;
/// -[Data[#Name,#Repeat]]: DerivedSorts-Repeat[#Name, $[NotMatch,%HxRepeat⟪ ⟫,#Repeat], #derived]
/// →
/// $[IfEmpty, #Name, #derived, (DERIVED[#Name, 0, #Repeat] ; #derived)]
/// ;
/// 
/// DerivedSorts-Scopes[$List[HxScope], $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-Scopes[#Scopes, #derived] → FoldWhen[ok scope derived.Then-DerivedSorts-Scope[ok, scope, derived], #Scopes, #derived] ;
/// 
/// Then-DerivedSorts-Scope[Ok, HxScope, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// Then-DerivedSorts-Scope[OK, Hx_M_Scope[#vs, #Term], #derived] → DerivedSorts-Term[#Term, #derived] ;
/// 
/// DerivedSorts-Terms[$List[HxTerm], $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-Terms[#Terms, #derived] → FoldWhen[ok term derived.Then-DerivedSorts-Term[ok, term, derived], #Terms, #derived] ;
/// 
/// Then-DerivedSorts-Term[Ok, HxTerm, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// Then-DerivedSorts-Term[OK, #Term, #derived] → DerivedSorts-Term[#Term, #derived] ;
/// 
/// DerivedSorts-Attributes[$List[HxAttribute], $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-Attributes[(), #derived] → #derived ;
/// DerivedSorts-Attributes[(#a1;#as), #derived] → DerivedSorts-Attribute[#a1, DerivedSorts-Attributes[#as, #derived]] ;
/// 
/// DerivedSorts-Attribute[HxAttribute, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-Attribute[%HxAttribute⟪ #AttributeKind# #AttributeName# ( #Term# ) ⟫, #derived] → DerivedSorts-Term[#Term#, #derived] ;
/// DerivedSorts-Attribute[%HxAttribute⟪ #AttributeKind# #AttributeName# { #Term# } ⟫, #derived] → DerivedSorts-Term[#Term#, #derived] ;
/// DerivedSorts-Attribute[%HxAttribute⟪ #AttributeKind# #AttributeName# { #Term1# : #Term2# } ⟫, #derived] → DerivedSorts-Term[#Term1#, DerivedSorts-Term[#Term2#, #derived]] ;
/// DerivedSorts-Attribute[%HxAttribute⟪ #AttributeKind# #AttributeName# { ¬ #Term# } ⟫, #derived] → DerivedSorts-Term[#Term#, #derived] ;
/// 
/// // Name.
/// ProductionNameDerived[DERIVED_SORT] :: Text;
/// ProductionNameDerived[DERIVED[#Name, #Prec, #Repeat]] → PG-ProductionNameWithPrecRepeatText[#Name, #Prec, #Repeat] ;
/// 
/// Un$Hx[HxTerm] :: HxTerm ;
/// Un$Hx[#] → # ;
/// 
/// /////////////////////////////////////////////////////////////////////
/// // Extract scope sorts for unparsed constructor.
/// 
/// {$String : DeclarationMapEntry}
/// ConstructorScopeSorts[$String<!--SortName-->, $String<!--Constructor-->] :: Lifted[$List[HxScopeSort]] ;
/// 
/// -[Data[#TopSortName]]:
/// {#DM}ConstructorScopeSorts[#TopSortName, #Constructor]
/// →
/// ConstructorScopeSorts0[$[{#DM}Get[DeclarationMapEntry], #TopSortName, DME_NONE], #Constructor]
/// ;
/// 
/// ConstructorScopeSorts0[DeclarationMapEntry, $String<!--Constructor-->] :: Lifted[$List[HxScopeSort]] ;
/// -[Data[#Entry, #Constructor]]:
/// ConstructorScopeSorts0[#Entry, #Constructor]
/// →
/// ConstructorScopeSorts1[#Entry, #Constructor]
/// ;
/// 
/// ConstructorScopeSorts1[DeclarationMapEntry, $String<!--Constructor-->] :: Lifted[$List[HxScopeSort]] ;
/// 
/// ConstructorScopeSorts1[DME_SORT[#Defines, #Name, #Precs, #Wrapper], #Constructor]
/// →
/// ConstructorScopeSorts2[#Defines, #Constructor]
/// ;
/// ConstructorScopeSorts1[$[NotMatch,DME_SORT[#Defines, #Name, #Precs, #Wrapper],#_], #Constructor] → BOTTOM ;
/// 
/// ConstructorScopeSorts2[$List[Define], $String<!--Constructor-->] :: Lifted[$List[HxScopeSort]] ;
/// 
/// ConstructorScopeSorts2[(), #Constructor] → BOTTOM ;
/// 
/// -[Fresh[param::HxSortParam]]:
/// ConstructorScopeSorts2[(D_ABSTRACTION[a.#Define[a]]; #Defines), #Constructor] → ConstructorScopeSorts2[(#Define[param]; #Defines), #Constructor] ;
/// 
/// ConstructorScopeSorts2[(D_RULE[#Rule, #sort, #IsDataEquivalence?]; #Defines), #Constructor] → ConstructorScopeSorts2[#Defines, #Constructor] ;
/// 
/// ConstructorScopeSorts2[(D_FORM[#Form, #Kind]; #Defines), #Constructor]
/// →
/// ConstructorScopeSorts3[#Form, #Defines, #Constructor]
/// ;
/// 
/// ConstructorScopeSorts2[(D_SYNTHESIZES[#AttributeName]; #Defines), #Constructor] → ConstructorScopeSorts2[#Defines, #Constructor] ;
/// 
/// ConstructorScopeSorts3[HxForm, $List[Define], $String<!--Constructor-->] :: Lifted[$List[HxScopeSort]] ;
/// -[Data[#Constructor1,#Constructor2]]:
/// ConstructorScopeSorts3[Hx_M_FormConstruction[#Constructor1, #ScopeSorts, #InheritedRefs], #Defines, #Constructor2]
/// →
/// $[If, $[Equal,#Constructor1,#Constructor2], LIFTED[#ScopeSorts], ConstructorScopeSorts2[#Defines, #Constructor2]]
/// ;
/// -[Data[#_]]:
/// ConstructorScopeSorts3[$[NotMatch,Hx_M_FormConstruction[#Constructor, #ScopeSorts, #InheritedRefs],#_], #Defines, #Constructor2] → ConstructorScopeSorts2[#Defines, #Constructor2] ;
/// 
/// 
/// /////////////////////////////////////////////////////////////////////
/// // Extract sort names.
/// 
/// {$String : DeclarationMapEntry} SortNameList :: $List[$String] ;
/// {#DM} SortNameList → {#DM} SortNameList2[$[{#DM}Keys[$String]]] ;
/// 
/// {$String : DeclarationMapEntry} SortNameList2[$List[$String]] :: $List[$String] ;
/// {#DM} SortNameList2[()] → () ;
/// {#DM} SortNameList2[(#Name; #Names)] → {#DM} SortNameList3[$[{#DM}Get[DeclarationMapEntry], #Name], #Names] ;
/// 
/// {$String : DeclarationMapEntry} SortNameList3[DeclarationMapEntry, $List[$String]] :: $List[$String] ;
/// {#DM} SortNameList3[DME_SORT[#Defines1, #Name1, #Precs1, #Wrapper1], #Names]
/// →
/// (#Name1 ; {#DM} SortNameList2[#Names])
/// ; 
/// 
/// {#DM} SortNameList3[$[NotMatch, DME_SORT[#Defines1, #Name1, #Precs1, #Wrapper1], #_], #Names]
/// →
/// {#DM} SortNameList2[#Names]
/// ;
/// 
/// 
/// /////////////////////////////////////////////////////////////////////
/// // Extract token names.
/// 
/// {$String : DeclarationMapEntry} TokenNameList :: $List[$String] ;
/// {#DM} TokenNameList → {#DM} TokenNameList2[$[{#DM}Keys[$String]]] ;
/// 
/// {$String : DeclarationMapEntry} TokenNameList2[$List[$String]] :: $List[$String] ;
/// {#DM} TokenNameList2[()] → () ;
/// {#DM} TokenNameList2[(#Name; #Names)] → {#DM} TokenNameList3[$[{#DM}Get[DeclarationMapEntry], #Name], #Name, #Names] ;
/// 
/// {$String : DeclarationMapEntry} TokenNameList3[DeclarationMapEntry, $String, $List[$String]] :: $List[$String] ;
/// {#DM} TokenNameList3[DME_TOKEN[#String1], #Name, #Names]
/// →
/// (#Name ; {#DM} TokenNameList2[#Names])
/// ; 
/// 
/// {#DM} TokenNameList3[$[NotMatch, DME_TOKEN[#String1], #_], #Name, #Names]
/// →
/// {#DM} TokenNameList2[#Names]
/// ;
/// 
/// 
/// /////////////////////////////////////////////////////////////////////
/// // Extract attribute names.
/// 
/// {$String : DeclarationMapEntry} AttributeNameList :: $List[$String] ;
/// {#DM} AttributeNameList → {#DM} AttributeNameList2[$[{#DM}Keys[$String]]] ;
/// 
/// {$String : DeclarationMapEntry} AttributeNameList2[$List[$String]] :: $List[$String] ;
/// {#DM} AttributeNameList2[()] → () ;
/// {#DM} AttributeNameList2[(#Name; #Names)] → {#DM} AttributeNameList3[$[{#DM}Get[DeclarationMapEntry], #Name], #Names] ;
/// 
/// {$String : DeclarationMapEntry} AttributeNameList3[DeclarationMapEntry, $List[$String]] :: $List[$String] ;
/// {#DM} AttributeNameList3[DME_ATTRIBUTE[#AttributeKind#, #AttributeName#, #AttributeForm#, #AttributeOptions#], #Names]
/// →
/// (#AttributeName# ; {#DM} AttributeNameList2[#Names])
/// ; 
/// 
/// {#DM} AttributeNameList3[$[NotMatch, DME_ATTRIBUTE[#AttributeKind#, #AttributeName#, #AttributeForm#, #AttributeOptions#], #_], #Names]
/// →
/// {#DM} AttributeNameList2[#Names]
/// ;
/// 
/// 
/// /////////////////////////////////////////////////////////////////////
/// 
/// 
/// /////////////////////////////////////////////////////////////////////
/// // Sort name for attribute value.
/// 
/// {$String : DeclarationMapEntry} AttributeValuePG-SortName[$String] :: $String;
/// {#DM}AttributeValuePG-SortName[#AttributeName] → {#DM}AttributeValueSortName1[$[{#DM}Get[DeclarationMapEntry], #AttributeName, DME_NONE], #AttributeName] ;
/// 
/// {$String : DeclarationMapEntry} AttributeValueSortName1[DeclarationMapEntry, $String] :: $String;
/// -[Data[#Entry]]:
/// {#DM}AttributeValueSortName1[#Entry, #AttributeName] → {#DM}AttributeValueSortName2[#Entry, #AttributeName] ;
/// 
/// {$String : DeclarationMapEntry} AttributeValueSortName2[DeclarationMapEntry, $String] :: $String;
/// {#DM}AttributeValueSortName2[DME_ATTRIBUTE[#AttributeKind, #AttributeName, %HxAttributeForm⟪ ( #Sort# ) ⟫, #AttributeOptions], #SortName] → PG-SortName[#Sort#];
/// {#DM}AttributeValueSortName2[DME_ATTRIBUTE[#AttributeKind, #AttributeName, %HxAttributeForm⟪ { #Sort# } ⟫, #AttributeOptions], #SortName] → "";
/// {#DM}AttributeValueSortName2[DME_ATTRIBUTE[#AttributeKind, #AttributeName, %HxAttributeForm⟪ { #Sort1# : #Sort2# } ⟫, #AttributeOptions], #SortName] → PG-SortName[#Sort2#];
/// -[Data[#_]]: {#DM}AttributeValueSortName2[$[NotMatch,DME_ATTRIBUTE[#AttributeKind, #AttributeName, #AttributeForm, #AttributeOptions],#_], #SortName] → $[Error,"No declaration of attribute"] ;
/// 
/// {$String : DeclarationMapEntry} AttributeKeyPG-SortName[$String] :: $String;
/// {#DM}AttributeKeyPG-SortName[#SortName] → {#DM}AttributeKeySortName1[$[{#DM}Get[DeclarationMapEntry], #SortName, DME_NONE], #SortName] ;
/// 
/// {$String : DeclarationMapEntry} AttributeKeySortName1[DeclarationMapEntry, $String] :: $String;
/// -[Data[#Entry]]:
/// {#DM}AttributeKeySortName1[#Entry, #SortName] → {#DM}AttributeKeySortName2[#Entry, #SortName] ;
/// 
/// {$String : DeclarationMapEntry} AttributeKeySortName2[DeclarationMapEntry, $String] :: $String;
/// {#DM}AttributeKeySortName2[DME_ATTRIBUTE[#AttributeKind, #AttributeName, %HxAttributeForm⟪ ( #Sort# ) ⟫, #AttributeOptions], #SortName] → "" ;
/// {#DM}AttributeKeySortName2[DME_ATTRIBUTE[#AttributeKind, #AttributeName, %HxAttributeForm⟪ { #Sort# } ⟫, #AttributeOptions], #SortName] → PG-SortName[#Sort#];
/// {#DM}AttributeKeySortName2[DME_ATTRIBUTE[#AttributeKind, #AttributeName, %HxAttributeForm⟪ { #Sort1# : #Sort2# } ⟫, #AttributeOptions], #SortName] → PG-SortName[#Sort1#];
/// {#DM}AttributeKeySortName2[$[NotMatch,DME_ATTRIBUTE[#AttributeKind, #AttributeName, #AttributeForm, #AttributeOptions],#_], #SortName] → "" ;
/// 
/// 
/// /////////////////////////////////////////////////////////////////////
/// // Initialize otherwise unused maps.
/// 
/// {$String : DeclarationMapEntry} PG-InitOtherMaps[$List[HxAttribute], $String] :: Text;
/// 
/// {#DM; "$AllInheritedMapNames" : NAMES[#InheritedMapNames]}
/// PG-InitOtherMaps[#Attributes, #sep] → PG-InitOtherMaps1[FoldWhen[ok a ns.ThenRemoveAttributeName[ok, a, ns], #Attributes, #InheritedMapNames], #sep, $False] ;
/// 
/// {$String : DeclarationMapEntry} PG-CaptureOtherMaps[$List[HxAttribute]] :: Text;
/// {#DM; "$AllInheritedMapNames" : NAMES[#InheritedMapNames]}
/// PG-CaptureOtherMaps[#Attributes] → PG-InitOtherMaps1[FoldWhen[ok a ns.ThenRemoveAttributeName[ok, a, ns], #Attributes, #InheritedMapNames], "; ", $True] ;
/// 
/// ThenRemoveAttributeName[Ok, HxAttribute, NameSet] :: NameSet;
/// ThenRemoveAttributeName[OK, %HxAttribute⟪ #AttributeKind# #AttributeName# #AttributeValue# ⟫, #MapNames] → RemoveName[#MapNames, #AttributeName#] ;
/// 
/// PG-InitOtherMaps1[NameSet, $String, $Boolean] :: Text;
/// PG-InitOtherMaps1[#MapNames, #sep, #capture] → PG-InitOtherMaps2[NameSetList[#MapNames], #sep, #capture] ;
/// 
/// PG-InitOtherMaps2[$List[$String], $String, $Boolean] :: Text;
/// PG-InitOtherMaps2[(), #sep, #capture] → %n⟪⟫ ;
/// PG-InitOtherMaps2[(#a;#as), #sep, #capture] → %n⟪†«#sep»"†«#a»" : {« $[If, #capture, %n⟨#InheritedMap_†‹#a›⟩, %n⟨⟩] »}Inherited_†«#a»« PG-InitOtherMaps2[#as, "; ", #capture] »⟫ ;
/// 
/// /////////////////////////////////////////////////////////////////////
/// )]//CookN
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
/// 
