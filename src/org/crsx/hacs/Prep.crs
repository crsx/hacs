// Prep.crs: CRSX3 RULES FOR CONVERTING HACS .hx FORM TO DESCRIPTIVE PARSER ARTIFACTS.
// Copyright © 2012,2014 Kristoffer H. Rose <krisrose@crsx.org>

Prep[(

// "Preparation" stage for converting HACS specification to PG/JavaCC parser + CRSX rules combination.
//
// Input: HACS (.hx) file as a "raw Hx" term.
// Output: single text containing multiple files (using /***...***/ delimiters):
// * .pg parser for user's language (unmarked + USERPG).
// * .pgtemplate for HACS parser extended with user's meta-terms (unmarked + METAPG).
// * .pg parser for user's meta-terms as embedded in rules (unmarked + EMBEDPG).
// * .crs sort declarations for user's terms (SORTS).
//
// Contents:
// 1. Top level (Prep).
// 2. Generate text of all non-terminal productions (P-Productions).
// 3. Generate single sort/precedence combination (P-Expand).
// 4. Generate text of all lexical declarations (P-Lexical).
// 5. Helpers for managing repeats.
// 6. Text naming conventions.
// 7. JJ Helpers.
// 8. Other Helpers.


// Input format is full "raw" HACS syntax %raw….⟦…⟧.
$CheckGrammar["org.crsx.hacs.HxRaw"];
$Use["org/crsx/hacs/HxRaw.crs"];

// Output format is text %n⟪...⟫.
$CheckGrammar["net.sf.crsx.text.Text"];
$Use["net/sf/crsx/text/Text.crs"];

// Standard functions.
$Use["org/crsx/hacs/Prelude.crs"];

// Utilities shared with other stages.
$Use["org/crsx/hacs/Util.crs"];

// Infer options.
$Lax;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 1. TOP LEVEL
//
// Prep1: Extract declarations from HACS hx term with all modules inlined.
// Prep2: Generate actual text.

Prep[HxModule] :: Text;
Prep[%rawHxModule⟦ module #HxModuleName# { #HxDeclarations# } ⟧]
→
Prep1[#HxModuleName#, U-ResolveImports[#HxDeclarations#, #HxModuleName#, "raw"], dm ds.Prep2[dm, ds, #HxModuleName#]]
;

Prep1[$String<!--ModuleName-->, $List[HxDeclaration], dm::DeclarationMap ds:$List[HxDeclaration].Text] :: Text;
-[Data[#Declarations]]:
Prep1[#ModuleName, #Declarations, dm ds.#[dm,ds]]
→
#[{} U-MakeDeclarationMap[#Declarations, #ModuleName], #Declarations]
;

Prep2[DeclarationMap, $List[HxDeclaration], $String<!--ModuleName-->] :: Text ;
Prep2[{#DM}DM, #Declarations, #ModuleName]
→
Prep3[{#DM}DM, #Declarations, #ModuleName, FilterNamesWhen[ok s.{#DM}U-then-SortHasUserHx[ok, s], {#DM}U-AllSortNames]]
;

Prep3[DeclarationMap, $List[HxDeclaration], $String<!--ModuleName-->, NameSet<!--SortsWithUserConstructors-->] :: Text ;
-[Data[#SortsWithUserConstructors]]:
Prep3[{#DM}DM, #Declarations, #ModuleName, #SortsWithUserConstructors]
→
%n⟪/* PG Grammar for /***METAPG&EMBED: HACS module specialized for parsed***/ †« #ModuleName » terms /***EMBEDPG: (embedded terms)***/ */

/* INTERFACE. */

class †« U-ClassName[#ModuleName] »/***USERPG:Parser***//***METAPG:Hx***//***EMBEDPG:Embed***/ :⟦
/***USERPG:<†« U-Local[{#DM}U-MainSymbol] »>« TextJoin[MapWhen[ok n.%n⟨,<†‹ U-then-Local[ok, n] ›>⟩, {#DM}U-NonMainSyntacticSymbols], %n⟨⟩] » ***/
/***EMBEDPG:<†« U-Local[{#DM}U-MainSymbol] »>« TextJoin[MapWhen[ok n.%n⟨,<†‹ U-then-Local[ok, n] ›>⟩, {#DM}U-NonMainSymbols], %n⟨⟩] » ***/
/***METAPG:
%%%HXNONTERMINALS%%%
<HxTopTerm>, <HxTopPattern>, <HxAttributes>, <HxSortName>, <HxAttributeName>, <HxConstructor>,
<PresortedMetaApplication>, <PresortedVariable>, <PresortedParsed>, <SortedTerm>,
<BracketedTerms>, <Terms>, <Term>, <Attribute>
***/
⟧

/***USERPG: prefix "†« P-User-Prefix[#ModuleName] »" ***/
/***METAPG: prefix "†« P-Meta-Prefix[#ModuleName] »" ***/
/***EMBEDPG: prefix "†« P-Embed-Prefix[#ModuleName] »" ***/

/***METAPG:
declarations
%{
%%%HXDECLARATIONS%%%
String hx(String s) { return "Hx_"+s; }
String user(String s) { return "†« U-LastName[#ModuleName] »_"+s; }
%}
***/

/***EMBEDPG:
declarations
%{
static String unwrap(String s) {return s.substring(1, s.length()-1);}
String hx(String s) { return "Hx_"+s; }
String user(String s) { return "†« U-LastName[#ModuleName] »_"+s; }
%}
***/

/***USERPG&EMBEDPG:
%{
TOKEN_MGR_DECLS : { int nesting; int nestedState;} /* Used by all nesting constructs. */
%}
***/

/***METAPG:
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
%%%HXPREPRODUCTIONS%%%
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
***/

/***METAPG:
/* HX INTERFACE. */

<HxTopTerm> ::= <PresortedVariable> | <PresortedMetaApplication> | <HxTopPattern> .
<HxTopPattern> ::= <PresortedParsed> | <SortedTerm> .
<HxAttributes> ::= ( {$Cons} <Attribute> <HxAttributes> | {$Nil} ).
<HxSortName> ::= ( « TextJoin[MapNamesWhen[ok n.%n⟨"†‹ U-then-Local[ok,n] ›"$⟩, UnionNames[{#DM}U-AllTokenNames, {#DM}U-AllSortNames]], %n⟨ | ⟩] » ).
<HxConstructor> ::= ( « TextJoin[{#DM} U-MapAllConstructorSorts[c s.%n⟨"†‹c›"$ |⟩], %n⟨ ⟩] » "__HACS__"$ ).

/* GENERAL TERMS. */

<PresortedVariable> ::= <HxVariable>!!!:#v ( {Special}:hx {{#v}} HX_CONCRETE$$:unwrap:{n} <HxAttributes> | <PresortedVariableIs #v> ) .
%{
/* <PresortedVariableIs #variable> */
net.sf.crsx.Sink N_PresortedVariableIs(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env, net.sf.crsx.util.Buffer variable_b) :
{Token t = null;}{⟦
« JJ-Construction[%n⟨hx("VariableUseSorted")⟩, TextJoin[(
    JJ-StringLiteral[%n⟨storedSort⟩];
    JJ-Construction[%n⟨hx("RepeatSingle")⟩, %n⟨⟩];
    %n⟨{sink = variable_b.term(true).copy(sink, true, net.sf.crsx.util.LinkedExtensibleMap.EMPTY_RENAMING);}⟩;
    JJ-Nonterminal[%n⟨sink⟩, "HxAttributes", %n⟨env⟩];),
    %n⟨¶⟩]] »
{return sink;}⟧
}

/* <PresortedMetaApplication> ::= */
net.sf.crsx.Sink N_PresortedMetaApplication$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) : {}{ « JJ-Nonterminal[%n⟨sink⟩, "PresortedMetaApplication", %n⟨env⟩] » <EOF> {return sink;} }
net.sf.crsx.Sink N_PresortedMetaApplication(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{Token t = null;}{⟦
« JJ-Construction[%n⟨hx("MetaApplicationSorted")⟩, TextJoin[(
    JJ-StringLiteral[%n⟨storedSort⟩];
    JJ-Construction[%n⟨hx("RepeatSingle")⟩, %n⟨⟩];
    JJ-Nonterminal[%n⟨sink⟩, "HxMetaVariable", %n⟨env⟩];
    JJ-Nonterminal[%n⟨sink⟩, "BracketedTerms", %n⟨env⟩];
    JJ-Nonterminal[%n⟨sink⟩, "HxAttributes", %n⟨env⟩];),
    %n⟨¶⟩]] »{return sink;}⟧
}

/* <PresortedParsed> ::= */
net.sf.crsx.Sink N_PresortedParsed$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) : {}{ « JJ-Nonterminal[%n⟨sink⟩, "PresortedParsed", %n⟨env⟩] » <EOF> {return sink;} }
net.sf.crsx.Sink N_PresortedParsed(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{Token t = null;}{⟦
{sink = sink.start(makeTConstructor(sink, null, "C-AttributeWrapperSorted", null));}
« JJ-StringLiteral[%n⟨storedSort⟩]
»t=<T_HX_CONCRETE>
{
  try {sink = factory.parser(factory).parse(sink, (storedSort.startsWith("Computed") ? "prelude_" : "†« P-Embed-Prefix[#ModuleName] »")+storedSort, new java.io.StringReader(unwrap(t.toString())), unit, t.beginLine, t.beginColumn+1, env);}
  catch (java.io.IOException e) {throw new ParseException(e.getMessage());}
  catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) throw (ParseException) cause; else throw new ParseException(e.getMessage());}
}
« JJ-Nonterminal[%n⟨sink⟩, "HxAttributes", %n⟨env⟩] »
{return sink.end();}⟧
}

/* <SortedTerm> ::= stand-alone term with explicit or implied sort. */
net.sf.crsx.Sink N_SortedTerm$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) : {}{ « JJ-Nonterminal[%n⟨sink⟩, "SortedTerm", %n⟨env⟩] » <EOF> {return sink;} }
net.sf.crsx.Sink N_SortedTerm(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{⟦
String savedSort;
net.sf.crsx.util.Buffer b = new net.sf.crsx.util.Buffer(sink);
net.sf.crsx.Sink s = null;⟧
}{⟦
( « If[HasNames[#SortsWithUserConstructors], TextConcat[JJ-Nonterminal[%n⟨sink⟩, "Construction", %n⟨env⟩], %n⟨
| ⟩], %n⟨⟩] »⟦{s = b.sink();}
« JJ-Nonterminal[%n⟨s⟩, "HxSortName", %n⟨env⟩]
»{savedSort = storedSort; storedSort = net.sf.crsx.util.Util.symbol(b.term(true));}
( « JJ-Nonterminal[%n⟨sink⟩, "PresortedVariable", %n⟨env⟩] »« If[HasNames[#SortsWithUserConstructors], TextConcat[%n⟨
| ⟩, JJ-Nonterminal[%n⟨sink⟩, "Construction", %n⟨env⟩]], %n⟨⟩] »
| « JJ-Nonterminal[%n⟨sink⟩, "PresortedMetaApplication", %n⟨env⟩] »
| « JJ-Nonterminal[%n⟨sink⟩, "PresortedParsed", %n⟨env⟩] »
)
{storedSort = savedSort;}⟧
)
{return sink;}⟧
}
%}

« IfThen[HasNames[#SortsWithUserConstructors], ok.{#DM}P-then-Construction[ok], ok.%n⟨⟩] »
<BracketedTerms> ::= ( HX_LBRACKET (<Terms> | {$Nil}) HX_RBRACKET | {$Nil} ) .
<Terms> ::= {$Cons} <Term> (HX_COMMA <Terms> | {$Nil}) .

<Term> ::= <SortedTerm> | {VariableUse}:hx <HxVariable>!!! <HxAttributes> .

%{
net.sf.crsx.Sink N_Attribute$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) : {}{ « JJ-Nonterminal[%n⟨sink⟩, "Attribute", %n⟨env⟩] » <EOF> {return sink;} }
net.sf.crsx.Sink N_Attribute(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{Token a = null, t = null;}{⟦
(« {#DM} P-MetaJJ-AttributeAlternatives[#ModuleName, NameSetList[{#DM} U-AllSynthesizedNames], NameSetList[{#DM}U-AllInheritedNames]] »)
{return sink;}⟧
}
%}

<HxSystemAttribute> ::= {SystemAttribute}:hx HX_DOT <HxVariable> HX_LPAREN <HxTopPattern> HX_RPAREN .
***/

/* USER GRAMMAR. */

« {#DM}P-Productions[#ModuleName] »


/***METAPG:
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
%%%HXPOSTPRODUCTIONS%%%
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
***/

/***USERPG&EMBEDPG:
/* TOKENS. */

« P-Lexical[#Declarations, #ModuleName] »
***/
⟫
;

{$String : DeclarationMapEntry} P-then-Construction[Ok] :: Text ;
{#DM}P-then-Construction[OK]
→
%n⟪<Construction> ::= (⟦ « TextJoin[MapWhen[ok s.%n⟨<†‹ U-then-Local[ok,s] ›_Construction>⟩, FilterWhen[ok s. {#DM}U-then-SortHasUserHx[ok, s], NameSetList[{#DM}U-AllSortNames]]], %n⟨ | ⟩] »⟧ ).
⟫;

P-then-MetaSorts-ConstructionSortCaseText[Ok, $String<!--ModuleName-->, $String<!--Name-->, Text] :: Text ;

P-then-MetaSorts-ConstructionSortCaseText[OK, #ModuleName, #Name, #rest]
→
%n⟪†« U-QN[#ModuleName, "Node", #Name] »[†« U-QN[#ModuleName, "TagSort", #Name] », $List[†« U-QN[#ModuleName, "NodeSort", "Scope"] »]];
« #rest»⟫
;

{$String : DeclarationMapEntry} P-MetaJJ-AttributeAlternatives[$String, $List[$String], $List[$String]] :: Text ;

{#DM} P-MetaJJ-AttributeAlternatives[#ModuleName, (), ()]
→
%n⟪ <T_HX_UP> (sink=N_HxSystemAttribute(sink, env) | « {#DM} P-MetaJJ-CatchAllAttributes[#ModuleName, %n⟨"AttributeKindUp"⟩] »)
⟫
;
{#DM} P-MetaJJ-AttributeAlternatives[#ModuleName, (#s1; #ss), ()]
→
%n⟪ <T_HX_UP> (⟦ sink=N_HxSystemAttribute(sink, env) | « {#DM} P-MetaJJ-CatchAllAttributes[#ModuleName, %n⟨"AttributeKindUp"⟩] »
| a=<T_HX_VAR> (⟦« {#DM} P-MetaJJ-AttributeBodies[#ModuleName, (#s1; #ss)] »⟧)⟧)
⟫
;
{#DM} P-MetaJJ-AttributeAlternatives[#ModuleName, (), (#i1; #is)]
→
%n⟪ <T_HX_UP> (⟦ sink=N_HxSystemAttribute(sink, env) | « {#DM} P-MetaJJ-CatchAllAttributes[#ModuleName, %n⟨"AttributeKindUp"⟩] »⟧)
| <T_HX_DOWN> a=<T_HX_VAR> (⟦« {#DM} P-MetaJJ-AttributeBodies[#ModuleName, (#i1; #is)] »⟧)
⟫
;
{#DM} P-MetaJJ-AttributeAlternatives[#ModuleName, (#s1; #ss), (#i1; #is)]
→
%n⟪ <T_HX_UP> (⟦ sink=N_HxSystemAttribute(sink, env) | « {#DM} P-MetaJJ-CatchAllAttributes[#ModuleName, %n⟨"AttributeKindUp"⟩] »
| a=<T_HX_VAR> (« {#DM} P-MetaJJ-AttributeBodies[#ModuleName, (#s1; #ss)] »)⟧)
| <T_HX_DOWN> a=<T_HX_VAR> (⟦« {#DM} P-MetaJJ-AttributeBodies[#ModuleName, (#i1; #is)] »⟧)
⟫
;

{$String : DeclarationMapEntry} P-MetaJJ-CatchAllAttributes[$String, Text] :: Text ;
{#DM} P-MetaJJ-CatchAllAttributes[#ModuleName, #kind]
→
%n⟪⟦ {sink = sink.start(makeTConstructor(sink, a, hx("CatchAllAttributes"), null)).start(makeTConstructor(sink, a, hx(«#kind»), null)) .end();}
sink=N_HxMetaVariable(sink, env)
{sink = sink.end();} ⟧⟫
;

{$String : DeclarationMapEntry} P-MetaJJ-AttributeBodies[$String, $List[$String]] :: Text ;
{#DM} P-MetaJJ-AttributeBodies[#ModuleName, (#Name; #Names)]
→
{#DM} P-MetaJJ-AttributeBodies2[#ModuleName, (#Name; #Names), ""]
;

{$String : DeclarationMapEntry} P-MetaJJ-AttributeBodies2[$String, $List[$String], $String] :: Text ;

-[Data[#Name]]:
{#DM} P-MetaJJ-AttributeBodies2[#ModuleName, (#Name; #Names), #sep]
→
%n⟪†«#sep»« P-MetaJJ-AttributeBody[#ModuleName, #Name, $[{#DM}Get, #Name, DME_NONE]] »« {#DM}P-MetaJJ-AttributeBodies2[#ModuleName, #Names, "| "] »⟫
;

{#DM} P-MetaJJ-AttributeBodies2[#ModuleName, (), #sep]
→
%n⟪⟫
;

P-MetaJJ-AttributeBody[$String<!--ModuleName-->, $String<!--Name-->, DeclarationMapEntry] :: Text ;

P-MetaJJ-AttributeBody[#ModuleName, #Name, DME_ATTRIBUTE[#AttributeKind, #AttributeName, #AttributeForm, #AttributeOptions]]
→
%n⟪⟦ LOOKAHEAD( {"†« U-Local[#AttributeName] »".equals(a.toString())} )
sink=N_Attribute« AttributeKindCategory[#AttributeKind] »_†«#AttributeName»(sink, env)⟧
⟫
;

P-MetaJJ-AttributeBody[#ModuleName, #Name, $[NotMatch,DME_ATTRIBUTE[#AttributeKind, #AttributeName, #AttributeForm, #AttributeOptions],#_]]
→
PrepError[$[:,"Inconsistent attribute...",#Name]]
;

// ALTERNATE TOP LEVEL:

P-GetModuleName[HxModule] :: Text;
P-GetModuleName[%rawHxModule⟦ module #HxModuleName# { #HxDeclarations# } ⟧]
→
%n⟪†«$[Replace,#HxModuleName#,"\"",""]»⟫
;

P-PrintEnvironment[HxModule] :: Text;
P-PrintEnvironment[%rawHxModule⟦ module #HxModuleName# { #HxDeclarations# } ⟧]
→
Prep1[#HxModuleName#, U-ResolveImports[#HxDeclarations#, #HxModuleName#, "raw"], dm ds.P2Print[dm, ds, #HxModuleName#]]
;

P2Print[DeclarationMap, $List[HxDeclaration], $String<!--ModuleName-->] :: Text ;
-[Data[#ModuleName]]:
P2Print[{#DM}DM, #Declarations, #ModuleName]
→
%n⟪MODULE='†« $[Replace,#ModuleName,"\"",""] »'
NAME='†« U-LastName[#ModuleName] »'
SORT='†« U-Local[{#DM}U-MainSymbol]  »'
SORTS='†« U-Local[{#DM}U-MainSymbol] »« TextJoin[MapWhen[ok n.%n⟨ †‹U-then-Local[ok,n]›⟩, {#DM}U-NonMainSymbols], %n⟨⟩] »'
SINKCLASS='net.sf.crsx.text.TextSink'
PARSERCLASS='†« U-ClassName[#ModuleName] »Parser'
PREFIX='†« P-User-Prefix[#ModuleName] »'
METAPARSERCLASS='†« U-ClassName[#ModuleName] »Hx'
METAPREFIX='†« P-Meta-Prefix[#ModuleName] »'
EMBEDPARSERCLASS='†« U-ClassName[#ModuleName] »Embed'
EMBEDPREFIX='†« P-Embed-Prefix[#ModuleName] »'
⟫
;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 2. GENERATE TEXT OF ALL NON-TERMINAL PRODUCTIONS.
//
// Productions are extracted by sort and for each sort grouped by precedence,
// each group producing a P production.

// Iterate through all productions.

{$String<!--SortName--> : DeclarationMapEntry} P-Productions[$String<!--ModuleName-->] :: Text;
{#DM} P-Productions[#ModuleName] → {#DM} P-Productions0[#ModuleName, {#DM} U-AllNames] ;

{$String<!--SortName--> : DeclarationMapEntry} P-Productions0[$String<!--ModuleName-->, NameSet] :: Text;
{#DM} P-Productions0[#ModuleName, #Names] → {#DM} P-Productions1[HasNames[#Names], #ModuleName, #Names] ;

{$String<!--SortName--> : DeclarationMapEntry} P-Productions1[Boolean, $String<!--ModuleName-->, NameSet] :: Text;
{#DM} P-Productions1[B_TRUE , #ModuleName, #Names] → %n⟪« {#DM} P-Production[#ModuleName, FirstName[#Names]] »« {#DM} P-Productions0[#ModuleName, RemoveFirstName[#Names]] »⟫ ;
{#DM} P-Productions1[B_FALSE, #ModuleName, #Names] → %n⟪⟫ ;

// Emit productions for one declaration.

{$String<!--Name--> : DeclarationMapEntry} P-Production[$String<!--ModuleName-->, $String<!--Name-->] :: Text;
-[Data[#Name]]:
{#DM} P-Production[#ModuleName, #Name]
→
{#DM} P-Production1[#ModuleName, $[{#DM}Get[DeclarationMapEntry], #Name, DME_NONE]]
;

{$String<!--SortName--> : DeclarationMapEntry} P-Production1[$String<!--ModuleName-->, DeclarationMapEntry] :: Text;

// Dummy.

{#DM} P-Production1[#ModuleName, DME_NONE]
→
%n⟪⟫
;

// Token declaration.

{#DM}
P-Production1[#ModuleName, DME_TOKEN[#SortName]]
→
%n⟪
/* Productions for †«#SortName» token. */

/***USERPG&EMBEDPG:
<†« U-Local[#SortName] »> ::= ⟦/***EMBEDPG:‹ P-Embed-Head[B_TRUE, B_TRUE, #ModuleName, #SortName, #SortName, B_FALSE, 0]›***/ (‹P-TokenNameText[#SortName]›$)⟧ .
***/
/***EMBEDPG:
« P-Embed-Tail[B_TRUE, #SortName, #SortName] »
***/

/***METAPG:
/* <†« U-Local[#SortName] »> covers Hacs terms restricted to †«#SortName» token sort. */
%{
net.sf.crsx.Sink N_†« U-Local[#SortName] »$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) : {}{ sink=N_†« U-Local[#SortName] »(sink, env) <EOF> {return sink;} }
net.sf.crsx.Sink N_†« U-Local[#SortName] »(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{String savedSort;}{
  {savedSort = storedSort; storedSort = "†« U-Local[#SortName] »";}
  ( "†« U-Local[#SortName] »" )?
  ( « JJ-Nonterminal[%n⟨sink⟩, "PresortedVariable", %n⟨env⟩] »
  | « JJ-Nonterminal[%n⟨sink⟩, "PresortedMetaApplication", %n⟨env⟩] »
  | « JJ-Nonterminal[%n⟨sink⟩, "PresortedParsed", %n⟨env⟩] »
  )
  {storedSort = savedSort;}
  {return sink;}
}
%}
***/
⟫
;

// Attribute declaration.

{#DM} P-Production1[#ModuleName, DME_ATTRIBUTE[#Kind, #Name, #AttributeForm, #AttributeOptions]]
→
%n⟪
/***METAPG:
/* Productions for †«#Name» attribute. */
%{
« P-MetaJJ-Production-Attribute[#ModuleName, #Kind, #Name, #AttributeForm, #AttributeOptions] »
%}
***/
⟫;

    // Handle an attribute definition.

    P-MetaJJ-Production-Attribute[$String<!--ModuleName-->, HxAttributeKind, $String, HxAttributeForm, $List[HxAttributeOption]] :: Text;
    P-MetaJJ-Production-Attribute[#ModuleName, #Kind, #Name, #AttributeForm, #AttributeOptions]
    →
    %n⟪
/* <Attribute« AttributeKindCategory[#Kind] »_†«#Name»> ::= ... */
net.sf.crsx.Sink N_Attribute« AttributeKindCategory[#Kind] »_†«#Name»(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{Token t = null;}
{
  {sink = sink.start(makeTConstructor(sink, null, hx("Attribute"), null));}
  {sink = sink.start(makeTConstructor(sink, null, hx("« AttributeKindIndicator[#Kind] »"), null)).end();}
  « JJ-StringLiteral[%n⟨"†‹#Name›"⟩] »⟦« P-MetaJJ-AttributeFormSyntax[#ModuleName, #AttributeForm, #AttributeOptions] »⟧
  {return sink.end();}
}
⟫;

    AttributeKindCategory[HxAttributeKind] :: Text ;
    AttributeKindCategory[%rawHxAttributeKind⟪ ↑ ⟫] → %n⟪Synthesized⟫ ;
    AttributeKindCategory[%rawHxAttributeKind⟪ ↓ ⟫] → %n⟪Inherited⟫ ;

    AttributeKindIndicator[HxAttributeKind] :: Text ;
    AttributeKindIndicator[%rawHxAttributeKind⟪ ↑ ⟫] → %n⟪AttributeKindUp⟫ ;
    AttributeKindIndicator[%rawHxAttributeKind⟪ ↓ ⟫] → %n⟪AttributeKindDown⟫ ;

    P-MetaJJ-AttributeFormSyntax[$String<!--ModuleName-->, HxAttributeForm, $List[HxAttributeOption]] :: Text ;
    P-MetaJJ-AttributeFormSyntax[#ModuleName, %rawHxAttributeForm⟪ ( #HxSort# ) ⟫, #AttributeOptions]
    →
    %n⟪« JJ-Token["HX_LPAREN"] »« JJ-Construction[%n⟨hx("AttributeValue")⟩, JJ-Nonterminal[%n⟨sink⟩, U-SortName[#HxSort#], %n⟨env⟩]] »« JJ-Token["HX_RPAREN"] »⟫
    ;
    P-MetaJJ-AttributeFormSyntax[#ModuleName, %rawHxAttributeForm⟪ { #HxSort# } ⟫, #AttributeOptions]
    →
    %n⟪« JJ-Token["HX_LBRACE"] »(⟦«
        JJ-Construction[%n⟨hx("AttributeKey")⟩, JJ-Nonterminal[%n⟨sink⟩, U-SortName[#HxSort#], %n⟨env⟩]]
      »⟧|⟦«
        JJ-Token["HX_NOT"] » « JJ-Construction[%n⟨hx("AttributeNotKey")⟩, JJ-Nonterminal[%n⟨sink⟩, U-SortName[#HxSort#], %n⟨env⟩]]
      »⟧|⟦«
        JJ-Token["HX_COLON"] » « JJ-Construction[%n⟨hx("AttributeCatchAll")⟩, JJ-Nonterminal[%n⟨sink⟩, "HxMetaVariable", %n⟨env⟩]]
      »⟧|⟦«
        JJ-Construction[%n⟨hx("AttributeNoKeyValue")⟩, %n⟨⟩]
      »⟧)« JJ-Token["HX_RBRACE"] »⟫
    ;
    P-MetaJJ-AttributeFormSyntax[#ModuleName, %rawHxAttributeForm⟪ { #HxSort1# : #HxSort2# } ⟫, #AttributeOptions]
    →
    %n⟪« JJ-Token["HX_LBRACE"] »(⟦«
	JJ-Construction[%n⟨hx("AttributeKeyValue")⟩,
	  MapTextConcat[t.t, (
	    JJ-Nonterminal[%n⟨sink⟩, U-SortName[#HxSort1#], %n⟨env⟩];
	    JJ-Token["HX_COLON"];
	    JJ-Nonterminal[%n⟨sink⟩, U-SortName[#HxSort2#], %n⟨env⟩];
	)]]
      »⟧|⟦«
        JJ-Token["HX_NOT"] » « JJ-Construction[%n⟨hx("AttributeNotKey")⟩, JJ-Nonterminal[%n⟨sink⟩, U-SortName[#HxSort1#], %n⟨env⟩]]
      »⟧|⟦«
        JJ-Token["HX_COLON"] » « JJ-Construction[%n⟨hx("AttributeCatchAll")⟩, JJ-Nonterminal[%n⟨sink⟩, "HxMetaVariable", %n⟨env⟩]]
      »⟧|⟦«
        JJ-Construction[%n⟨hx("AttributeNoKeyValue")⟩, %n⟨⟩]
      »⟧)« JJ-Token["HX_RBRACE"] »⟫
    ;

// Sort declaration.

{#DM} P-Production1[#ModuleName, DME_SORT[#Defines, #SortName, #Precs, #Wrapper, #IsMain]]
→
%n⟪« {#DM} P-Production-Defines[#ModuleName, #Defines, #SortName, 0, ()] »
/***METAPG:
%{
« {#DM} P-MetaJJ-Production-Defines[#ModuleName, #Defines, #SortName, {#DM}U-then-SortHasUserHx[OK, #SortName]] »
%}
***/⟫
;

// Helper for ParsedForm and FK.
PFK_SORT ::=( PFK[HxParsedForm, FormKind]; );

// Handle a sort definition.

{$String<!--SortName--> : DeclarationMapEntry} P-Production-Defines[$String<!--ModuleName-->, $List[Define], $String<!--SortName-->, $Numeric<!--Prec-->, $List[PFK_SORT]] :: Text;

{#DM} P-Production-Defines[#ModuleName, (), #SortName, #Prec, ()]
→
%n⟪/***EMBEDPG:
/* Productions for †«#SortName» sort with (highest) precedence †«$[FormatNumber,#Prec]». */

<«P-ProductionNameWithPrecText[#SortName,#Prec]»> ::= « P-Embed-Head[B_TRUE, B_FALSE, #ModuleName, #SortName, #SortName, B_FALSE, #Prec] » .
« P-Embed-Tail[B_TRUE, #SortName, #SortName] »***/⟫
;

{#DM} P-Production-Defines[#ModuleName, (), #SortName, #Prec, (#PFK1;#PFKs)]
→
%n⟪

/* Productions for †«#SortName» sort with (highest) precedence †«$[FormatNumber,#Prec]». */
« {#DM} P-Expand[#ModuleName, (#PFK1;#PFKs), #SortName, #Prec, B_TRUE] »
⟫
;

-[Fresh[dummy::HxSortParam]]:
{#DM} P-Production-Defines[#ModuleName, (D_ABSTRACTION[a.#Define1[a]]; #Defines), #SortName, #Prec, #PrecPFKs]
→
{#DM} P-Production-Defines[#ModuleName, (#Define1[dummy]; #Defines), #SortName, #Prec, #PrecPFKs]
;

{#DM} P-Production-Defines[#ModuleName, (D_RULE[#Rule, #RuleSort, #IsData]; #Defines), #SortName, #Prec, #PrecPFKs]
→
{#DM} P-Production-Defines[#ModuleName, #Defines, #SortName, #Prec, #PrecPFKs]
;

{#DM} P-Production-Defines[#ModuleName, (D_FORM[#Form1, #Kind1]; #Defines), #SortName, #Prec, #PrecPFKs]
→
{#DM} P-Production-Defines2[#ModuleName, #Form1, #Kind1, #Defines, #SortName, #Prec, #PrecPFKs]
;

{#DM} P-Production-Defines[#ModuleName, (D_SYNTHESIZES[#AttributeName1]; #Defines), #SortName, #Prec, #PrecPFKs]
→
{#DM} P-Production-Defines[#ModuleName, #Defines, #SortName, #Prec, #PrecPFKs]
;

{$String<!--SortName--> : DeclarationMapEntry} P-Production-Defines2[$String<!--ModuleName-->, HxForm, FormKind, $List[Define], $String<!--SortName-->, $Numeric, $List[PFK_SORT]] :: Text;

{#DM} P-Production-Defines2[#ModuleName, Hx_FormParsed[#ParsedForm1, #Prec1, #InheritedRefs], #Kind1, #Defines, #SortName, #Prec, #PrecPFKs]
→
{#DM} P-Production-Defines3[#ModuleName, #ParsedForm1, StringToNumericDefault[#Prec1,0], #Kind1, #Defines, #SortName, #Prec, #PrecPFKs]
;

{#DM} P-Production-Defines2[#ModuleName, Hx_FormConstruction[#Constructor, #ScopeSortList, #InheritedRefs], #Kind1, #Defines, #SortName, #Prec, #PrecPFKs]
→
{#DM} P-Production-Defines[#ModuleName, #Defines, #SortName, #Prec, #PrecPFKs]
;

{$String<!--SortName--> : DeclarationMapEntry} P-Production-Defines3[$String<!--ModuleName-->, HxParsedForm, $Numeric, FormKind, $List[Define], $String, $Numeric, $List[PFK_SORT]] :: Text;

-[Data[#Prec1,#Prec],Share[#ParsedForm1,#Kind1,#Defines]]:
{#DM} P-Production-Defines3[#ModuleName, #ParsedForm1, #Prec1, #Kind1, #Defines, #SortName, #Prec, ()]
→
$[If, $[NumericEqual,#Prec1,#Prec],
  {#DM} P-Production-Defines[#ModuleName, #Defines, #SortName, #Prec, (PFK[#ParsedForm1, #Kind1];)],
  %n⟪
<«P-ProductionNameWithPrecText[#SortName,#Prec]»> ::= <«P-ProductionNameWithPrecText[#SortName,#Prec1]»> .
« {#DM} P-Production-Defines[#ModuleName, #Defines, #SortName, #Prec1, (PFK[#ParsedForm1, #Kind1];)] »⟫]
;

-[Data[#Prec1,#Prec],Share[#ParsedForm1,#Kind1,#Defines,#PFK,#PFKs]]:
{#DM} P-Production-Defines3[#ModuleName, #ParsedForm1, #Prec1, #Kind1, #Defines, #SortName, #Prec, (#PFK;#PFKs)]
→
$[If, $[NumericEqual,#Prec1,#Prec],
  {#DM} P-Production-Defines[#ModuleName, #Defines, #SortName, #Prec, Append[(#PFK;#PFKs), (PFK[#ParsedForm1, #Kind1];)]],
  %n⟪/***USERPG&EMBEDPG:
/* Productions for †«#SortName» sort with precedence †«$[FormatNumber,#Prec]». */
« {#DM} P-Expand[#ModuleName, (#PFK;#PFKs), #SortName, #Prec, B_FALSE] »
***/
« {#DM} P-Production-Defines[#ModuleName, #Defines, #SortName, #Prec1, (PFK[#ParsedForm1, #Kind1];)] »
⟫]
;

// Production definitions for MetaJJ.

{$String<!--SortName--> : DeclarationMapEntry} P-MetaJJ-Production-Defines[$String<!--ModuleName-->, $List[Define], $String<!--SortName-->, Boolean<!--HasHxConstructors-->] :: Text;

{#DM}
P-MetaJJ-Production-Defines[#ModuleName, #Defines, #SortName, B_TRUE]
→
%n⟪
/* <†« U-Local[#SortName] »> covers Hacs terms prerestricted to †«#SortName» user sort (including user naked terms). */
net.sf.crsx.Sink N_†« U-Local[#SortName] »$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) : {}{ sink=N_†« U-Local[#SortName] »(sink, env) <EOF> {return sink;} }
net.sf.crsx.Sink N_†« U-Local[#SortName] »(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{String savedSort; Token t = null;}{
  (
    sink=N_†« U-Local[#SortName] »_Construction(sink, env)
  |
    {savedSort = storedSort; storedSort = "†« U-Local[#SortName] »";}
    ( « JJ-Nonterminal[%n⟨sink⟩, "PresortedVariable", %n⟨env⟩] »
    | « JJ-Nonterminal[%n⟨sink⟩, "PresortedMetaApplication", %n⟨env⟩] »
    | « JJ-Nonterminal[%n⟨sink⟩, "PresortedParsed", %n⟨env⟩] »
    | "†« U-Local[#SortName] »"
      ( « JJ-Nonterminal[%n⟨sink⟩, "PresortedVariable", %n⟨env⟩] »« If[HasNames[FilterNamesWhen[ok s.{#DM}U-then-SortHasUserHx[ok, s], {#DM}U-AllSortNames]], TextConcat[%n⟨
      | ⟩, JJ-Nonterminal[%n⟨sink⟩, "Construction", %n⟨env⟩]], %n⟨⟩] »
      | « JJ-Nonterminal[%n⟨sink⟩, "PresortedMetaApplication", %n⟨env⟩] »
      |  « JJ-Nonterminal[%n⟨sink⟩, "PresortedParsed", %n⟨env⟩] »
    ))
    {storedSort = savedSort;}
  )
  {return sink;}
}

/* <†« U-Local[#SortName]»_Construction> covers just Hacs user terms of †«#SortName» sort. */
net.sf.crsx.Sink N_†« U-Local[#SortName] »_Construction$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) : {}{ sink=N_†« U-Local[#SortName] »_Construction(sink, env) <EOF> {return sink;} }
net.sf.crsx.Sink N_†« U-Local[#SortName] »_Construction(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{ net.sf.crsx.util.Buffer b = null; net.sf.crsx.Sink s = null; java.util.ArrayList<String> bs = null; java.util.ArrayList<net.sf.crsx.Variable> vs = null; Token t = null;}{⟦
( ⟦« {#DM} P-MetaJJ-Production-Defines1[#ModuleName, #Defines, #SortName, ""] » ⟧)
{return sink;}⟧
}
⟫;

{#DM}
P-MetaJJ-Production-Defines[#ModuleName, #Defines, #SortName, B_FALSE]
→
%n⟪
/* <†« U-Local[#SortName] »> covers Hacs terms restricted to †«#SortName» user sort (no naked terms). */
net.sf.crsx.Sink N_†« U-Local[#SortName] »$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) : {}{ sink=N_†« U-Local[#SortName] »(sink, env) <EOF> {return sink;} }
net.sf.crsx.Sink N_†« U-Local[#SortName] »(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{String savedSort; Token t = null;}{
  {savedSort = storedSort; storedSort = "†« U-Local[#SortName] »";}
  ( t="†« U-Local[#SortName] »" )?
  ( « JJ-Nonterminal[%n⟨sink⟩, "PresortedVariable", %n⟨env⟩] »
  | « JJ-Nonterminal[%n⟨sink⟩, "PresortedMetaApplication", %n⟨env⟩] »
  | « JJ-Nonterminal[%n⟨sink⟩, "PresortedParsed", %n⟨env⟩] »
  )
  {storedSort = savedSort;}
  {return sink;}
}
⟫;

//

{$String<!--SortName--> : DeclarationMapEntry} P-MetaJJ-Production-Defines1[$String<!--ModuleName-->, $List[Define], $String<!--SortName-->, $String<!--lead-->] :: Text;

-[Fresh[dummy::HxSortParam]]:
{#DM} P-MetaJJ-Production-Defines1[#ModuleName, (D_ABSTRACTION[a.#Define1[a]]; #Defines), #SortName, #lead]
→
{#DM} P-MetaJJ-Production-Defines1[#ModuleName, (#Define1[dummy]; #Defines), #SortName, #lead]
;

{#DM} P-MetaJJ-Production-Defines1[#ModuleName, (D_RULE[#Rule, #RuleSort, #IsData]; #Defines), #SortName, #lead]
→
{#DM} P-MetaJJ-Production-Defines1[#ModuleName, #Defines, #SortName, #lead]
;

{#DM} P-MetaJJ-Production-Defines1[#ModuleName, (D_FORM[#Form1, #Kind1]; #Defines), #SortName, #lead]
→
{#DM} P-MetaJJ-Production-HxForm[#ModuleName, #Form1, #Kind1, #SortName, #lead, lead.{#DM} P-MetaJJ-Production-Defines1[#ModuleName, #Defines, #SortName, lead]]
;

{#DM} P-MetaJJ-Production-Defines1[#ModuleName, (D_SYNTHESIZES[#AttributeName1]; #Defines), #SortName, #lead]
→
{#DM} P-MetaJJ-Production-Defines1[#ModuleName, #Defines, #SortName, #lead]
;

{#DM} P-MetaJJ-Production-Defines1[#ModuleName, (), #SortName, #lead]
→
%n⟪⟫
;

// Generate JJ parser instructions for meta-fragment of a HACS Form.

{$String<!--SortName--> : DeclarationMapEntry} P-MetaJJ-Production-HxForm[$String<!--ModuleName-->, HxForm, FormKind, $String<!--SortName-->, $String<!--lead-->, l::$String . Text] :: Text;
{#DM} P-MetaJJ-Production-HxForm[#ModuleName, Hx_FormParsed[#ParsedForm1, #Prec1, #InheritedRefs], #Kind1, #SortName, #lead, lead.#[lead]] → #[#lead] ;
{#DM} P-MetaJJ-Production-HxForm[#ModuleName, Hx_FormConstruction[#Constructor, #ScopeSortList, #InheritedRefs], #Kind1, #SortName, #lead, lead.#[lead]]
→
%n⟪†«#lead» (⟦ « {#DM} P-MetaJJ-Production-HxFormConstruction[#ModuleName, #SortName, #Constructor, #ScopeSortList] » ⟧)
« #["|"] »⟫
;

    // Handle one construction form.

    {$String<!--SortName--> : DeclarationMapEntry} P-MetaJJ-Production-HxFormConstruction[$String<!--ModuleName-->, $String<!--SortName-->, $String<!--Constructor-->, $List[HxScopeSort]] :: Text ;
    {#DM} P-MetaJJ-Production-HxFormConstruction[#ModuleName, #SortName, #Constructor, #ScopeSortList]
    →
    TextJoin[(%n⟨ "†« U-Local[#Constructor] »" ⟩;
      JJ-Construction[%n⟨hx("ConstructionSorted")⟩, TextJoin[(
        JJ-StringLiteral[%n⟨"†« U-QN[#ModuleName, "", #SortName] »"⟩];
        JJ-Construction[%n⟨hx("RepeatSingle")⟩, %n⟨⟩];
        JJ-StringLiteral[%n⟨"†« U-QN[#ModuleName, #SortName, #Constructor] »"⟩];
        IfEmpty[#ScopeSortList,
          TextConcat[%n⟨(<T_HX_LPAREN> <T_HX_RPAREN>)? ⟩, JJ-Construction[%n⟨"$Nil"⟩, %n⟨⟩]],
          %n⟨<T_HX_LPAREN> ‹ {#DM} P-MetaJJ-Production-HxScopeSortList[#ModuleName, #ScopeSortList, #SortName, B_TRUE] › <T_HX_RPAREN>⟩];
        JJ-Nonterminal[%n⟨sink⟩, "HxAttributes", %n⟨env⟩];),%n⟨ ⟩]];),
      %n⟨ ⟩]
    ;

    // Handle the list of argument scope sorts.

    {$String<!--SortName--> : DeclarationMapEntry} P-MetaJJ-Production-HxScopeSortList[$String<!--ModuleName-->, $List[HxScopeSort], $String<!--SortName-->, Boolean<!--First-->] :: Text;

    {#DM} P-MetaJJ-Production-HxScopeSortList[#ModuleName, (#ScopeSort# ; #ScopeSortList), #SortName, #first]
    →
    TextConcat3[
      If[#first, %n⟪¶⟫, %n⟪¶<T_HX_COMMA>¶⟫],
      %n⟪{ bs = new java.util.ArrayList<String>(); vs= new java.util.ArrayList<net.sf.crsx.Variable>(); } ¶⟫,
      JJ-Construction[%n⟪"$Cons"⟫,
	%n⟪« {#DM} P-MetaJJ-Production-HxScopeSort[#ModuleName, #ScopeSort#, #SortName, %n⟨env⟩, 0]
	  » « {#DM} P-MetaJJ-Production-HxScopeSortList[#ModuleName, #ScopeSortList, #SortName, B_FALSE] »⟫]]
    ;
    // TODO: should not ignore #Repeat.

    {#DM} P-MetaJJ-Production-HxScopeSortList[#ModuleName, (), #SortName, #first] → JJ-Construction[%n⟪"$Nil"⟫, %n⟪⟫] ;

    // Handle each argument scope sort.

    {$String<!--SortName--> : DeclarationMapEntry} P-MetaJJ-Production-HxScopeSort[$String<!--ModuleName-->, HxScopeSort, $String<!--SortName-->, Text<!--Environment-->, $Numeric<!--ArgCount-->] :: Text;

    {#DM} P-MetaJJ-Production-HxScopeSort[#ModuleName, %rawHxBindersScopeSort⟪ [ v ] #HxBindersScopeSort# ⟫, #SortName, #env, #n]
    →
    %n⟪{ b = new net.sf.crsx.util.Buffer(sink); s = b.sink(); }
N_HxVariable(s, env)
{ String ‹v› = net.sf.crsx.util.Util.symbol(b.term(true)); bs.add(‹v›); vs.add(sink.makeVariable(‹v›, true)); }
« {#DM} P-MetaJJ-Production-HxScopeSort[#ModuleName, #HxBindersScopeSort#, #SortName, %n⟨‹#env›.extend(bs.get(†‹ $[FormatNumber,#n] ›), vs.get(†‹ $[FormatNumber,#n] ›))⟩, $[Plus,#n,1]]
    »⟫;

    {#DM} P-MetaJJ-Production-HxScopeSort[#ModuleName, %rawHxScopeSort⟪ #HxSort# #HxRepeat# [ #HxSubstituteSorts# ] ⟫, #SortName, #env, #n]
    →
    JJ-Construction[%n⟪hx("Scope")⟫, %n⟪« JJ-Construction[%n⟨"$Nil"⟩, %n⟨⟩] »¶{sink=sink.binds(vs.toArray(new net.sf.crsx.Variable[vs.size()]));} ¶« JJ-Nonterminal[%n⟨sink⟩, U-SortName[#HxSort#], #env] »⟫]
    ;
    // TODO: should not ignore #Repeat.

// Meta-definitions for sorts.

P-Embed-Head[Boolean<!--Last?-->, Boolean<!--Followed?-->, $String<!--ModuleName-->, $String, $String, Boolean<!--LeftRecursive?-->, $Numeric<!--Prec-->] :: Text;

P-Embed-Head[B_FALSE, #followed, #ModuleName, #SortName, #Name, #isLeftRecursive, #Prec] → %n⟪⟫ ;

-[Data[#SortName],Discard[#Prec]]:
P-Embed-Head[B_TRUE, #followed, #ModuleName, #SortName, #Name, B_FALSE, #Prec] →
 %n⟪
meta_« P-TokenNameText[#Name] »$$:unwrap:{†« P-Meta-Prefix[#ModuleName] »SortedTerm}« If[#followed, %n⟨ |⟩, %n⟨⟩] »
⟫ ;

-[Data[#SortName]]:
P-Embed-Head[B_TRUE, #followed, #ModuleName, #SortName, #Name, B_TRUE, #Prec] →
 %n⟪
meta_« P-TokenNameText[#Name] »$$:unwrap:{†« P-Meta-Prefix[#ModuleName] »SortedTerm}:#1 <« P-ProductionNameWithPrecText[#SortName, #Prec] »LR #1>« If[#followed, %n⟨ |⟩, %n⟨⟩] »
⟫ ;


P-Embed-Tail[Boolean, $String, $String] :: Text;

P-Embed-Tail[B_FALSE, #SortName, #Name] → %n⟪⟫ ;

-[Data[#SortName]]: P-Embed-Tail[B_TRUE, #SortName, #Name] → %n⟪
%{
/* Meta token for embedded user †«#SortName». */ 
MORE : { < "\u27e8" (" ")* †« Stringify[U-Local[#SortName]] » (" ")* ~["\u27e8","\u27e9"] > { nesting = 0; nestedState = curLexState; } : IN_META_«P-TokenNameText[#Name]» }
<IN_META_«P-TokenNameText[#Name]»> MORE : { "\u27e8" { nesting = 1; } : IN_NESTED_META_«P-TokenNameText[#Name]» }
<IN_NESTED_META_«P-TokenNameText[#Name]»> MORE : { "\u27e8" { nesting++; } }
<IN_NESTED_META_«P-TokenNameText[#Name]»> MORE : { "\u27e9" { if (--nesting <= 0) SwitchTo(IN_META_«P-TokenNameText[#Name]»); } }
<IN_META_«P-TokenNameText[#Name]»> TOKEN : { < T_meta_«P-TokenNameText[#Name]» : "\u27e9" > { SwitchTo(nestedState); } }
<IN_META_«P-TokenNameText[#Name]»,IN_NESTED_META_«P-TokenNameText[#Name]»> MORE : { < ~[] > }
%}
⟫ ;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 3. GENERATE SINGLE SORT/PRECEDENCE COMBINATION.
//
// Text of single sort+precedence production expansion.
//
// Emits the left recursion handler, if any, and the PG grammar production
// for the sort+precedence combination, with left factored buffering.

CONSUMPTION_SORT ::=( C_BUFFER[$String<!--SortName-->, $Numeric<!--precedence-->]; C_LEFTRECURSIVE[$String<!--SortName-->, $Numeric<!--precedence-->]; <!--C_INLINE;--> );
/// C_INLINE DISABLED.

{$String<!--SortName--> : DeclarationMapEntry} P-Expand[$String<!--ModuleName-->, $List[PFK_SORT], $String<!--SortName-->, $Numeric, Boolean<!--Last-->] :: Text;
{#DM} P-Expand[#ModuleName, #PrecPFKs, #SortName, #Prec, #Last?]
→
{#DM} P-LeftRecursive[#ModuleName, #PrecPFKs, #SortName, #Prec, #Last?, (), ()]
;

// Generate optional left recursion production helper, normal production, and optional meta-production.

{$String<!--SortName--> : DeclarationMapEntry} P-LeftRecursive[$String<!--ModuleName-->, $List[PFK_SORT], $String, $Numeric, Boolean, $List[PFK_SORT], $List[PFK_SORT]] :: Text;
{$String<!--SortName--> : DeclarationMapEntry} P-LeftRecursive2[$String<!--ModuleName-->, Boolean, PFK_SORT, $List[PFK_SORT], $String, $Numeric, Boolean, $List[PFK_SORT], $List[PFK_SORT]] :: Text;

{#DM} P-LeftRecursive[#ModuleName, (#PFK1; #PFKs), #SortName, #Prec, #Last?, #LeftRecursivePFKs, #OtherPFKs]
→
{#DM} P-LeftRecursive2[#ModuleName, P-isLeftRecursive[#SortName, #Prec, #PFK1], #PFK1, #PFKs, #SortName, #Prec, #Last?, #LeftRecursivePFKs, #OtherPFKs]
;

    // HAND-CODED HACK to recognize and strip left recursive production (because HxRaw.pg cannot match parsed forms...).

    P-isLeftRecursive[$String, $Numeric, PFK_SORT] :: Boolean;
    P-isLeftRecursive[#SortName, #Prec,#PFK] → P-isLeftRecursive1[#SortName, #Prec, #PFK] ;

    P-isLeftRecursive1[$String, $Numeric, PFK_SORT] :: Boolean;

    P-isLeftRecursive1[#SortName, #Prec, PFK[Hx_ParsedFormSpace[#Space, #ParsedForm1], #Kind]]
    →
    P-isLeftRecursive1[#SortName, #Prec, PFK[#ParsedForm1, #Kind]]
    ;

    P-isLeftRecursive1[#SortName, #Prec, PFK[Hx_ParsedFormWord[#Word, #ParsedForm1], #Kind]]
    →
    B_FALSE
    ;

    -[Data[#Sort]]:
    P-isLeftRecursive1[#SortName, #Prec, PFK[Hx_ParsedFormTerm[Hx_ScopeSortPrec[#Sort1, #Prec1], #ParsedForm1], #Kind]]
    →
    P-isLeftRecursive1b[#SortName, #Prec, #Sort1, StringToNumericDefault[#Prec1, 0]]
    ;
        P-isLeftRecursive1b[$String<!--SortName-->, $Numeric, HxScopeSort, $Numeric] :: Boolean ;
	-[Data[#Prec,#Prec1]]: P-isLeftRecursive1b[#SortName, #Prec, #Sort1, #Prec1] → $[If, $[NumericEqual,#Prec,#Prec1], P-isLeftRecursive2[#SortName, #Sort1], B_FALSE] ;

    P-isLeftRecursive1[#SortName, #Prec, PFK[Hx_ParsedFormDone, #Kind]]
    →
    B_FALSE
    ;

    P-isLeftRecursive2[$String, HxScopeSort] :: Boolean;

    P-isLeftRecursive2[#SortName,
      Hx_ScopeSort[
	Hx_Sort[Hx_SortName[#SortName1, #_1], $Nil],
	Hx_RepeatSingle,
	$Nil]]
    →
    SameString[U-Local[#SortName], U-Local[#SortName1]]
    ;

    -[Data[#Kind]]:
    P-isLeftRecursive2[#SortName, $[NotMatch,
      Hx_ScopeSort[
	Hx_Sort[Hx_SortName[#SortName1, #_1], $Nil],
	Hx_RepeatSingle,
	$Nil],#_]]
    →
    B_FALSE
    ;

    P-stripLeftRecursion[PFK_SORT] :: PFK_SORT;
    P-stripLeftRecursion[PFK[Hx_ParsedFormSpace[#Space, #ParsedForm1], #Kind]]
    →
    P-stripLeftRecursion[PFK[#ParsedForm1, #Kind]]
    ;
    P-stripLeftRecursion[
      PFK[
	Hx_ParsedFormTerm[
	  Hx_ScopeSortPrec[
	    Hx_ScopeSort[
	      Hx_Sort[Hx_SortName[#SortName, #_], $Nil],
	      Hx_RepeatSingle,
	      $Nil],
	    #Prec],
	  #ParsedForm],
	#Kind]]
    →
    PFK[#ParsedForm, #Kind]
    ;

{#DM} P-LeftRecursive2[#ModuleName, B_TRUE, #PFK1, #PFKs, #SortName, #Prec, #Last?, #LeftRecursivePFKs, #OtherPFKs]
→
{#DM} P-LeftRecursive[#ModuleName, #PFKs, #SortName, #Prec, #Last?, Append[#LeftRecursivePFKs, (P-stripLeftRecursion[#PFK1];)], #OtherPFKs]
;

{#DM} P-LeftRecursive2[#ModuleName, B_FALSE, #PFK1, #PFKs, #SortName, #Prec, #Last?, #LeftRecursivePFKs, #OtherPFKs]
→
{#DM} P-LeftRecursive[#ModuleName, #PFKs, #SortName, #Prec, #Last?, #LeftRecursivePFKs, Append[#OtherPFKs, (#PFK1;)]]
;

{#DM} P-LeftRecursive[#ModuleName, (), #SortName, #Prec, #Last?, #LeftRecursivePFKs, #OtherPFKs]
→
IfEmpty[#LeftRecursivePFKs,
  // There is no left recursion -- use the plain expansion.
  {#DM} P-Produce[#ModuleName, #SortName, #Prec, #Last?, #OtherPFKs, C_BUFFER[#SortName, #Prec]],
  // There is left recursion...
  {#DM} P-ProduceBody[#ModuleName, #SortName, #SortName, #LeftRecursivePFKs, 2, (), (%n⟨#1⟩;), (%n⟨/***EMBEDPG: C-UnravelScope_0[***/#1/***EMBEDPG:]***/⟩;), C_LEFTRECURSIVE[#SortName, #Prec], in after .
    %n⟪
/***USERPG&EMBEDPG:
/* Handle left recursion. */
<«P-ProductionNameWithPrecText[#SortName, #Prec]»LR #1> ::= ⟦
/***EMBEDPG: « P-Embed-Head[#Last?, B_TRUE, #ModuleName, #SortName, #SortName, B_FALSE, 0] »***/
«in»
| {{#1}}⟧
. ***/

« TextJoinMap[after, %n⟨
⟩] »
« {#DM} P-Produce[#ModuleName, #SortName, #Prec, #Last?, #OtherPFKs, C_LEFTRECURSIVE[#SortName, #Prec]] »⟫]]
;

// 

{$String<!--SortName--> : DeclarationMapEntry} P-Produce[$String<!--ModuleName-->, $String<!--SortName-->, $Numeric<!--Prec-->, Boolean<!--Last?-->, $List[PFK_SORT], CONSUMPTION_SORT] :: Text;

{#DM} P-Produce[#ModuleName, #SortName, #Prec, #Last?, #PFKs, C_BUFFER[#SortName, #Prec]]
→
{#DM} P-ProduceBody[#ModuleName, #SortName, "", #PFKs, 1, (), (), (), C_BUFFER[#SortName, #Prec], in after .
  %n⟪
/***USERPG&EMBEDPG:
<«P-ProductionNameWithPrecText[#SortName,#Prec]»> ::= ⟦
/***EMBEDPG: « P-Embed-Head[#Last?, B_TRUE, #ModuleName, #SortName, #SortName, B_FALSE, 0] »***/
«in»⟧ .
***/

/***EMBEDPG:
« P-Embed-Tail[#Last?, #SortName, #SortName] »« TextJoinMap[after, %n⟨
⟩] »
***/
⟫]
;

{#DM} P-Produce[#ModuleName, #SortName, #Prec, #Last?, #PFKs, C_LEFTRECURSIVE[#SortName9, #Prec9]]
→
{#DM} P-ProduceBody[#ModuleName, #SortName, "", #PFKs, 1, (), (), (), C_LEFTRECURSIVE[#SortName9, #Prec9], in after .
  %n⟪
/***USERPG&EMBEDPG:
<«P-ProductionNameWithPrecText[#SortName, #Prec]»> ::= ⟦
«in»⟧ .
***/

/***EMBEDPG:
« P-Embed-Tail[#Last?, #SortName, #SortName] »« TextJoinMap[after, %n⟨
⟩] »
***/
⟫]
;

// Handle part of parsing choice tree.

{$String<!--SortName--> : DeclarationMapEntry}
P-ProduceBody[$String<!--ModuleName-->, $String<!--HostSort-->, $String<!--tagprefix-->, $List[PFK_SORT], $Numeric<!--ArgIndex-->, $List[Text]<!--Words-->, $List[Text]<!--Terms-->, $List[Text]<!--Scopes-->, CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

{#DM} P-ProduceBody[#ModuleName, #SortName, #tagprefix, (), #n, #words, #terms, #scopes, #consumer, in after . #[in,after]]
→
#[%n⟪⟫, EmptyTextMap]
;

-[Data[#PFKs]]:
{#DM} P-ProduceBody[#ModuleName, #SortName, #tagprefix, (PFK[#Form, #Kind]; #Rest), #n, #words, #terms, #scopes, #consumer, in after . #[in,after]]
→
{#DM} P-ProduceBody1[#ModuleName, #SortName, P-RepairLeftRecursiveConsumerFormTag[#n, #consumer, U-Local[#SortName]], #Form, #Kind, #Rest, #n, #words, #terms, #scopes, #consumer, in after . #[in,after]]
;
    // Hack to repair tag of forms that have been truncated by the left recursion logic: truncated form is always the second.
    P-RepairLeftRecursiveConsumerFormTag[$Numeric<!--ArgIndex-->, CONSUMPTION_SORT, $String<!--SortName-->] :: $String ;
    -[Data[#n,#SortLocalName,#tag]]: P-RepairLeftRecursiveConsumerFormTag[#n, C_LEFTRECURSIVE[#1,#2], #SortLocalName] → $[:,"_",#SortLocalName,"_"] ;
    P-RepairLeftRecursiveConsumerFormTag[#n, C_BUFFER[#1,#2], #SortLocalName] → "" ;

// Handle part or parsing choice tree were left recursion not possible.

{$String<!--SortName--> : DeclarationMapEntry}
P-ProduceBody0[$String<!--ModuleName-->, $String<!--HostSort-->, $String<!--tagprefix-->, $List[PFK_SORT], $Numeric<!--ArgIndex-->, $List[Text]<!--Words-->, $List[Text]<!--Terms-->, $List[Text]<!--Scopes-->, CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

{#DM} P-ProduceBody0[#ModuleName, #SortName, #tagprefix, (), #n, #words, #terms, #scopes, #consumer, in after . #[in,after]]
→
#[%n⟪⟫, EmptyTextMap]
;

-[Data[#PFKs]]:
{#DM} P-ProduceBody0[#ModuleName, #SortName, #tagprefix, (PFK[#Form, #Kind]; #Rest), #n, #words, #terms, #scopes, #consumer, in after . #[in,after]]
→
{#DM} P-ProduceBody1[#ModuleName, #SortName, #tagprefix, #Form, #Kind, #Rest, #n, #words, #terms, #scopes, #consumer, in after . #[in,after]]
;

// Pick branching kind.

{$String<!--SortName--> : DeclarationMapEntry} P-ProduceBody1[$String<!--ModuleName-->, $String<!--HostSort-->, $String<!--tagprefix-->, HxParsedForm, FormKind, $List[PFK_SORT], $Numeric<!--ArgIndex-->, $List[Text]<!--Words-->, $List[Text]<!--Terms-->, $List[Text]<!--Scopes-->, CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

{#DM} P-ProduceBody1[#ModuleName, #SortName, #tagprefix, Hx_ParsedFormTerm[#ScopeSortPrec, #ParsedForm], #Kind, #Rest, #n, #words, #terms, #scopes, #consumer, in after . #[in,after]]
→
{#DM} P-ProduceBodyTerm1[#ModuleName, #SortName, #tagprefix, #Rest, (), #ScopeSortPrec, #Kind, (PFK[#ParsedForm, #Kind];), #n, #words, #terms, #scopes, #consumer, in after . #[in,after]]
;

{#DM} P-ProduceBody1[#ModuleName, #SortName, #tagprefix, Hx_ParsedFormWord[#word, #ParsedForm], #Kind, #Rest, #n, #words, #terms, #scopes, #consumer, in after . #[in,after]]
→
{#DM} P-ProduceBodyWord1[#ModuleName, #SortName, #tagprefix, #Rest, (), #word, (PFK[#ParsedForm, #Kind];), #n, #words, #terms, #scopes, #consumer, in after . #[in,after]]
;

{#DM} P-ProduceBody1[#ModuleName, #SortName, #tagprefix, Hx_ParsedFormSpace[#space, #ParsedForm], #Kind, #Rest, #n, #words, #terms, #scopes, #consumer, in after . #[in,after]]
→
{#DM} P-ProduceBody1[#ModuleName, #SortName, #tagprefix, #ParsedForm, #Kind, #Rest, #n, #words, #terms, #scopes, #consumer, in after . #[in,after]]
;

{#DM} P-ProduceBody1[#ModuleName, #SortName, #tagprefix, Hx_ParsedFormDone, #Kind, #Rest, #n, #words, #terms, #scopes, C_BUFFER[#SortName, #Prec], in after . #[in,after]]
→
{#DM} P-ProduceBody2[#ModuleName, #SortName, #tagprefix, #Rest, #n, #words, #terms, #scopes, C_BUFFER[#SortName, #Prec], in after . #[in,after],
  P-AttributeCollection[#ModuleName, #Kind, #SortName, #Prec, {#DM}P-ProductionConstructionText[#ModuleName, #SortName, #Prec, #Kind, #tagprefix, #words, #terms, #scopes], B_FALSE],
  P-AttributeProduction[#ModuleName, #Kind, #SortName, #Prec, B_FALSE]]
;

{#DM} P-ProduceBody1[#ModuleName, #SortName, #tagprefix, Hx_ParsedFormDone, #Kind, #Rest, #n, #words, #terms, #scopes, C_LEFTRECURSIVE[#SortName, #Prec], in after . #[in,after]]
→
{#DM} P-ProduceBody2[#ModuleName, #SortName, #tagprefix, #Rest, #n, #words, #terms, #scopes, C_LEFTRECURSIVE[#SortName, #Prec], in after . #[in,after],
  P-AttributeCollection[#ModuleName, #Kind, #SortName, #Prec, {#DM}P-ProductionConstructionText[#ModuleName, #SortName, #Prec, #Kind, #tagprefix, #words, #terms, #scopes], B_TRUE],
  P-AttributeProduction[#ModuleName, #Kind, #SortName, #Prec, B_TRUE]]
;

{$String<!--SortName--> : DeclarationMapEntry} P-ProduceBody2[$String<!--ModuleName-->, $String<!--HostSort-->, $String<!--tagprefix-->, $List[PFK_SORT], $Numeric, $List[Text]<!--Words-->, $List[Text]<!--Terms-->, $List[Text]<!--Scopes-->, CONSUMPTION_SORT, in::Text after::TextMapSort.Text, Text, TextMapSort] :: Text;
-[Data[#in2,#sort2,#after2]]:
{#DM} P-ProduceBody2[#ModuleName, #SortName, #tagprefix, #Rest, #n, #words, #terms, #scopes, #consumer, in after . #[in,after], #in2, #after2]
→
{#DM} P-ProduceBody[#ModuleName, #SortName, #tagprefix, #Rest, #n, #words, #terms, #scopes, #consumer, in after . #[%n⟪« #in2 »«in»⟫, JoinTextMaps[#after2, after]]]
;

P-AttributeCollection[$String<!--ModuleName-->, FormKind, $String<!--SortName-->, $Numeric, Text, Boolean] :: Text;

P-AttributeCollection[#ModuleName, #Kind, #SortName, #Prec, #Construct, B_FALSE] → #Construct ;
P-AttributeCollection[#ModuleName, #Kind, #SortName, #Prec, #Construct, B_TRUE] → %n⟪<«P-ProductionNameWithPrecText[#SortName,#Prec]»LR «#Construct»>⟫ ;

P-AttributeProduction[$String<!--ModuleName-->, FormKind, $String<!--SortName-->, $Numeric, Boolean] :: TextMapSort;
P-AttributeProduction[#ModuleName, #dontcare, #SortName, #Prec, #IsLeftRecursive]
→
EmptyTextMap //TODO: eliminate?
;

// Generate PG instructions to construct a result term.

{$String<!--Name--> : DeclarationMapEntry}
P-ProductionConstructionText[$String<!--ModuleName-->, $String, $Numeric, FormKind, $String<!--Tag-->, $List[Text]<!--Words-->, $List[Text]<!--Terms-->, $List[Text]<!--Scopes-->] :: Text;

{#DM}P-ProductionConstructionText[#ModuleName, #SortName, #Prec, FK_DATA[#tag1], #tag, #words, #terms, #scopes]
→
%n⟪ {{<!--DATA--> « {#DM}P-CRSX-GenerateConstructionTerm[#ModuleName, #SortName, #Prec, #tag, #scopes] » <!--« TextJoin[#words,%n⟨,⟩]»-->}}⟫
;

{#DM}P-ProductionConstructionText[#ModuleName, #SortName, #Prec, FK_SCHEME[#tag1], #tag, #words, #terms, #scopes]
→
%n⟪ {{<!--SCHEME--> « {#DM}P-CRSX-GenerateConstructionTerm[#ModuleName, #SortName, #Prec, #tag, #scopes] »}}⟫
;
    {$String<!--Name--> : DeclarationMapEntry} P-CRSX-GenerateConstructionTerm[$String<!--ModuleName-->, $String<!--SortName-->, $Numeric, $String<!--Tag-->, $List[Text]<!--Scopes-->] :: Text ;
    {#DM}P-CRSX-GenerateConstructionTerm[#ModuleName, #SortName, #Prec, #tag, #scopes]
    →
    %n⟪/***USERPG: '†« U-QN[#ModuleName, #SortName, #tag] »'« WrappedTextJoin[#scopes, %n⟨[⟩, %n⟨, ⟩, %n⟨]⟩] » ***/
    /***EMBEDPG: †« P-hx[#ModuleName, "ConstructionSorted"] »["†« U-QN[#ModuleName, "", #SortName] »", '†« P-hx[#ModuleName, "RepeatSingle"] »',
      "†« U-QN[#ModuleName, #SortName, #tag] »", (« TextJoin[Map[t.%n⟨‹t›;⟩, #scopes], %n⟨ ⟩] »), ()] ***/
    ⟫;

P-ProductionConstructionText[#ModuleName, #SortName, #Prec, FK_SUGAR[#Inh], #tag, #words, #terms, #scopes]
→
%n⟪ {{<!--SUGAR--> « WrappedTextJoin[#terms, %n⟨⟩, %n⟨ ⟩, %n⟨⟩] »}}⟫
;
//TODO:  FIX COMPOSITE SUGAR!

P-ProductionConstructionText[#ModuleName, #SortName, #Prec, FK_ALIAS, #tag, #words, #terms, #scopes]
→
%n⟪ {{<!--ALIAS--> « WrappedTextJoin[#terms, %n⟨⟩, %n⟨ ⟩, %n⟨⟩] »}}⟫
;

-[Data[#SortName]]:
P-ProductionConstructionText[#ModuleName, #SortName, #Prec, FK_SYMBOL[#isStatic, #t], #tag, #words, #terms, #scopes]
→
%n⟪ {{<!--SYMBOL--> /***EMBEDPG: †« P-hx[#ModuleName, "VariableUseSorted"] »["†« U-Local[#SortName] »", †« P-hx[#ModuleName, "RepeatSingle"] », ***/ « WrappedTextJoin[#terms, %n⟨⟩, %n⟨ ⟩, %n⟨⟩] » /***EMBEDPG: , ()]***/ }}
⟫;

    /// ∀ a . IfAliasKind[FormKind, a, a] :: a;
    /// IfAliasKind[FK_ALIAS, #1, #2] → #1 ;
    /// IfAliasKind[FK_SYMBOL[#IsStatic, #t], #1, #2] → #1 ;
    /// -[Data[#Kind]]: IfAliasKind[$[NotMatch,FK_ALIAS,$[NotMatch,FK_SYMBOL[#IsStatic, #t],#Kind]], #1, #2] → #2 ;

// (1) Constant Token Case: (a) collect productions starting with the constant token and ...

{$String<!--SortName--> : DeclarationMapEntry} P-ProduceBodyWord1[$String<!--ModuleName-->, $String<!--HostSort-->, $String<!--tagprefix-->, $List[PFK_SORT], $List[PFK_SORT], $String, $List[PFK_SORT], $Numeric<!--ArgIndex-->, $List[Text]<!--Words-->, $List[Text]<!--Terms-->, $List[Text]<!--Scopes-->, CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

-[Data[#word1,#word],Share[#ParsedForm1,#Kind1,#Rest,#wordPFKs,#n,#terms,#words,#consumer]]:
{#DM} P-ProduceBodyWord1[#ModuleName, #SortName, #tagprefix, (PFK[Hx_ParsedFormWord[#word1, #ParsedForm1], #Kind1]; #Rest), #Failed, #word, #wordPFKs, #n, #words, #terms, #scopes, #consumer, in after . #[in,after]]
→
$[If, $[Equal, #word, #word1],
  {#DM} P-ProduceBodyWord1[#ModuleName, #SortName, #tagprefix, #Rest, #Failed, #word, Append[#wordPFKs, (PFK[#ParsedForm1, #Kind1];)], #n, #words, #terms, #scopes, #consumer, in after . #[in,after]],
  {#DM} P-ProduceBodyWord1[#ModuleName, #SortName, #tagprefix, #Rest, Append[#Failed, (PFK[Hx_ParsedFormWord[#word1, #ParsedForm1], #Kind1];)], #word, #wordPFKs, #n, #words, #terms, #scopes, #consumer, in after . #[in,after]]]
;

{#DM} P-ProduceBodyWord1[#ModuleName, #SortName, #tagprefix, (PFK[Hx_ParsedFormTerm[#ScopeSortPrec1, #ParsedForm1], #Kind]; #Rest), #Failed, #word, #wordPFKs, #n, #words, #terms, #scopes, #consumer, in after . #[in,after]]
→
{#DM} P-ProduceBodyWord1[#ModuleName, #SortName, #tagprefix, #Rest, Append[#Failed, (PFK[Hx_ParsedFormTerm[#ScopeSortPrec1, #ParsedForm1], #Kind];)], #word, #wordPFKs, #n, #words, #terms, #scopes, #consumer, in after . #[in,after]]
;

{#DM} P-ProduceBodyWord1[#ModuleName, #SortName, #tagprefix, (PFK[Hx_ParsedFormSpace[#space1, #ParsedForm1], #Kind1]; #Rest), #Failed, #word, #wordPFKs, #n, #words, #terms, #scopes, #consumer, in after . #[in,after]]
→
{#DM} P-ProduceBodyWord1[#ModuleName, #SortName, #tagprefix, (PFK[#ParsedForm1, #Kind1]; #Rest), #Failed, #word, #wordPFKs, #n, #words, #terms, #scopes, #consumer, in after . #[in,after]]
;

{#DM} P-ProduceBodyWord1[#ModuleName, #SortName, #tagprefix, (PFK[Hx_ParsedFormDone, #Kind]; #Rest), #Failed, #word, #wordPFKs, #n, #words, #terms, #scopes, #consumer, in after . #[in,after]]
→
{#DM} P-ProduceBodyWord1[#ModuleName, #SortName, #tagprefix, #Rest, Append[#Failed, (PFK[Hx_ParsedFormDone, #Kind];)], #word, #wordPFKs, #n, #words, #terms, #scopes, #consumer, in after . #[in,after]]
;

{#DM} P-ProduceBodyWord1[#ModuleName, #SortName, #tagprefix, (), #Failed, #word, #wordPFKs, #n, #words, #terms, #scopes, #consumer, in after . #[in,after]]
→
{#DM} P-ProduceBodyWord2[#ModuleName, #SortName, #tagprefix, #Failed, #word, #wordPFKs, #n, #words, #terms, #scopes, #consumer, in after . #[in,after]]
;

// ... (b) emit constant token branch.

{$String<!--SortName--> : DeclarationMapEntry} P-ProduceBodyWord2[$String<!--ModuleName-->, $String<!--HostSort-->, $String<!--tagprefix-->, $List[PFK_SORT], $String, $List[PFK_SORT], $Numeric, $List[Text]<!--Words-->, $List[Text]<!--Terms-->, $List[Text]<!--Scopes-->, CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

{#DM} P-ProduceBodyWord2[#ModuleName, #SortName, #tagprefix, (), #word, #wordPFKs, #n, #words, #terms, #scopes, #consumer, in after . #[in,after]]
→
{#DM} P-ProduceBody0[#ModuleName, #SortName, $[:,#tagprefix,#word], #wordPFKs, #n, Append[#words, (%n⟨†‹#word›⟩;)], #terms, #scopes, #consumer, in1 after1 . #[%n⟪ « ProductionWord[#word] » ⟦« in1 »⟧⟫, after1]]
;

{#DM} P-ProduceBodyWord2[#ModuleName, #SortName, #tagprefix, (#PFK1;#PFKs), #word, #wordPFKs, #n, #words, #terms, #scopes, #consumer, in after . #[in,after]]
→
{#DM} P-ProduceBody0[#ModuleName, #SortName, $[:,#tagprefix,#word], #wordPFKs, #n, Append[#words, (%n⟨†‹#word›⟩;)], #terms, #scopes, #consumer, in1 after1 .
  {#DM} P-ProduceBody0[#ModuleName, #SortName, #tagprefix, (#PFK1;#PFKs), #n, #words, #terms, #scopes, #consumer, in2 after2 .
    #[%n⟪(« ProductionWord[#word] » « in1 »
| « in2 » ) ⟫, JoinTextMaps[after1, after2]]]]
;

    ProductionWord[$String] :: Text;
    ProductionWord[#word] → %n⟪†« Stringify[$[Replace, #word,$[:,"}","}"],"}  } "]] »⟫ ; // TODO: fix nesting so }+} can be allowed

// (2) Common Nonterminal: (a) collect productions starting with the nonterminal and...

{$String : DeclarationMapEntry} P-ProduceBodyTerm1[$String<!--ModuleName-->, $String<!--HostSort-->, $String<!--tagprefix-->,
	$List[PFK_SORT], $List[PFK_SORT], HxScopeSortPrec, FormKind, $List[PFK_SORT], $Numeric, $List[Text]<!--Words-->, $List[Text]<!--Terms-->, $List[Text]<!--Scopes-->, CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

{#DM} P-ProduceBodyTerm1[#ModuleName, #SortName, #tagprefix, (PFK[Hx_ParsedFormWord[#word1, #ParsedForm1], #Kind1]; #Rest), #Failed, #ScopeSortPrec, #Kind, #nonterminalPFKs, #n, #words, #terms, #scopes, #consumer, in after . #[in,after]]
→
{#DM} P-ProduceBodyTerm1[#ModuleName, #SortName, #tagprefix, #Rest, Append[#Failed, (PFK[Hx_ParsedFormWord[#word1, #ParsedForm1], #Kind1];)], #ScopeSortPrec, #Kind, #nonterminalPFKs, #n, #words, #terms, #scopes, #consumer, in after . #[in,after]]
;

{#DM} P-ProduceBodyTerm1[#ModuleName, #SortName, #tagprefix, (PFK[Hx_ParsedFormTerm[#ScopeSortPrec1, #ParsedForm1], #Kind1]; #Rest), #Failed, #ScopeSortPrec2, #Kind, #nonterminalPFKs, #n, #words, #terms, #scopes, #consumer, in after . #[in,after]]
→
{#DM} P-ProduceBodyTerm1x[#ModuleName, #SortName, #tagprefix, P-SameScopeSortPrec[#ScopeSortPrec1, #ScopeSortPrec2], #ScopeSortPrec1, #ParsedForm1, #Kind1, #Rest, #Failed, #ScopeSortPrec2, #Kind, #nonterminalPFKs, #n, #words, #terms, #scopes, #consumer, in after . #[in,after]]
;

    SortVar[HxSort] :: $String;
    -[Data[#Sort]]: SortVar[#Sort] → SortVar2[#Sort] ;
    SortVar2[HxSort] :: $String;
    -[Data[#SortName]]: SortVar2[%rawHxSort⟪ #HxSortName# #HxMetaVariables# #HxSimpleSorts# ⟫] → SortVar3[#HxSortName#, #HxMetaVariables#] ;
    SortVar2[$[NotMatch,%rawHxSort⟪ #HxSortName# #HxMetaVariables# #HxSimpleSorts# ⟫,#]] →  "bad" ;
    SortVar3[$String, $List[$String]] :: $String;
    SortVar3[#SortName, ()] → $[:,"v",#SortName] ;
    SortVar3[#SortName, (#MetaVar;)] → $[:,"v",#SortName,$[Replace,#MetaVar,"#",""]] ;

    // Local test if two ScopeSortPrecs are the same.

    P-SameScopeSortPrec[HxScopeSortPrec, HxScopeSortPrec] :: Boolean;
    P-SameScopeSortPrec[%rawHxScopeSortPrec⟪ #HxScopeSort1# #HxFormPrec1# ⟫, %rawHxScopeSortPrec⟪ #HxScopeSort2# #HxFormPrec2# ⟫] → And[P-SameScopeSort[#HxScopeSort1#, #HxScopeSort2#], P-SamePrec[#HxFormPrec1#, #HxFormPrec2#]] ;
    P-SameScopeSortPrec[%rawHxScopeSortPrec⟪ #HxScopeSort1# binds v1 ⟫, %rawHxScopeSortPrec⟪ #HxScopeSort2# #HxFormPrec2# ⟫] → B_FALSE ;
    P-SameScopeSortPrec[%rawHxScopeSortPrec⟪ #HxScopeSort1# #HxFormPrec1# ⟫, %rawHxScopeSortPrec⟪ #HxScopeSort2# binds v2 ⟫] → B_FALSE ;
    P-SameScopeSortPrec[%rawHxScopeSortPrec⟪ #HxScopeSort1# binds v1 ⟫, %rawHxScopeSortPrec⟪ #HxScopeSort2# binds v2 ⟫] → And[P-SameScopeSort[#HxScopeSort1#, #HxScopeSort2#], $[If, $[SameVariable, v1, v2], B_TRUE, B_FALSE]] ;

    P-SameScopeSort[HxScopeSort, HxScopeSort] :: Boolean;
    P-SameScopeSort[%rawHxScopeSort⟪ #HxSort1# [ #HxSubstituteSorts1# ] ⟫, %rawHxScopeSort⟪ #HxSort2# [ #HxSubstituteSorts2# ] ⟫] → P-SameSort[#HxSort1#, #HxSort2#] ;

    P-SameSort[HxSort, HxSort] :: Boolean;
    -[Data[#1,#2]]: P-SameSort[#1, #2] → P-SameSort2[#1, #2] ;

    P-SameSort2[HxSort, HxSort] :: Boolean;
    -[Data[#HxSortName1#,#HxSortName2#]]:
    P-SameSort2[%rawHxSort⟪ #HxSortName1# #HxMetaVariables1# #HxSimpleSorts1# ⟫, %rawHxSort⟪ #HxSortName2# #HxMetaVariables2# #HxSimpleSorts2# ⟫]
    →
    SameString[U-Local[#HxSortName1#], U-Local[#HxSortName2#]]
    ;

    P-SameSort2[$[NotMatch,%rawHxSort⟪ #HxSortName1# #HxMetaVariables1# #HxSimpleSorts1# ⟫,#1], #2]
    →
    B_FALSE
    ;

    P-SameSort2[#1,$[NotMatch,%rawHxSort⟪ #HxSortName2# #HxMetaVariables2# #HxSimpleSorts2# ⟫,#2]]
    →
    B_FALSE
    ;

    P-SamePrec[$String, $String] :: Boolean;
    P-SamePrec[#Prec1, #Prec2] → P-SamePrec2[StringToNumericDefault[#Prec1,0], StringToNumericDefault[#Prec2,0]] ;

    P-SamePrec2[$Numeric, $Numeric] :: Boolean;
    -[Data[#Prec1,#Prec2]]: P-SamePrec2[#Prec1, #Prec2] → $[If, $[NumericEqual, #Prec1, #Prec2], B_TRUE, B_FALSE] ;

//

{#DM} P-ProduceBodyTerm1[#ModuleName, #SortName, #tagprefix, (PFK[Hx_ParsedFormSpace[#space1, #ParsedForm1], #Kind1]; #Rest), #Failed, #ScopeSortPrec, #Kind, #nonterminalPFKs, #n, #words, #terms, #scopes, #consumer, in after . #[in,after]]
→
{#DM} P-ProduceBodyTerm1[#ModuleName, #SortName, #tagprefix, (PFK[#ParsedForm1, #Kind1]; #Rest), #Failed, #ScopeSortPrec, #Kind, #nonterminalPFKs, #n, #words, #terms, #scopes, #consumer, in after . #[in,after]]
;

{#DM} P-ProduceBodyTerm1[#ModuleName, #SortName, #tagprefix, (PFK[Hx_ParsedFormDone, #Kind1]; #Rest), #Failed, #ScopeSortPrec, #Kind, #nonterminalPFKs, #n, #words, #terms, #scopes, #consumer, in after . #[in,after]]
→
{#DM} P-ProduceBodyTerm1[#ModuleName, #SortName, #tagprefix, #Rest, Append[#Failed, (PFK[Hx_ParsedFormDone, #Kind1];)], #ScopeSortPrec, #Kind, #nonterminalPFKs, #n, #words, #terms, #scopes, #consumer, in after . #[in,after]]
;

{#DM} P-ProduceBodyTerm1[#ModuleName, #SortName, #tagprefix, (), #Failed, #ScopeSortPrec, #Kind, #nonterminalPFKs, #n, #words, #terms, #scopes, #consumer, in after . #[in,after]]
→
{#DM} P-ProduceBodyTerm2[#ModuleName, #SortName, #tagprefix, #Failed, #ScopeSortPrec, #Kind, #nonterminalPFKs, #n, #words, #terms, #scopes, #consumer, in after . #[in,after]]
;

// ... helper to filter identical scope sorts...

{$String : DeclarationMapEntry}
P-ProduceBodyTerm1x[$String<!--ModuleName-->, $String<!--HostSort-->, $String<!--tagprefix-->, Boolean, HxScopeSortPrec, HxParsedForm, FormKind,
	$List[PFK_SORT], $List[PFK_SORT], HxScopeSortPrec, FormKind, $List[PFK_SORT], $Numeric, $List[Text]<!--Words-->, $List[Text]<!--Terms-->, $List[Text]<!--Scopes-->, CONSUMPTION_SORT,
        in::Text after::TextMapSort.Text] :: Text;

{#DM} P-ProduceBodyTerm1x[#ModuleName, #SortName, #tagprefix, B_FALSE, #ScopeSortPrec1, #ParsedForm1, #Kind1, #Rest, #Failed, #ScopeSortPrec, #Kind, #nonterminalPFKs, #n, #words, #terms, #scopes, #consumer, in after . #[in,after]]
→
{#DM} P-ProduceBodyTerm1[#ModuleName, #SortName, #tagprefix, #Rest, Append[#Failed, (PFK[Hx_ParsedFormTerm[#ScopeSortPrec1, #ParsedForm1], #Kind1];)], #ScopeSortPrec, #Kind, #nonterminalPFKs, #n, #words, #terms, #scopes, #consumer, in after . #[in,after]]
;

{#DM} P-ProduceBodyTerm1x[#ModuleName, #SortName, #tagprefix, B_TRUE, #ScopeSortPrec1, #ParsedForm1, #Kind1, #Rest, #Failed, #ScopeSortPrec, #Kind, #nonterminalPFKs, #n, #words, #terms, #scopes, #consumer, in after . #[in,after]]
→
{#DM} P-ProduceBodyTerm1[#ModuleName, #SortName, #tagprefix, #Rest, #Failed, #ScopeSortPrec, #Kind, Append[#nonterminalPFKs, (PFK[#ParsedForm1, #Kind1];)], #n, #words, #terms, #scopes, #consumer, in after . #[in,after]]
;

// ... (b) emit branch (with recursive nesting of tail).

{$String : DeclarationMapEntry}
P-ProduceBodyTerm2[$String<!--ModuleName-->, $String<!--HostSort-->, $String<!--tagprefix-->, $List[PFK_SORT], HxScopeSortPrec, FormKind, $List[PFK_SORT], $Numeric, $List[Text]<!--Words-->, $List[Text]<!--Terms-->, $List[Text]<!--Scopes-->, CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

{#DM} P-ProduceBodyTerm2[#ModuleName, #SortName, #tagprefix, (), #ScopeSortPrec, #Kind, #nonterminalPFKs, #n, #words, #terms, #scopes, #consumer, in after . #[in,after]]
→
{#DM} P-ProduceBodyTerm3[#ModuleName, #SortName, #tagprefix, #ScopeSortPrec, #Kind, #nonterminalPFKs, #n, #words, #terms, #scopes, #consumer, in after . #[in,after]]
;

{#DM} P-ProduceBodyTerm2[#ModuleName, #SortName, #tagprefix, (#PFK1;#PFKs), #ScopeSortPrec, #Kind, #nonterminalPFKs, #n, #words, #terms, #scopes, #consumer, in after . #[in,after]]
→
{#DM} P-ProduceBodyTerm3[#ModuleName, #SortName, #tagprefix, #ScopeSortPrec, #Kind, #nonterminalPFKs, #n, #words, #terms, #scopes, #consumer, in1 after1 .
  {#DM} P-ProduceBody0[#ModuleName, #SortName, #tagprefix, (#PFK1;#PFKs), #n, #words, #terms, #scopes, #consumer, in2 after2 .
    #[%n⟪(« in1 »
| « in2 »)⟫, JoinTextMaps[after1, after2]]]]
;

{$String : DeclarationMapEntry}
P-ProduceBodyTerm3[$String<!--ModuleName-->, $String<!--HostSort-->, $String<!---tagprefix-->, HxScopeSortPrec, FormKind, $List[PFK_SORT], $Numeric, $List[Text]<!--Words-->, $List[Text]<!--Terms-->, $List[Text]<!--Scopes-->, CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

{#DM} P-ProduceBodyTerm3[#ModuleName, #SortName, #tagprefix, %rawHxScopeSortPrec⟪ #HxSort# #HxRepeat# [ #HxSubstituteSorts# ] #HxFormPrec# ⟫, #Kind, #nonterminalPFKs, #n, #words, #terms, #scopes, #consumer, in after . #[in,after]]
→
{#DM} P-ProduceBody0[#ModuleName, #SortName, StringJoin[(#tagprefix; "_"; U-SortName[#HxSort#]; "_";), ""], #nonterminalPFKs, $[Plus,#n,1],
  Append[#words, (%n⟨†‹ U-SortName[#HxSort#] ›⟩;)],
  Append[#terms, (%n⟨†‹ P-SortMetaVar[#HxSort#, #n] ›⟩;)],
  Append[#scopes, (%n⟨‹ P-CRSX-ArgumentWrapper[#HxSubstituteSorts#, P-SortMetaVar[#HxSort#, #n], #Kind] ›⟩;)],
  #consumer,
  in after .
    #[%n⟪⟦( <« P-ProductionNameWithPrecRepeatText[U-SortName[#HxSort#], StringToNumericDefault[#HxFormPrec#,0], #HxRepeat#] »>«
	WrappedTextJoin[Map[s.P-ExtractSubstitutedSort[s], #HxSubstituteSorts#], %n⟨[⟩, %n⟨,⟩, %n⟨]⟩] »«
	P-VariableMarker[#Kind, %n⟨:†‹ P-SortMetaVar[#HxSort#, #n] ›⟩] » ⟦« in »⟧ )
      ⟧⟫, after]]
;

{#DM} P-ProduceBodyTerm3[#ModuleName, #SortName, #tagprefix, %rawHxScopeSortPrec⟪ #HxSort# #HxRepeat# [ #HxSubstituteSorts# ] binds x ⟫, #Kind, #nonterminalPFKs, #n, #words, #terms, #scopes, #consumer, in after . #[in,after]]
→
{#DM} P-ProduceBody0[#ModuleName, #SortName, StringJoin[(#tagprefix; "_"; U-SortName[#HxSort#]; "_";), ""], #nonterminalPFKs, $[Plus,#n,1],
  Append[#words, (%n⟨†‹ U-SortName[#HxSort#] ›⟩;)],
  #terms,
  #scopes,
  #consumer,
  in after . #[%n⟪⟦( <†« {#DM} U-SymbolSortTokenName[U-SortName[#HxSort#]] »>^«x» ⟦« in »⟧ ) ⟧⟫, after]]
;

    // P special production name for non-terminals with precedence and repeat...

    P-ProductionNameWithPrecRepeatText[$String, $Numeric, HxRepeat] :: Text;
    P-ProductionNameWithPrecRepeatText[#Name, #Prec, %rawHxRepeat⟪ ⟫] → P-ProductionNameWithPrecText[U-Local[#Name], #Prec] ;
    P-ProductionNameWithPrecRepeatText[#Name, #Prec, %rawHxRepeat⟪ ? ⟫]→ %n⟪« P-ProductionNameWithPrecText[U-Local[#Name], #Prec] »_Maybe⟫ ;
    P-ProductionNameWithPrecRepeatText[#Name, #Prec, %rawHxRepeat⟪ * ⟫]→ %n⟪« P-ProductionNameWithPrecText[U-Local[#Name], #Prec] »_MaybeSome⟫ ;
    -[Data[#HxRegExpSimple#]]:
    P-ProductionNameWithPrecRepeatText[#Name, #Prec, %rawHxRepeat⟪ + ⟫]→ %n⟪« P-ProductionNameWithPrecText[U-Local[#Name], #Prec] »_Some⟫ ;
    -[Data[#HxRegExpSub#]]:
    P-ProductionNameWithPrecRepeatText[#Name, #Prec, %rawHxRepeat⟪ + _ #HxRegExpSub# ⟫]→ %n⟪« P-ProductionNameWithPrecText[U-Local[#Name], #Prec] »« P-RegExpSubNameText["", #HxRegExpSub#] »⟫ ;

    // Convert regular expression to name fragment...
    P-RegExpSubNameText[$String, HxRegExpSimple] :: Text;
    -[Data[#Name,#HxString#]]:      P-RegExpSubNameText[#Name, %rawHxRegExpSub⟪ #HxString# ⟫] → %n⟪†«#Name»_SomeS†« $[Mangle,#HxString#] »⟫ ;
    -[Data[#Name,#HxSeparator#]]:        P-RegExpSubNameText[#Name, %rawHxRegExpSub⟪ #HxSeparator# ⟫] → %n⟪†«#Name»_SomeW†« $[Mangle,#HxSeparator#] »⟫ ;

    P-CRSX-ArgumentWrapper[$List[HxSubstituteSort], $String<!--MetaVar-->, FormKind] :: Text ;
    P-CRSX-ArgumentWrapper[#HxSubstituteSorts, #MetaVar, FK_DATA[#tag]] → %n⟪/***EMBEDPG: 'C-UnravelScope_†« NumericToString[Length[#HxSubstituteSorts]] »'[***/†«#MetaVar»/***EMBEDPG:]***/⟫ ;
    P-CRSX-ArgumentWrapper[#HxSubstituteSorts, #MetaVar, FK_SCHEME[#tag]] → %n⟪/***EMBEDPG: 'C-UnravelScope_†« NumericToString[Length[#HxSubstituteSorts]] »'[***/†«#MetaVar»/***EMBEDPG:]***/⟫ ;
    P-CRSX-ArgumentWrapper[#HxSubstituteSorts, #MetaVar, FK_SYMBOL[#stat, #token]] → %n⟪†«#MetaVar»⟫ ;
    P-CRSX-ArgumentWrapper[#HxSubstituteSorts, #MetaVar, FK_SUGAR[#term]] → %n⟪†«#MetaVar»⟫ ;
    P-CRSX-ArgumentWrapper[#HxSubstituteSorts, #MetaVar, FK_ALIAS] → %n⟪†«#MetaVar»⟫ ;

    P-SortMetaVar[HxSort, $Numeric] :: $String;
    -[Data[#Sort]]: P-SortMetaVar[#Sort, #n] → P-SortMetaVar2[#Sort, #n] ;
    P-SortMetaVar2[HxSort, $Numeric] :: $String;
    P-SortMetaVar2[%rawHxSort⟪ #HxSortName# #HxMetaVariable# #HxSimpleSorts# ⟫, #n] → U-Local[#HxMetaVariable#] ;
    P-SortMetaVar2[%rawHxSort⟪ #HxSortName# #HxSimpleSorts# ⟫, #n] → P-SortMetaVar3[U-Local[#HxSortName#], #n] ;
    P-SortMetaVar2[$[NotMatch,%rawHxSort⟪ #HxSortName# #HxMetaVariables# #HxSimpleSorts# ⟫,#], #n] →  "#bad" ;

    P-SortMetaVar3[$String, $Numeric] :: $String;
    P-SortMetaVar3[#Name, #n] → $[:,"#_",#Name,"_",$[FormatNumber,#n]] ;

    // TODO: Eliminate redundant repeat productions!

    P-ExtractSubstitutedSort[HxSubstituteSort] :: Text;
    -[Free[v::HxTerm]]:
    P-ExtractSubstitutedSort[%rawHxSubstituteSort⟪ v as #HxSort# ⟫] → %n⟪«v»⟫ ;

    P-VariableMarker[FormKind, Text] :: Text;
    -[Data[#Kind]]: P-VariableMarker[#Kind, #Other] → P-VariableMarker2[#Kind, #Other] ;

    P-VariableMarker2[FormKind, Text] :: Text;
    P-VariableMarker2[FK_SYMBOL[$False,#t], #Other] → %n⟪!!!« #Other »⟫ ;
    P-VariableMarker2[FK_SYMBOL[$True,#t], #Other] → %n⟪!!« #Other »⟫ ;
    P-VariableMarker2[$[NotMatch,FK_SYMBOL[#IsStatic,#t],#Kind], #Other] → #Other ;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 4. GENERATE TEXT OF ALL LEXICAL DECLARATIONS.

// Instantiate CPS processing.
P-Lexical[$List[HxDeclaration], $String<!--ModuleName-->] :: Text ;
P-Lexical[#Declarations, #ModuleName] → P-Lexical2[#Declarations, #ModuleName, B_FALSE, hasskip.P-Lexical2Tail[hasskip]] ;

// Generate P token instructions per HACS declaration.

P-Lexical2[$List[HxDeclaration], $String, Boolean, ha::Boolean.Text] :: Text ;

Lexical-module:
P-Lexical2[%rawHxDeclarations⟪ module #HxModuleName2# { #HxDeclarations2# } ; #HxDeclarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
P-Lexical2[#HxDeclarations2#, #HxModuleName2#, #hasSkip, hasskip.P-Lexical2[#HxDeclarations#, #ModuleName, hasskip, hasskip2.#[hasskip2]]]
;

Lexical-space:
P-Lexical2[%rawHxDeclarations⟪ space #HxRegExp# ; #HxDeclarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
%n⟪skip ::= ' ' | ⟦« P-InlineRegExp[#HxRegExp#, #ModuleName, "space$"] »⟧ .
« P-DeclareRegExp[#HxRegExp#, #ModuleName, "space$"] »« P-Lexical2[#HxDeclarations#, #ModuleName, B_TRUE, hasskip.#[hasskip]] »⟫
;

Lexical-token:
P-Lexical2[%rawHxDeclarations⟪ token #HxTokenName# | #HxRegExp# ; #HxDeclarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
%n⟪token «P-TokenNameText[#HxTokenName#]» ::= ⟦« P-InlineRegExp[#HxRegExp#, #ModuleName, #HxTokenName#] »⟧ .
« P-DeclareRegExp[#HxRegExp#, #ModuleName, #HxTokenName#] »« P-Lexical2[#HxDeclarations#, #ModuleName, #hasSkip, hasskip.#[hasskip]] »⟫
;

Lexical-fragment:
P-Lexical2[%rawHxDeclarations⟪ fragment #HxTokenName# | #HxRegExp# ; #HxDeclarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
%n⟪token fragment «P-TokenNameText[#HxTokenName#]» ::= ⟦« P-InlineRegExp[#HxRegExp#, #ModuleName, #HxTokenName#] »⟧ .
« P-DeclareRegExp[#HxRegExp#, #ModuleName, #HxTokenName#] »« P-Lexical2[#HxDeclarations#, #ModuleName, #hasSkip, hasskip.#[hasskip]] »⟫
;

Lexical-attribute:
P-Lexical2[%rawHxDeclarations⟪ attribute #HxAttributeKind# #HxAttributeName# #HxAttributeForm# ; #HxDeclarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
P-Lexical2[#HxDeclarations#, #ModuleName, #hasSkip, hasskip.#[hasskip]]
;

Lexical-sort:
P-Lexical2[%rawHxDeclarations⟪ sort #HxSortName# #HxRepeat# #HxSortAbstraction# ; #HxDeclarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
P-Lexical2[#HxDeclarations#, #ModuleName, #hasSkip, hasskip.#[hasskip]]
;

Lexical-main-sort:
P-Lexical2[%rawHxDeclarations⟪ main sort #HxSortName# #HxRepeat# #HxSortAbstraction# ; #HxDeclarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
P-Lexical2[#HxDeclarations#, #ModuleName, #hasSkip, hasskip.#[hasskip]]
;

Lexical-alternatives:
P-Lexical2[%rawHxDeclarations⟪ #HxSortAlternatives# ; #HxDeclarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
P-Lexical2[#HxDeclarations#, #ModuleName, #hasSkip, hasskip.#[hasskip]]
;

Lexical-rule:
P-Lexical2[%rawHxDeclarations⟪ rule #HxRule# ; #HxDeclarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
P-Lexical2[#HxDeclarations#, #ModuleName, #hasSkip, hasskip.#[hasskip]]
;

Lexical-nest:
P-Lexical2[%rawHxDeclarations⟪ { #HxDeclarations2# } #HxDeclarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
P-Lexical2[#HxDeclarations2#, #ModuleName, #hasSkip, hasskip.P-Lexical2[#HxDeclarations#, #ModuleName, hasskip, hasskip2.#[hasskip2]]]
;

Lexical-done:
P-Lexical2[%rawHxDeclarations⟪ ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
#[#hasSkip]
;

// The final continuation.
P-Lexical2Tail[Boolean] :: Text;
P-Lexical2Tail[B_TRUE] → %n⟪⟫ ;
P-Lexical2Tail[B_FALSE] → %n⟪skip ::= " " .
⟫ ;

// b. Inline Text of Regular Expression.

//

P-InlineRegExp[$List[HxRegExpChoice], $String<!--ModuleName-->, $String<!--identifier-->] :: Text ;
P-InlineRegExp[(#RegExpChoice; #RegExp), #ModuleName, #id]
→
%n⟪⟦« P-InlineRegExpChoice[#RegExpChoice, #ModuleName, #id, ""] »⟧ « P-InlineRegExp2[#RegExp, #ModuleName, #id] »⟫
;

P-InlineRegExp2[$List[HxRegExpChoice], $String<!--ModuleName-->, $String<!--identifier-->] :: Text ;
P-InlineRegExp2[(#RegExpChoice; #RegExp), #ModuleName, #id]
→
%n⟪⟦« P-InlineRegExpChoice[#RegExpChoice, #ModuleName, #id, "| "] »⟧ « P-InlineRegExp2[#RegExp, #ModuleName, #id] »⟫
;
P-InlineRegExp2[(), #ModuleName, #id]
→
%n⟪⟫
;

//

P-InlineRegExpChoice[HxRegExpChoice, $String<!--ModuleName-->, $String<!--id-->, $String<!--sep-->] :: Text;

P-InlineRegExpChoice[%rawHxRegExpChoice⟪ nested #HxRegExpSimple1# #HxRegExpSimple2# ⟫, #ModuleName, #id, #sep]
→
$[If, $[Equal,#id,"space$"],
  %n⟪⟫, // handled by SKIP declaration in nesting
  %n⟪†«#sep»NESTED_«P-TokenNameText[#id]»⟫
]
;
P-InlineRegExpChoice[%rawHxRegExpChoice⟪ #HxRegExpUnits# ⟫, #ModuleName, #id, #sep]
→
%n⟪†«#sep»« P-InlineRegExpUnits[#HxRegExpUnits#, #ModuleName, #id] »⟫
;

//

P-InlineRegExpUnits[$List[HxRegExpUnit], $String<!--ModuleName-->, $String] :: Text;

P-InlineRegExpUnits[%rawHxRegExpUnits⟪ #HxRegExpUnit# #HxRegExpUnits# ⟫, #ModuleName, #id]
→
%n⟪« P-InlineRegExpUnit[#HxRegExpUnit#, #ModuleName, #id] » « P-InlineRegExpUnits[#HxRegExpUnits#, #ModuleName, #id] »⟫
;
P-InlineRegExpUnits[%rawHxRegExpUnits⟪ ⟫, #ModuleName, #id]
→
%n⟪⟫
;

//

P-InlineRegExpUnit[HxRegExpUnit, $String<!--ModuleName-->, $String] :: Text;

P-InlineRegExpUnit[%rawHxRegExpUnit⟪ #HxRegExpSimple# ⟫, #ModuleName, #id]
→
P-InlineRegExpSimple[#HxRegExpSimple#, #ModuleName, #id]
;

P-InlineRegExpUnit[%rawHxRegExpUnit⟪ #HxRegExpSimple# ? ⟫, #ModuleName, #id]
→
%n⟪( « P-InlineRegExpSimple[#HxRegExpSimple#, #ModuleName, #id] » )?⟫
;

P-InlineRegExpUnit[%rawHxRegExpUnit⟪ #HxRegExpSimple# * ⟫, #ModuleName, #id]
→
%n⟪( « P-InlineRegExpSimple[#HxRegExpSimple#, #ModuleName, #id] » )*⟫
;

P-InlineRegExpUnit[%rawHxRegExpUnit⟪ #HxRegExpSimple# + ⟫, #ModuleName, #id]
→
%n⟪( « P-InlineRegExpSimple[#HxRegExpSimple#, #ModuleName, #id] » )+⟫
;

P-InlineRegExpUnit[%rawHxRegExpUnit⟪ #HxRegExpSimple# + _ #HxRegExpSub# ⟫, #ModuleName, #id]
→
%n⟪( « P-InlineRegExpSimple[#HxRegExpSimple#, #ModuleName, #id] » ( « P-InlineRegExpSimple[#HxRegExpSub#, #ModuleName, #id] » « P-InlineRegExpSimple[#HxRegExpSimple#, #ModuleName, #id] » )* )⟫
;

//

P-InlineRegExpSimple[HxRegExpSimple, $String<!--ModuleName-->, $String] :: Text;

P-InlineRegExpSimple[%rawHxRegExpSimple⟪ #HxString# ⟫, #ModuleName, #id]
→
%n⟪†«#HxString#»⟫ // TODO: manually decode HACS and recode P escapes (or at least check)!
;

P-InlineRegExpSimple[%rawHxRegExpSimple⟪ #HxRegExpWord# ⟫, #ModuleName, #id]
→
%n⟪†« Stringify[#HxRegExpWord#] »⟫
;

P-InlineRegExpSimple[%rawHxRegExpSimple⟪ #HxFragmentRef# ⟫, #ModuleName, #id]
→
%n⟪«P-TokenNameText[#HxFragmentRef#]»⟫
;

P-InlineRegExpSimple[%rawHxRegExpSimple⟪ . ⟫, #ModuleName, #id]
→
P-InlineRegExpSimple[%rawHxRegExpSimple⟪ [^\n\r\f] ⟫, #ModuleName, #id]
;

P-InlineRegExpSimple[%rawHxRegExpSimple⟪ #HxRegExpClass# ⟫, #ModuleName, #id]
→
P-InlineRegExpClass1[#HxRegExpClass#, #ModuleName, #id]
;

P-InlineRegExpSimple[%rawHxRegExpSimple⟪ ( #HxRegExp# ) ⟫, #ModuleName, #id]
→
%n⟪( « P-InlineRegExp[#HxRegExp#, #ModuleName, #id] » )⟫
;

//

P-InlineRegExpClass1[HxRegExpClass, $String<!--ModuleName-->, $String] :: Text;

P-InlineRegExpClass1[Hx_RegExpClassNot[#RegExpClass], #ModuleName, #id]
→
%n⟪~[« P-InlineRegExpClass2[#RegExpClass, #ModuleName, #id, %n⟨⟩] »]⟫
;

P-InlineRegExpClass1[$[NotMatch,Hx_RegExpClassNot[#_],#RegExpClass], #ModuleName, #id]
→
%n⟪[« P-InlineRegExpClass2[#RegExpClass, #ModuleName, #id, %n⟨⟩] »]⟫
;

P-InlineRegExpClass2[HxRegExpClass, $String<!--ModuleName-->, $String, Text] :: Text;

P-InlineRegExpClass2[Hx_RegExpClassChar[#Char, #RegExpClass], #ModuleName, #id, #sep]
→
%n⟪«#sep»« P-InlineRegExpRangeChar[#Char, #ModuleName, #id] »« P-InlineRegExpClass2[#RegExpClass, #ModuleName, #id, %n⟨,⟩] »⟫
;

P-InlineRegExpClass2[Hx_RegExpClassRange[#lo, #hi, #RegExpClass], #ModuleName, #id, #sep]
→
%n⟪«#sep»« P-InlineRegExpRangeChar[#lo, #ModuleName, #id] »-« P-InlineRegExpRangeChar[#hi, #ModuleName, #id] »« P-InlineRegExpClass2[#RegExpClass, #ModuleName, #id, %n⟨,⟩] »⟫
;

P-InlineRegExpClass2[Hx_RegExpClassDone, #ModuleName, #id, #sep]
→
%n⟪⟫
;
P-InlineRegExpRangeChar[$String, $String<!--ModuleName-->, $String] :: Text;
-[Data[#HxRegExpRangeStartChar#]]:
P-InlineRegExpRangeChar[#HxRegExpRangeStartChar#, #ModuleName, #id]
→
$[If, $[StringEqual,#HxRegExpRangeStartChar#,"\""], %n⟪\"⟫, %n⟪"†«#HxRegExpRangeStartChar#»"⟫]
;

//

P-DeclareRegExp[$List[HxRegExpChoice], $String<!--ModuleName-->, $String<!--identifier-->] :: Text ;
P-DeclareRegExp[(#RegExpChoice; #RegExp), #ModuleName, #id]
→
%n⟪« P-DeclareRegExpChoice[#RegExpChoice, #ModuleName, #id] »« P-DeclareRegExp[#RegExp, #ModuleName, #id] »⟫
;
P-DeclareRegExp[(), #ModuleName, #id]
→
%n⟪⟫
;

P-DeclareRegExpChoice[HxRegExpChoice, $String<!--ModuleName-->, $String] :: Text;
P-DeclareRegExpChoice[%rawHxRegExpChoice⟪ nested #HxRegExpSimple1# #HxRegExpSimple2# ⟫, #ModuleName, #id]
→
%n⟪
%{
/* token †«#id». */
MORE : { < « P-InlineRegExpSimple[#HxRegExpSimple1#, #ModuleName, #id] » > { nesting = 0; nestedState = curLexState; } : IN_«P-TokenNameText[#id]» }
<IN_«P-TokenNameText[#id]»> MORE : { < « P-InlineRegExpSimple[#HxRegExpSimple1#, #ModuleName, #id] » > { nesting = 1; } : IN_NESTED_«P-TokenNameText[#id]» }
<IN_NESTED_«P-TokenNameText[#id]»> MORE : { < « P-InlineRegExpSimple[#HxRegExpSimple1#, #ModuleName, #id] » > { nesting++; } }
<IN_NESTED_«P-TokenNameText[#id]»> MORE : { < « P-InlineRegExpSimple[#HxRegExpSimple2#, #ModuleName, #id] » > { if (--nesting <= 0) SwitchTo(IN_«P-TokenNameText[#id]»); } }
<IN_«P-TokenNameText[#id]»> †« $[If,$[Equal,#id,"space$"],"SKIP","TOKEN"] » : { < T_NESTED_«P-TokenNameText[#id]» : « P-InlineRegExpSimple[#HxRegExpSimple2#, #ModuleName, #id] » > { SwitchTo(nestedState); } }
<IN_«P-TokenNameText[#id]»,IN_NESTED_«P-TokenNameText[#id]»> MORE : { < ~[] > }
%}
⟫
;
P-DeclareRegExpChoice[%rawHxRegExpChoice⟪ #HxRegExpUnits# ⟫, #ModuleName, #id]
→
P-DeclareRegExpUnits[#HxRegExpUnits#, #ModuleName, #id]
;

P-DeclareRegExpUnits[$List[HxRegExpUnit], $String<!--ModuleName-->, $String] :: Text;
P-DeclareRegExpUnits[%rawHxRegExpUnits⟪ #HxRegExpUnit# #HxRegExpUnits# ⟫, #ModuleName, #id]
→
%n⟪« P-DeclareRegExpUnit[#HxRegExpUnit#, #ModuleName, #id] »« P-DeclareRegExpUnits[#HxRegExpUnits#, #ModuleName, #id] »⟫
;
P-DeclareRegExpUnits[%rawHxRegExpUnits⟪ ⟫, #ModuleName, #id]
→
%n⟪⟫
;

P-DeclareRegExpUnit[HxRegExpUnit, $String<!--ModuleName-->, $String] :: Text;
P-DeclareRegExpUnit[%rawHxRegExpUnit⟪ #HxRegExpSimple# ⟫, #ModuleName, #id] → P-DeclareRegExpSimple[#HxRegExpSimple#, #ModuleName, #id] ;
P-DeclareRegExpUnit[%rawHxRegExpUnit⟪ #HxRegExpSimple# ? ⟫, #ModuleName, #id] → P-DeclareRegExpSimple[#HxRegExpSimple#, #ModuleName, #id] ;
P-DeclareRegExpUnit[%rawHxRegExpUnit⟪ #HxRegExpSimple# * ⟫, #ModuleName, #id] → P-DeclareRegExpSimple[#HxRegExpSimple#, #ModuleName, #id] ;
P-DeclareRegExpUnit[%rawHxRegExpUnit⟪ #HxRegExpSimple# + ⟫, #ModuleName, #id] → P-DeclareRegExpSimple[#HxRegExpSimple#, #ModuleName, #id] ;
P-DeclareRegExpUnit[%rawHxRegExpUnit⟪ #HxRegExpSimple# + _ #HxRegExpSub# ⟫, #ModuleName, #id] → %n⟪« P-DeclareRegExpSimple[#HxRegExpSimple#, #ModuleName, #id] »« P-DeclareRegExpSimple[#HxRegExpSub#, #ModuleName, #id] »⟫ ;

P-DeclareRegExpSimple[HxRegExpSimple, $String<!--ModuleName-->, $String] :: Text;
P-DeclareRegExpSimple[%rawHxRegExpSimple⟪ #HxString# ⟫, #ModuleName, #id] → %n⟪⟫ ;
P-DeclareRegExpSimple[%rawHxRegExpSimple⟪ #HxFragmentRef# ⟫, #ModuleName, #id] → %n⟪⟫ ;
P-DeclareRegExpSimple[%rawHxRegExpSimple⟪ . ⟫, #ModuleName, #id] → %n⟪⟫ ;
P-DeclareRegExpSimple[%rawHxRegExpSimple⟪ #HxRegExpClass# ⟫, #ModuleName, #id] → %n⟪⟫ ;
P-DeclareRegExpSimple[%rawHxRegExpSimple⟪ ( #HxRegExp# ) ⟫, #ModuleName, #id] → P-DeclareRegExp[#HxRegExp#, #ModuleName, #id] ;
P-DeclareRegExpSimple[%rawHxRegExpSimple⟪ #HxRegExpWord# ⟫, #ModuleName, #id] → %n⟪⟫ ;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 5. HELPERS FOR MANAGING REPEATS.

//
P-RegExpSubWord[HxRegExpSimple] :: $String;
-[Data[#HxString#]]: P-RegExpSubWord[%rawHxRegExpSub⟪ #HxString# ⟫] → $[Rescape, #HxString#] ;
-[Data[#HxSeparator#]]:   P-RegExpSubWord[%rawHxRegExpSub⟪ #HxSeparator# ⟫] → #HxSeparator# ;

∀ a . IfSingletonRepeat[HxRepeat, a, a] :: a;
IfSingletonRepeat[%rawHxRepeat⟪ ⟫, #1, #2] → #1 ;
IfSingletonRepeat[%rawHxRepeat⟪ ? ⟫, #1, #2] → #2 ;
IfSingletonRepeat[%rawHxRepeat⟪ * ⟫, #1, #2] → #2 ;
IfSingletonRepeat[%rawHxRepeat⟪ + ⟫, #1, #2] → #2 ;
IfSingletonRepeat[%rawHxRepeat⟪ + _ #HxRegExpSub# ⟫, #1, #2] → #2 ;

NestedRepeat[HxRepeat, HxRepeat] :: HxRepeat;
NestedRepeat-single-single:   NestedRepeat[%rawHxRepeat⟪ ⟫, %rawHxRepeat⟪ ⟫]                                     → %rawHxRepeat⟪ ⟫ ;
NestedRepeat-single-maybe :   NestedRepeat[%rawHxRepeat⟪ ⟫, %rawHxRepeat⟪ ? ⟫]                                   → %rawHxRepeat⟪ ? ⟫ ;
NestedRepeat-single-many:     NestedRepeat[%rawHxRepeat⟪ ⟫, %rawHxRepeat⟪ * ⟫]                                   → %rawHxRepeat⟪ * ⟫ ;
NestedRepeat-single-some:     NestedRepeat[%rawHxRepeat⟪ ⟫, %rawHxRepeat⟪ + ⟫]                                   → %rawHxRepeat⟪ + ⟫ ;
NestedRepeat-single-somesep:  NestedRepeat[%rawHxRepeat⟪ ⟫, %rawHxRepeat⟪ + _ #HxRegExpSub2# ⟫]                   → %rawHxRepeat⟪ + _ #HxRegExpSub2# ⟫ ;
NestedRepeat-maybe-single:    NestedRepeat[%rawHxRepeat⟪ ? ⟫, %rawHxRepeat⟪ ⟫]                                   → %rawHxRepeat⟪ ? ⟫ ;
NestedRepeat-maybe-maybe :    NestedRepeat[%rawHxRepeat⟪ ? ⟫, %rawHxRepeat⟪ ? ⟫]                                 → %rawHxRepeat⟪ ? ⟫ ;
NestedRepeat-maybe-many:      NestedRepeat[%rawHxRepeat⟪ ? ⟫, %rawHxRepeat⟪ * ⟫]                                 → %rawHxRepeat⟪ * ⟫ ;
NestedRepeat-maybe-some:      NestedRepeat[%rawHxRepeat⟪ ? ⟫, %rawHxRepeat⟪ + ⟫]                                 → %rawHxRepeat⟪ * ⟫ ;
NestedRepeat-maybe-somesep:   NestedRepeat[%rawHxRepeat⟪ ? ⟫, %rawHxRepeat⟪ + _ #HxRegExpSub2# ⟫]                 → $[Error,"Cannot nest ? in +_'...' repeater."] ;
NestedRepeat-many-single:     NestedRepeat[%rawHxRepeat⟪ * ⟫, %rawHxRepeat⟪ ⟫]                                   → %rawHxRepeat⟪ * ⟫ ;
NestedRepeat-many-maybe :     NestedRepeat[%rawHxRepeat⟪ * ⟫, %rawHxRepeat⟪ ? ⟫]                                 → %rawHxRepeat⟪ * ⟫ ;
NestedRepeat-many-many:       NestedRepeat[%rawHxRepeat⟪ * ⟫, %rawHxRepeat⟪ * ⟫]                                 → %rawHxRepeat⟪ * ⟫ ;
NestedRepeat-many-some:       NestedRepeat[%rawHxRepeat⟪ * ⟫, %rawHxRepeat⟪ + ⟫]                                 → %rawHxRepeat⟪ * ⟫ ;
NestedRepeat-many-somesep:    NestedRepeat[%rawHxRepeat⟪ * ⟫, %rawHxRepeat⟪ + _ #HxRegExpSub2# ⟫]                 → $[Error,"Cannot nest * in +_'...' repeater."] ;
NestedRepeat-some-single:     NestedRepeat[%rawHxRepeat⟪ + ⟫, %rawHxRepeat⟪ ⟫]                                   → %rawHxRepeat⟪ + ⟫ ;
NestedRepeat-some-maybe :     NestedRepeat[%rawHxRepeat⟪ + ⟫, %rawHxRepeat⟪ ? ⟫]                                 → %rawHxRepeat⟪ * ⟫ ;
NestedRepeat-some-many:       NestedRepeat[%rawHxRepeat⟪ + ⟫, %rawHxRepeat⟪ * ⟫]                                 → %rawHxRepeat⟪ * ⟫ ;
NestedRepeat-some-some:       NestedRepeat[%rawHxRepeat⟪ + ⟫, %rawHxRepeat⟪ + ⟫]                                 → %rawHxRepeat⟪ + ⟫ ;
NestedRepeat-some-somesep:    NestedRepeat[%rawHxRepeat⟪ + ⟫, %rawHxRepeat⟪ + _ #HxRegExpSub2# ⟫]                 → %rawHxRepeat⟪ + _ #HxRegExpSub2# ⟫ ;
NestedRepeat-somesep-single:  NestedRepeat[%rawHxRepeat⟪ + _ #HxRegExpSub1# ⟫, %rawHxRepeat⟪ ⟫]                   → %rawHxRepeat⟪ + _ #HxRegExpSub1# ⟫ ;
NestedRepeat-somesep-maybe :  NestedRepeat[%rawHxRepeat⟪ + _ #HxRegExpSub1# ⟫, %rawHxRepeat⟪ ? ⟫]                 → $[Error,"Cannot nest +_'...' in ? repeater."] ;
NestedRepeat-somesep-many:    NestedRepeat[%rawHxRepeat⟪ + _ #HxRegExpSub1# ⟫, %rawHxRepeat⟪ * ⟫]                 → $[Error,"Cannot nest +_'...' in * repeater."] ;
NestedRepeat-somesep-some:    NestedRepeat[%rawHxRepeat⟪ + _ #HxRegExpSub1# ⟫, %rawHxRepeat⟪ + ⟫]                 → $[Error,"Cannot nest +_'...' in + repeater."] ;
NestedRepeat-somesep-somesep: NestedRepeat[%rawHxRepeat⟪ + _ #HxRegExpSub1# ⟫, %rawHxRepeat⟪ + _ #HxRegExpSub2# ⟫] → $[Error,"Cannot nest +_'...' in another +_'...' repeater."] ;

P-SubRepeat[HxRepeat, HxRepeat] :: Boolean;

P-SubRepeat-single: P-SubRepeat[%rawHxRepeat⟪ ⟫, #Repeat2] → B_TRUE ;

P-SubRepeat-maybe-single: P-SubRepeat[%rawHxRepeat⟪ ? ⟫, %rawHxRepeat⟪ ⟫] → B_FALSE;
P-SubRepeat-maybe-maybe: P-SubRepeat[%rawHxRepeat⟪ ? ⟫, %rawHxRepeat⟪ ? ⟫] → B_TRUE;
P-SubRepeat-maybe-many: P-SubRepeat[%rawHxRepeat⟪ ? ⟫, %rawHxRepeat⟪ * ⟫] → B_TRUE;
P-SubRepeat-maybe-some: P-SubRepeat[%rawHxRepeat⟪ ? ⟫, %rawHxRepeat⟪ + ⟫] → B_FALSE;
P-SubRepeat-maybe-somesep: P-SubRepeat[%rawHxRepeat⟪ ? ⟫, %rawHxRepeat⟪ + _ #HxRegExpSub2# ⟫] → B_FALSE;

P-SubRepeat-some-single: P-SubRepeat[%rawHxRepeat⟪ + ⟫, %rawHxRepeat⟪ ⟫] → B_FALSE;
P-SubRepeat-some-maybe: P-SubRepeat[%rawHxRepeat⟪ + ⟫, %rawHxRepeat⟪ ? ⟫] → B_FALSE;
P-SubRepeat-some-many: P-SubRepeat[%rawHxRepeat⟪ + ⟫, %rawHxRepeat⟪ * ⟫] → B_TRUE;
P-SubRepeat-some-some: P-SubRepeat[%rawHxRepeat⟪ + ⟫, %rawHxRepeat⟪ + ⟫] → B_TRUE;
P-SubRepeat-some-somesep: P-SubRepeat[%rawHxRepeat⟪ + ⟫, %rawHxRepeat⟪ + _ #HxRegExpSub2# ⟫] → B_FALSE;

P-SubRepeat-many-many: P-SubRepeat[%rawHxRepeat⟪ * ⟫, %rawHxRepeat⟪ * ⟫] → B_TRUE ;
P-SubRepeat-many-other[Data[#_]]: P-SubRepeat[%rawHxRepeat⟪ * ⟫, $[NotMatch,%rawHxRepeat⟪ * ⟫,#_]] → B_FALSE;

P-SubRepeat-somesep-single: P-SubRepeat[%rawHxRepeat⟪ + _ #HxRegExpSub1# ⟫, %rawHxRepeat⟪ ⟫] → B_FALSE;
P-SubRepeat-somesep-maybe: P-SubRepeat[%rawHxRepeat⟪ + _ #HxRegExpSub1# ⟫, %rawHxRepeat⟪ ? ⟫] → B_FALSE;
P-SubRepeat-somesep-many: P-SubRepeat[%rawHxRepeat⟪ + _ #HxRegExpSub1# ⟫, %rawHxRepeat⟪ * ⟫] → B_FALSE;
P-SubRepeat-somesep-some: P-SubRepeat[%rawHxRepeat⟪ + _ #HxRegExpSub1# ⟫, %rawHxRepeat⟪ + ⟫] → B_FALSE;

P-SubRepeat-somesep-string-string: P-SubRepeat[%rawHxRepeat⟪ + _ #HxString1# ⟫, %rawHxRepeat⟪ + _ #HxString2# ⟫] → SameString[UnString[#HxString1#], UnString[#HxString2#]] ;
P-SubRepeat-somesep-string-word: P-SubRepeat[%rawHxRepeat⟪ + _ #HxString1# ⟫, %rawHxRepeat⟪ + _ #HxSeparator2# ⟫] → SameString[UnString[#HxString1#], #HxSeparator2#] ;
P-SubRepeat-somesep-word-string: P-SubRepeat[%rawHxRepeat⟪ + _ #HxSeparator1# ⟫, %rawHxRepeat⟪ + _ #HxString2# ⟫] → SameString[#HxSeparator1#, UnString[#HxString2#]] ;
P-SubRepeat-somesep-word-word: P-SubRepeat[%rawHxRepeat⟪ + _ #HxSeparator1# ⟫, %rawHxRepeat⟪ + _ #HxSeparator2# ⟫] → SameString[#HxSeparator1#, #HxSeparator2#] ;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 6. TEXT NAMING CONVENTIONS.

// P token name and constructor.

P-TokenNameText[$String] :: Text;
-[Data[#Name]]: P-TokenNameText[#Name] → %n⟪†« U-Local[#Name] »⟫ ;

P-TokenConstructorText[$String<!--ModuleName-->, $String] :: Text;
P-TokenConstructorText[#ModuleName, #Name] → %n⟪†« U-QN[#ModuleName, "Token", #Name] »⟫ ;

// P production (= non-terminal = sort) name and constructor.

P-ProductionNameText[$String] :: Text;
-[Data[#Name]]: P-ProductionNameText[#Name] → %n⟪†« U-Local[#Name] »⟫ ;

// P special production name for non-terminals with precedence.

P-ProductionNameWithPrecText[$String, $Numeric] :: Text;
-[Data[#Name,#Prec],Copy[#Name,#Prec]]: P-ProductionNameWithPrecText[#Name, #Prec] → P-ProductionNameText[U-Local[$[If, $[NumericEqual,#Prec,0], #Name, $[:,#Name,$[FormatNumber,#Prec]]]]] ;

P-ProductionNameWithPrec[$String, $Numeric] :: $String;
-[Data[#Name,#Prec],Copy[#Name,#Prec]]: P-ProductionNameWithPrec[#Name, #Prec] → U-Local[$[If, $[NumericEqual,#Prec,0], #Name, $[:,#Name,$[FormatNumber,#Prec]]]] ;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 7. JJ HELPERS.

JJ-StringLiteral[Text] :: Text ;
JJ-StringLiteral[#Literal]
→
%n⟪{sink = sink.start(makeTConstructor(sink, t, «#Literal», net.sf.crsx.CRS.STRING_SORT)).end();}
⟫;

JJ-NumericLiteral[Text] :: Text ;
JJ-NumericLiteral[#Literal]
→
%n⟪{sink = sink.start(makeTConstructor(sink, t, «#Literal», net.sf.crsx.CRS.NUMERIC_SORT)).end();}
⟫;

JJ-Construction[Text, Text] :: Text ;
JJ-Construction[#Constructor, #Content]
→
%n⟪{sink = sink.start(makeTConstructor(sink, t, «#Constructor», null));}
⟦«#Content»⟧{sink = sink.end();}
⟫;



JJ-Token[$String] :: Text ;
JJ-Token[#TokenName]
→
%n⟪<T_†« U-Local[#TokenName] »>
⟫
;

JJ-Nonterminal[Text<!--sink-->, $String<!--Nonterminal-->, Text<!--env-->] :: Text;
JJ-Nonterminal[#sink, #nonterminal, #env]
→
%n⟪«#sink»=N_†« U-Local[#nonterminal] »(«#sink», «#env»)
⟫
;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 8. OTHER HELPERS.

// Convert hx module name to lower case prefix.

P-Prefix[$String] :: $String;
-[Data[#Name]]: P-Prefix[#Name] → $[If, $[Contains,#Name,"."], P-Prefix[$[AfterFirst,#Name,"."]], $[Replace,$[DownCase,#Name],"\"",""]] ;

P-Embed-Prefix[$String] :: $String;
P-Embed-Prefix[#ModuleName] → StringConcat[P-Prefix[#ModuleName], "Embed_"] ;

P-Meta-Prefix[$String] :: $String;
P-Meta-Prefix[#ModuleName] → StringConcat[P-Prefix[#ModuleName], "Meta_"] ;

P-User-Prefix[$String] :: $String;
P-User-Prefix[#ModuleName] → StringConcat[P-Prefix[#ModuleName], "_"] ;

P-user[$String, $String] :: $String ;
P-user[#ModuleName, #Name] → StringConcat3[U-LastName[#ModuleName], "_", #Name] ;

P-hx[$String, $String] :: $String ;
P-hx[#ModuleName, #Name] → StringConcat["Hx_", #Name] ;

P-BaseSortName[HxSort] :: $String;
-[Data[#Sort]]: P-BaseSortName[#Sort] → P-BaseSortName2[#Sort] ;
P-BaseSortName2[HxSort] :: $String;
P-BaseSortName2[           %rawHxSort⟪ #HxSortName# #HxMetaVariables# #HxSimpleSorts# ⟫] → #HxSortName# ;
P-BaseSortName2[$[NotMatch,%rawHxSort⟪ #HxSortName# #HxMetaVariables# #HxSimpleSorts# ⟫,#]] →  "BAD" ;

// Errors.

∀ a . PrepError[$String] :: a;
-[Data[#message]]: PrepError[#message] → $[Error, #message] ;

)] //Prep




/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// // P-ProductionNames: Extract top level productions.
/// //
/// // Only include productions for tokens and sorts that have syntax.
///
/// {$String<!--SortName--> : DeclarationMapEntry} P-ProductionNames[$List[$String]] :: $List[$String];
/// {#DM}P-ProductionNames[()] → () ;
/// {#DM}P-ProductionNames[(#1;#s)] → {#DM}P-ProductionNames2[$[{#DM}Get[DeclarationMapEntry],#1,DME_NONE], #1, #s] ;
///
/// {$String<!--SortName--> : DeclarationMapEntry} P-ProductionNames2[DeclarationMapEntry, $String, $List[$String]] :: $List[$String];
/// {#DM}P-ProductionNames2[DME_NONE, #1, #s] → {#DM}P-ProductionNames[#s] ;
/// {#DM}P-ProductionNames2[DME_TOKEN[#SortName], #1, #s] → (#1 ; {#DM}P-ProductionNames[#s]) ;
/// {#DM}P-ProductionNames2[DME_ATTRIBUTE[#Kind, #Name, #AttributeForm, #AttributeOptions], #1, #s] → {#DM}P-ProductionNames[#s] ;
/// {#DM}P-ProductionNames2[DME_SORT[#Defines, #SortName, #Precs, #Wrapper], #1, #s] → {#DM}P-ProductionNames3[#Defines, #1, #s] ;
///
/// {$String<!--SortName--> : DeclarationMapEntry} P-ProductionNames3[$List[Define], $String, $List[$String]] :: $List[$String];
/// -[Fresh[dummy::HxSortParam]]:
/// {#DM} P-ProductionNames3[(D_ABSTRACTION[a.#Define1[a]]; #Defines), #1, #s] → {#DM} P-ProductionNames3[(#Define1[dummy]; #Defines), #1, #s] ;
/// {#DM} P-ProductionNames3[(D_RULE[#Rule, #RuleSort, #IsData]; #Defines), #1, #s] → {#DM} P-ProductionNames3[#Defines, #1, #s] ;
/// {#DM} P-ProductionNames3[(D_FORM[#Form1, #Kind1]; #Defines), #1, #s] → {#DM} P-ProductionNames4[#Form1, #Defines, #1, #s] ;
/// {#DM} P-ProductionNames3[(D_NONE; #Defines), #1, #s] → {#DM} P-ProductionNames3[#Defines, #1, #s] ;
/// {#DM} P-ProductionNames3[(), #1, #s] → {#DM}P-ProductionNames[#s] ;
///
/// {$String<!--SortName--> : DeclarationMapEntry} P-ProductionNames4[HxForm, $List[Define], $String, $List[$String]] :: $List[$String];
/// {#DM} P-ProductionNames4[Hx_FormParsed[#ParsedForm1, #Prec1, #InheritedRefs], #Defines, #1, #s] → (#1; {#DM}P-ProductionNames[#s]) ;
/// {#DM} P-ProductionNames4[Hx_FormConstruction[#Constructor, #ScopeSortList, #InheritedRefs], #Defines, #1, #s] → {#DM} P-ProductionNames3[#Defines, #1, #s] ;
///
///
///
///
///
///
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// // TEXT LIST OF REPEAT-DERIVED DECLARATIONS.
///
/// P-ProduceDerived[DERIVED_SORT] :: TextMapSort;
/// P-ProduceDerived[DERIVED[#SortName, #Prec, #Repeat]] → P-ProduceRepeat[#Repeat, #SortName, #Prec, P-ProductionNameWithPrecRepeatText[#SortName, #Prec, #Repeat]] ;
///
/// P-ProduceRepeat[HxRepeat, $String, $Numeric, Text] :: TextMapSort;
///
/// P-ProduceRepeat[%rawHxRepeat⟪ ⟫, #s, #p, #name] → EmptyTextMap ;
///
/// -[Data[#s]]:
/// P-ProduceRepeat[%rawHxRepeat⟪ ? ⟫, #s, #p, #name]
/// →
/// SingletonTextMap[TextToString[#name], %n⟪
/// <«#name»> ::= «
///   P-Head[B_TRUE, #ModuleName, $[:,#s,"?"], TextToString[#name], B_FALSE, 0]
/// »( <«P-ProductionNameWithPrecText[#s, #p]»>:#1 {{ $Cons[#1,$Nil] }} | {{ $Nil }} ).
/// « P-Embed-Tail[B_TRUE, $[:,#s,"?"], TextToString[#name]] »⟫]
/// ;
///
/// -[Data[#s]]:
/// P-ProduceRepeat[%rawHxRepeat⟪ * ⟫, #s, #p, #name]
/// →
/// SingletonTextMap[TextToString[#name], %n⟪
/// <«#name»> ::= «
///   P-Head[B_TRUE, #ModuleName, $[:,#s,"*"], TextToString[#name], B_FALSE, 0]
/// »( <«P-ProductionNameWithPrecText[#s, #p]»>:#1 <«#name»>:#2 {{ $Cons[#1,#2] }} | {{ $Nil }} ).
/// « P-Embed-Tail[B_TRUE, $[:,#s,"*"], TextToString[#name]] »⟫]
/// ;
///
/// -[Data[#s]]:
/// P-ProduceRepeat[%rawHxRepeat⟪ + ⟫, #s, #p, #name]
/// →
/// SingletonTextMap[TextToString[#name], %n⟪
/// <«#name»> ::= «
///   P-Head[B_TRUE, #ModuleName, $[:,#s,"+"], TextToString[#name], B_FALSE, 0]
/// » <«P-ProductionNameWithPrecText[#s, #p]»>:#1 ( <«#name»>:#2 {{ $Cons[#1,#2] }} | {{ $Cons[#1,$Nil] }} ) .
/// « P-Embed-Tail[B_TRUE, $[:,#s,"+"], TextToString[#name]] »⟫]
/// ;
///
/// -[Data[#s]]:
/// P-ProduceRepeat[%rawHxRepeat⟪ + _ #HxRegExpSub# ⟫, #s, #p, #name]
/// →
/// SingletonTextMap[TextToString[#name], %n⟪
/// <«#name»> ::= «
///   P-Head[B_TRUE, #ModuleName, RegExpSubSuffix[#HxRegExpSub#, $[:,#s,"+_"]], TextToString[#name], B_FALSE, 0]
/// » <«P-ProductionNameWithPrecText[#s, #p]»>:#1 ( « P-InlineRegExpSimple[#HxRegExpSub#, ""] » <«#name»>:#2 {{ $Cons[#1,#2] }} | {{ $Cons[#1,$Nil] }} ) .
/// « P-Embed-Tail[B_TRUE, RegExpSubSuffix[#HxRegExpSub#, $[:,#s,"+_"]], TextToString[#name]] »⟫]
/// ;
///
///
///
///
///
///
///
///
///
///
///
///
///
///
///
///
///
///
///
///
///
///
///
///
///
///
///
///
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///
/// // PrepBase.crs: CRSX3 SUPPORT LIBRARY FOR HACS PREPROCESSOR OPERATIONS.
/// //
/// // Declarations here depend only on the Prelude and the Hx syntax.
/// //
/// PrepBase[(
///
/// $Use["org/crsx/hacs/Prelude.crs"];
///
/// // Syntax and sorts of hx terms (%rawHx...⟪...⟫).
/// $Use["org/crsx/hacs/Hx.crs"];
///
/// // Syntax and sorts of text (%n⟪...⟫).
/// $CheckGrammar["net.sf.crsx.text.Text"];
/// $Use["net/sf/crsx/text/Text.crs"];
///
/// $Lax;
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// // LOCATION EXTRACTION.
///
/// $StringEntrySort ::=( STRING[$String]; );
///
/// {$String : $StringEntrySort}MakeLocation :: $String;
/// {#L}MakeLocation → MakeLocation2[$[{#L}Get[$StringEntrySort],"$FileLocation",STRING[""]], $[{#L}Get[$StringEntrySort],"$LineLocation",STRING[""]], $[{#L}Get[$StringEntrySort],"$ColumnLocation",STRING[""]]] ;
/// MakeLocation2[$StringEntrySort, $StringEntrySort, $StringEntrySort] :: $String;
/// MakeLocation2[STRING[#file], STRING[#line], STRING[#column]] → $[:,#file," ",#line,":",#column] ;
///
///
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// // SORT EXTRACTION.
///
/// ScopeU-SortName[HxScopeSort] :: $String;
/// ScopeU-SortName[%rawHxScopeSort⟪ #HxSort# #HxRepeat# [ #HxSubstituteSorts# ] ⟫] → SortNameWithRepeat[#HxSort#, #HxRepeat#] ;
/// -[Free[v::Text]]:
/// ScopeU-SortName[%rawHxScopeSort⟪ [ v : #HxSort# ] ⟫                  ] → U-SortName[#HxSort#] ;
/// -[Free[v::Text]]:
/// ScopeU-SortName[%rawHxScopeSort⟪ [ v : #HxSort# ] #HxScopeSort# ⟫] → ScopeU-SortName[#HxScopeSort#] ;
///
/// ScopeSortMetaVar[HxScopeSort, $Numeric] :: $String;
/// -[Discard[#HxSubstituteSorts#]]: ScopeSortMetaVar[%rawHxScopeSort⟪ #HxSort# [ #HxSubstituteSorts# ] ⟫, #n] → SortMetaVar[#HxSort#, #n] ;
/// -[Free[v::Text]]: ScopeSortMetaVar[%rawHxScopeSort⟪ [ v : #HxSort# ] ⟫                  , #n] → SortMetaVar[#HxSort#, #n] ;
///

///
///
///
///
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// // PRODUCTION NAMES.
///
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// // ERRORS.
///
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///
///
///
///
///
///
///
///
///


///
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// // COMPARISON OF FORMS.
///
///
///
///
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// // Extract all repeat-derived sort forms from DM structure.
///
/// DERIVED_SORT ::=( DERIVED[$String, $Numeric<!--Precedence-->, HxRepeat]; );
///
/// {$String<!--SortName--> : DeclarationMapEntry} DerivedSorts[NameSet] :: $List[DERIVED_SORT];
/// {#DM} DerivedSorts[#Names] → FoldNamesWhen[ok x y.{#DM} Then-DerivedSorts2[ok, x, y], #Names, ()] ;
///
/// {$String<!--SortName--> : DeclarationMapEntry} Then-DerivedSorts2[Ok, $String, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// {#DM} Then-DerivedSorts2[OK, #name, #derived] → DerivedSorts2[$[{#DM}Get[DeclarationMapEntry], #name, DME_NONE], #derived];
///
/// DerivedSorts2[DeclarationMapEntry, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
///
/// DerivedSorts2[DME_NONE, #derived] → #derived ;
/// DerivedSorts2[DME_TOKEN[#name], #derived] → #derived ;
/// DerivedSorts2[DME_ATTRIBUTE[#kind, #name, #form, #options], #derived] → #derived ;
///
/// DerivedSorts2[DME_SORT[#Defines, #Name, #Precs, #Wrapper], #derived]
/// →
/// FoldWhen[ok defined derived.Then-DerivedSorts-Defines[ok, defined, derived], #Defines, #derived]
/// ;
///
/// Then-DerivedSorts-Defines[Ok, Define, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// -[Fresh[dummy::HxSortParam]]: Then-DerivedSorts-Defines[OK, D_ABSTRACTION[a . #Define[a]], #derived] → Then-DerivedSorts-Defines[OK, #Define[dummy], #derived] ;
/// Then-DerivedSorts-Defines[OK, D_FORM[#Form, #Kind], #derived] → DerivedSorts-Form[#Form, #derived] ;
/// Then-DerivedSorts-Defines[OK, D_RULE[#Rule, #SortName, #IsDataEquivalence], #derived] → DerivedSorts-Rule[#Rule, #derived] ;
/// Then-DerivedSorts-Defines[OK, D_SYNTHESIZES[#AttributeName], #derived] → #derived ;
/// Then-DerivedSorts-Defines[OK, D_NONE, #derived] → #derived ;
///
/// DerivedSorts-Form[HxForm, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-Form[Hx_FormParsed[#HxParsedForm#, #HxFormPrec#, #InheritedRefs], #derived] → DerivedSorts-ParsedForm[#HxParsedForm#, #derived] ;
/// DerivedSorts-Form[Hx_FormConstruction[#HxConstructor#, #HxScopeSorts#, #InheritedRefs], #derived] → #derived ;
///
/// DerivedSorts-ParsedForm[HxParsedForm, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-ParsedForm[Hx_ParsedFormWord[#Word, #ParsedForm], #derived] → DerivedSorts-ParsedForm[#ParsedForm, #derived] ;
/// DerivedSorts-ParsedForm[Hx_ParsedFormSpace[#Space, #ParsedForm], #derived] → DerivedSorts-ParsedForm[#ParsedForm, #derived] ;
/// DerivedSorts-ParsedForm[Hx_ParsedFormDone, #derived] → #derived ;
/// DerivedSorts-ParsedForm[Hx_ParsedFormTerm[Hx_ScopeSortPrec[#ScopeSort, #Precedence], #ParsedForm], #derived]
/// →
/// DerivedSorts-ScopeSort[#ScopeSort, #Precedence, #Repeat, DerivedSorts-ParsedForm[#ParsedForm, #derived]]
/// ;
///
/// DerivedSorts-ScopeSort[HxScopeSort, $Numeric, HxRepeat, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-ScopeSort[%rawHxScopeSort⟪ #HxSort# #HxRepeat# [ #HxSubstituteSorts1# ] ⟫, #Precedence, #Repeat, #derived] → DerivedSorts-Sort[#HxSort#, #Precedence, NestedRepeat[#HxRepeat#, #Repeat], #derived] ;
/// -[Free[v::Text]]:
/// DerivedSorts-ScopeSort[%rawHxScopeSort⟪ [ v : #HxSort# ] ⟫, #Precedence, #Repeat, #derived] → #derived ;
///
/// DerivedSorts-Sort[HxSort, $Numeric, HxRepeat, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// -[Data[#Repeat]]:
/// DerivedSorts-Sort[#Sort, #Precedence, #Repeat, #derived] → DerivedSorts-Sort2[#Repeat, #Precedence, P-BaseSortName[#Sort], #derived] ;
///
/// DerivedSorts-Sort2[HxRepeat, $Numeric, $String, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-Sort2[%rawHxRepeat⟪ ⟫, #Precedence, #Name, #derived] → #derived ;
/// -[Data[#Repeat,#Name]]:
/// DerivedSorts-Sort2[$[NotMatch,%rawHxRepeat⟪ ⟫,#Repeat], #Precedence, #Name, #derived]
/// →
/// $[IfEmpty, #Name, #derived, (DERIVED[#Name, #Precedence, #Repeat] ; #derived)]
/// ;
///
/// DerivedSorts-Rule[HxRule, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-Rule[%rawHxRule⟪ #HxPriority# #HxConstruction# : #HxConstruction_Pattern# → #HxTerm_Contraction# ⟫, #derived]
/// →
/// DerivedSorts-Term[#HxConstruction_Pattern#, DerivedSorts-Term[#HxTerm_Contraction#, #derived]]
/// ;
///
/// DerivedSorts-Term[HxTerm, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
///
/// DerivedSorts-Term[Hx_OMITTED, #derived] → #derived ;
///
/// -[Free[v::Text]]:
/// DerivedSorts-Term[%rawHxTerm⟪ v #HxAttributes# ⟫, #derived] → DerivedSorts-Attributes[#HxAttributes#, #derived] ;
///
/// -[Free[v::Text]]:
/// DerivedSorts-Term[%rawHxTerm⟪ #HxConstructor# #HxRepeat# v #HxAttributes# ⟫, #derived]
/// →
/// DerivedSorts-Repeat[#HxConstructor#, #HxRepeat#, DerivedSorts-Attributes[#HxAttributes#, #derived]] ;
///
/// DerivedSorts-Term[%rawHxTerm⟪ #HxLiteral# #HxAttributes# ⟫, #derived] → DerivedSorts-Attributes[#HxAttributes#, #derived] ;
///
/// DerivedSorts-Term[Hx_Unparsed[#Unparsed, #Attributes], #derived] → #derived ;
/// DerivedSorts-Term[Hx_UnparsedSorted[#Name, #Repeat, #Unparsed, #Attributes], #derived] → #derived ;
///
/// DerivedSorts-Term[%rawHxTerm⟪ #HxConstructor# (#HxScopes#) #HxAttributes# ⟫, #derived] → DerivedSorts-Scopes[#HxScopes#, DerivedSorts-Attributes[#HxAttributes#, #derived]] ;
///
/// DerivedSorts-Term[%rawHxTerm⟪ #HxConstructor1# #HxRepeat# #HxConstructor# (#HxScopes#) #HxAttributes# ⟫, #derived]
/// →
/// DerivedSorts-Repeat[#HxConstructor1#, #HxRepeat#, DerivedSorts-Scopes[#HxScopes#, DerivedSorts-Attributes[#HxAttributes#, #derived]]]
/// ;
///
/// DerivedSorts-Term[%rawHxTerm⟪ #HxMetaVariable# [#HxTerms#] #HxAttributes# ⟫, #derived]
/// →
/// DerivedSorts-Terms[#HxTerms#, DerivedSorts-Attributes[#HxAttributes#, #derived]]
/// ;
///
/// DerivedSorts-Term[%rawHxTerm⟪ #HxConstructor_Sort# #HxRepeat# #HxMetaVariable# [#HxTerms#] #HxAttributes# ⟫, #derived]
/// →
/// DerivedSorts-Repeat[#HxConstructor_Sort#, #HxRepeat#, DerivedSorts-Terms[#HxTerms#, #derived]]
/// ;
///
/// DerivedSorts-Term[Hx_Special[#v, #Concrete], #derived] → #derived ;
///
/// DerivedSorts-Repeat[$String, HxRepeat, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-Repeat[#Name, %rawHxRepeat⟪ ⟫, #derived] → #derived ;
/// -[Data[#Name,#Repeat]]: DerivedSorts-Repeat[#Name, $[NotMatch,%rawHxRepeat⟪ ⟫,#Repeat], #derived]
/// →
/// $[IfEmpty, #Name, #derived, (DERIVED[#Name, 0, #Repeat] ; #derived)]
/// ;
///
/// DerivedSorts-Scopes[$List[HxScope], $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-Scopes[#Scopes, #derived] → FoldWhen[ok scope derived.Then-DerivedSorts-Scope[ok, scope, derived], #Scopes, #derived] ;
///
/// Then-DerivedSorts-Scope[Ok, HxScope, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// Then-DerivedSorts-Scope[OK, Hx_Scope[#vs, #Term], #derived] → DerivedSorts-Term[#Term, #derived] ;
///
/// DerivedSorts-Terms[$List[HxTerm], $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-Terms[#Terms, #derived] → FoldWhen[ok term derived.Then-DerivedSorts-Term[ok, term, derived], #Terms, #derived] ;
///
/// Then-DerivedSorts-Term[Ok, HxTerm, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// Then-DerivedSorts-Term[OK, #Term, #derived] → DerivedSorts-Term[#Term, #derived] ;
///
/// DerivedSorts-Attributes[$List[HxAttribute], $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-Attributes[(), #derived] → #derived ;
/// DerivedSorts-Attributes[(#a1;#as), #derived] → DerivedSorts-Attribute[#a1, DerivedSorts-Attributes[#as, #derived]] ;
///
/// DerivedSorts-Attribute[HxAttribute, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-Attribute[%rawHxAttribute⟪ #HxAttributeKind# #HxAttributeName# ( #HxTerm# ) ⟫, #derived] → DerivedSorts-Term[#HxTerm#, #derived] ;
/// DerivedSorts-Attribute[%rawHxAttribute⟪ #HxAttributeKind# #HxAttributeName# { #HxTerm# } ⟫, #derived] → DerivedSorts-Term[#HxTerm#, #derived] ;
/// DerivedSorts-Attribute[%rawHxAttribute⟪ #HxAttributeKind# #HxAttributeName# { #HxTerm1# : #HxTerm2# } ⟫, #derived] → DerivedSorts-Term[#HxTerm1#, DerivedSorts-Term[#HxTerm2#, #derived]] ;
/// DerivedSorts-Attribute[%rawHxAttribute⟪ #HxAttributeKind# #HxAttributeName# { ¬ #HxTerm# } ⟫, #derived] → DerivedSorts-Term[#HxTerm#, #derived] ;
///
/// // Name.
/// ProductionNameDerived[DERIVED_SORT] :: Text;
/// ProductionNameDerived[DERIVED[#Name, #Prec, #Repeat]] → P-ProductionNameWithPrecRepeatText[#Name, #Prec, #Repeat] ;
///
/// Un$Hx[HxTerm] :: HxTerm ;
/// Un$Hx[#] → # ;
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// // Extract scope sorts for unparsed constructor.
///
/// {$String : DeclarationMapEntry}
/// ConstructorScopeSorts[$String<!--SortName-->, $String<!--Constructor-->] :: Lifted[$List[HxScopeSort]] ;
///
/// -[Data[#TopSortName]]:
/// {#DM}ConstructorScopeSorts[#TopSortName, #Constructor]
/// →
/// ConstructorScopeSorts0[$[{#DM}Get[DeclarationMapEntry], #TopSortName, DME_NONE], #Constructor]
/// ;
///
/// ConstructorScopeSorts0[DeclarationMapEntry, $String<!--Constructor-->] :: Lifted[$List[HxScopeSort]] ;
/// -[Data[#Entry, #Constructor]]:
/// ConstructorScopeSorts0[#Entry, #Constructor]
/// →
/// ConstructorScopeSorts1[#Entry, #Constructor]
/// ;
///
/// ConstructorScopeSorts1[DeclarationMapEntry, $String<!--Constructor-->] :: Lifted[$List[HxScopeSort]] ;
///
/// ConstructorScopeSorts1[DME_SORT[#Defines, #Name, #Precs, #Wrapper], #Constructor]
/// →
/// ConstructorScopeSorts2[#Defines, #Constructor]
/// ;
/// ConstructorScopeSorts1[$[NotMatch,DME_SORT[#Defines, #Name, #Precs, #Wrapper],#_], #Constructor] → BOTTOM ;
///
/// ConstructorScopeSorts2[$List[Define], $String<!--Constructor-->] :: Lifted[$List[HxScopeSort]] ;
///
/// ConstructorScopeSorts2[(), #Constructor] → BOTTOM ;
///
/// -[Fresh[param::HxSortParam]]:
/// ConstructorScopeSorts2[(D_ABSTRACTION[a.#Define[a]]; #Defines), #Constructor] → ConstructorScopeSorts2[(#Define[param]; #Defines), #Constructor] ;
///
/// ConstructorScopeSorts2[(D_RULE[#Rule, #sort, #IsDataEquivalence?]; #Defines), #Constructor] → ConstructorScopeSorts2[#Defines, #Constructor] ;
///
/// ConstructorScopeSorts2[(D_FORM[#Form, #Kind]; #Defines), #Constructor]
/// →
/// ConstructorScopeSorts3[#Form, #Defines, #Constructor]
/// ;
///
/// ConstructorScopeSorts2[(D_SYNTHESIZES[#AttributeName]; #Defines), #Constructor] → ConstructorScopeSorts2[#Defines, #Constructor] ;
///
/// ConstructorScopeSorts3[HxForm, $List[Define], $String<!--Constructor-->] :: Lifted[$List[HxScopeSort]] ;
/// -[Data[#Constructor1,#Constructor2]]:
/// ConstructorScopeSorts3[Hx_FormConstruction[#Constructor1, #ScopeSorts, #InheritedRefs], #Defines, #Constructor2]
/// →
/// $[If, $[Equal,#Constructor1,#Constructor2], LIFTED[#ScopeSorts], ConstructorScopeSorts2[#Defines, #Constructor2]]
/// ;
/// -[Data[#_]]:
/// ConstructorScopeSorts3[$[NotMatch,Hx_FormConstruction[#Constructor, #ScopeSorts, #InheritedRefs],#_], #Defines, #Constructor2] → ConstructorScopeSorts2[#Defines, #Constructor2] ;
///
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// // Extract sort names.
///
/// {$String : DeclarationMapEntry} SortNameList :: $List[$String] ;
/// {#DM} SortNameList → {#DM} SortNameList2[$[{#DM}Keys[$String]]] ;
///
/// {$String : DeclarationMapEntry} SortNameList2[$List[$String]] :: $List[$String] ;
/// {#DM} SortNameList2[()] → () ;
/// {#DM} SortNameList2[(#Name; #Names)] → {#DM} SortNameList3[$[{#DM}Get[DeclarationMapEntry], #Name], #Names] ;
///
/// {$String : DeclarationMapEntry} SortNameList3[DeclarationMapEntry, $List[$String]] :: $List[$String] ;
/// {#DM} SortNameList3[DME_SORT[#Defines1, #Name1, #Precs1, #Wrapper1], #Names]
/// →
/// (#Name1 ; {#DM} SortNameList2[#Names])
/// ;
///
/// {#DM} SortNameList3[$[NotMatch, DME_SORT[#Defines1, #Name1, #Precs1, #Wrapper1], #_], #Names]
/// →
/// {#DM} SortNameList2[#Names]
/// ;
///
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// // Extract token names.
///
/// {$String : DeclarationMapEntry} TokenNameList :: $List[$String] ;
/// {#DM} TokenNameList → {#DM} TokenNameList2[$[{#DM}Keys[$String]]] ;
///
/// {$String : DeclarationMapEntry} TokenNameList2[$List[$String]] :: $List[$String] ;
/// {#DM} TokenNameList2[()] → () ;
/// {#DM} TokenNameList2[(#Name; #Names)] → {#DM} TokenNameList3[$[{#DM}Get[DeclarationMapEntry], #Name], #Name, #Names] ;
///
/// {$String : DeclarationMapEntry} TokenNameList3[DeclarationMapEntry, $String, $List[$String]] :: $List[$String] ;
/// {#DM} TokenNameList3[DME_TOKEN[#String1], #Name, #Names]
/// →
/// (#Name ; {#DM} TokenNameList2[#Names])
/// ;
///
/// {#DM} TokenNameList3[$[NotMatch, DME_TOKEN[#String1], #_], #Name, #Names]
/// →
/// {#DM} TokenNameList2[#Names]
/// ;
///
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// // Extract attribute names.
///
/// {$String : DeclarationMapEntry} AttributeNameList :: $List[$String] ;
/// {#DM} AttributeNameList → {#DM} AttributeNameList2[$[{#DM}Keys[$String]]] ;
///
/// {$String : DeclarationMapEntry} AttributeNameList2[$List[$String]] :: $List[$String] ;
/// {#DM} AttributeNameList2[()] → () ;
/// {#DM} AttributeNameList2[(#Name; #Names)] → {#DM} AttributeNameList3[$[{#DM}Get[DeclarationMapEntry], #Name], #Names] ;
///
/// {$String : DeclarationMapEntry} AttributeNameList3[DeclarationMapEntry, $List[$String]] :: $List[$String] ;
/// {#DM} AttributeNameList3[DME_ATTRIBUTE[#HxAttributeKind#, #HxAttributeName#, #HxAttributeForm#, #HxAttributeOptions#], #Names]
/// →
/// (#HxAttributeName# ; {#DM} AttributeNameList2[#Names])
/// ;
///
/// {#DM} AttributeNameList3[$[NotMatch, DME_ATTRIBUTE[#HxAttributeKind#, #HxAttributeName#, #HxAttributeForm#, #HxAttributeOptions#], #_], #Names]
/// →
/// {#DM} AttributeNameList2[#Names]
/// ;
///
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// // Sort name for attribute value.
///
/// {$String : DeclarationMapEntry} AttributeValueU-SortName[$String] :: $String;
/// {#DM}AttributeValueU-SortName[#AttributeName] → {#DM}AttributeValueSortName1[$[{#DM}Get[DeclarationMapEntry], #AttributeName, DME_NONE], #AttributeName] ;
///
/// {$String : DeclarationMapEntry} AttributeValueSortName1[DeclarationMapEntry, $String] :: $String;
/// -[Data[#Entry]]:
/// {#DM}AttributeValueSortName1[#Entry, #AttributeName] → {#DM}AttributeValueSortName2[#Entry, #AttributeName] ;
///
/// {$String : DeclarationMapEntry} AttributeValueSortName2[DeclarationMapEntry, $String] :: $String;
/// {#DM}AttributeValueSortName2[DME_ATTRIBUTE[#AttributeKind, #AttributeName, %rawHxAttributeForm⟪ ( #HxSort# ) ⟫, #AttributeOptions], #SortName] → U-SortName[#HxSort#];
/// {#DM}AttributeValueSortName2[DME_ATTRIBUTE[#AttributeKind, #AttributeName, %rawHxAttributeForm⟪ { #HxSort# } ⟫, #AttributeOptions], #SortName] → "";
/// {#DM}AttributeValueSortName2[DME_ATTRIBUTE[#AttributeKind, #AttributeName, %rawHxAttributeForm⟪ { #HxSort1# : #HxSort2# } ⟫, #AttributeOptions], #SortName] → U-SortName[#HxSort2#];
/// -[Data[#_]]: {#DM}AttributeValueSortName2[$[NotMatch,DME_ATTRIBUTE[#AttributeKind, #AttributeName, #AttributeForm, #AttributeOptions],#_], #SortName] → $[Error,"No declaration of attribute"] ;
///
/// {$String : DeclarationMapEntry} AttributeKeyU-SortName[$String] :: $String;
/// {#DM}AttributeKeyU-SortName[#SortName] → {#DM}AttributeKeySortName1[$[{#DM}Get[DeclarationMapEntry], #SortName, DME_NONE], #SortName] ;
///
/// {$String : DeclarationMapEntry} AttributeKeySortName1[DeclarationMapEntry, $String] :: $String;
/// -[Data[#Entry]]:
/// {#DM}AttributeKeySortName1[#Entry, #SortName] → {#DM}AttributeKeySortName2[#Entry, #SortName] ;
///
/// {$String : DeclarationMapEntry} AttributeKeySortName2[DeclarationMapEntry, $String] :: $String;
/// {#DM}AttributeKeySortName2[DME_ATTRIBUTE[#AttributeKind, #AttributeName, %rawHxAttributeForm⟪ ( #HxSort# ) ⟫, #AttributeOptions], #SortName] → "" ;
/// {#DM}AttributeKeySortName2[DME_ATTRIBUTE[#AttributeKind, #AttributeName, %rawHxAttributeForm⟪ { #HxSort# } ⟫, #AttributeOptions], #SortName] → U-SortName[#HxSort#];
/// {#DM}AttributeKeySortName2[DME_ATTRIBUTE[#AttributeKind, #AttributeName, %rawHxAttributeForm⟪ { #HxSort1# : #HxSort2# } ⟫, #AttributeOptions], #SortName] → U-SortName[#HxSort1#];
/// {#DM}AttributeKeySortName2[$[NotMatch,DME_ATTRIBUTE[#AttributeKind, #AttributeName, #AttributeForm, #AttributeOptions],#_], #SortName] → "" ;
///
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// // Initialize otherwise unused maps.
///
/// {$String : DeclarationMapEntry} P-InitOtherMaps[$List[HxAttribute], $String] :: Text;
///
/// {#DM; "$AllInheritedMapNames" : NAMES[#InheritedMapNames]}
/// P-InitOtherMaps[#Attributes, #sep] → P-InitOtherMaps1[FoldWhen[ok a ns.ThenRemoveAttributeName[ok, a, ns], #Attributes, #InheritedMapNames], #sep, $False] ;
///
/// {$String : DeclarationMapEntry} P-CaptureOtherMaps[$List[HxAttribute]] :: Text;
/// {#DM; "$AllInheritedMapNames" : NAMES[#InheritedMapNames]}
/// P-CaptureOtherMaps[#Attributes] → P-InitOtherMaps1[FoldWhen[ok a ns.ThenRemoveAttributeName[ok, a, ns], #Attributes, #InheritedMapNames], "; ", $True] ;
///
/// ThenRemoveAttributeName[Ok, HxAttribute, NameSet] :: NameSet;
/// ThenRemoveAttributeName[OK, %rawHxAttribute⟪ #HxAttributeKind# #HxAttributeName# #HxAttributeValue# ⟫, #MapNames] → RemoveName[#MapNames, #HxAttributeName#] ;
///
/// P-InitOtherMaps1[NameSet, $String, $Boolean] :: Text;
/// P-InitOtherMaps1[#MapNames, #sep, #capture] → P-InitOtherMaps2[NameSetList[#MapNames], #sep, #capture] ;
///
/// P-InitOtherMaps2[$List[$String], $String, $Boolean] :: Text;
/// P-InitOtherMaps2[(), #sep, #capture] → %n⟪⟫ ;
/// P-InitOtherMaps2[(#a;#as), #sep, #capture] → %n⟪†«#sep»"†«#a»" : {« $[If, #capture, %n⟨#InheritedMap_†‹#a›⟩, %n⟨⟩] »}Inherited_†«#a»« P-InitOtherMaps2[#as, "; ", #capture] »⟫ ;
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
