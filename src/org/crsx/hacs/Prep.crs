// PrepPG: RULES FOR CONVERTING HX HACS FORMAT TO PG FORMAT.
//
// Reads the HACS (.hx) file as "Hx" term.
// Emits a CRSX3 ParserGenerator grammar (.pg as text) for the user's terms.
//
// Units:
// . Top level (PG).
// . Resolve imports (PG-ResolveImports).
// . Declaration map datastructure and access (DeclarationMap).
// . Declaration map creation (PG-MakeDeclarationMap).
// . Text of all non-terminal productions (PG-Productions).

// . PG-Lexical: Text of Lexical Declarations.
// . Text naming conventions.

// . JJ Helpers.
// . Other Helpers.


PG[(

// Sorts for generated terms.
$CheckGrammar["org.crsx.hacs.HxRaw"];
///$Use["org/crsx/hacs/HxRaw-sorts.crs"];

// Syntax and sorts of text (%n⟪...⟫).
$CheckGrammar["net.sf.crsx.text.Text"];
$Use["net/sf/crsx/text/Text.crs"];

// Standard prelude.
$Use["org/crsx/hacs/Prelude.crs"];

// Insert options automatically.
$Lax;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// . PG: TOP LEVEL
//
// Convert HACS tree to .pgbase with text of ---
// * .pg parser for user's language (unmarked + USERPG).
// * .crs sort declarations for user's terms (SORTS).
// * .pgtemplate for HACS parser extended with user's meta-terms (unmarked + METAPG).
// * .pg parser for user's meta-terms as embedded in patterns (unmarked + EMBEDPG).
// * .crs sort declarations for meta-terms (METASORTS).
//
// PG1: Extract declarations from HACS hx term with all modules inlined.
// PG2: Generate actual text.

PG[HxModule] :: Text;
PG[%rawHxModule⟦ module #HxModuleName# { #HxDeclarations# } ⟧]
→
PG1[#HxModuleName#, PG-ResolveImports[#HxDeclarations#, #HxModuleName#], dm ds.PG2[dm, ds, #HxModuleName#]]
;

PG1[$String<!--ModuleName-->, $List[HxDeclaration], ok::Ok dm::DeclarationMap.Text] :: Text;
PG1[#ModuleName, #Declarations, ok dm.#[ok,dm]]
→
#[{} PG-MakeDeclarationMap[#Declarations, #ModuleName], #Declarations]
;

PG2[DeclarationMap, $List[HxDeclaration], $String<!--ModuleName-->] :: Text ;
-[Data[#Declarations]]:
PG2[{#DM}DM, #Declarations, #ModuleName]
→
%n⟪/* PG Grammar for /***METAPG&EMBED: HACS module specialized for parsed***/ †« #ModuleName » terms /***EMBEDPG: (embedded terms)***/ */

/* INTERFACE. */

class †« PG-ClassName[#ModuleName] »/***USERPG:Parser***//***METAPG:Hx***//***EMBEDPG:Embed***/ :⟦
/***USERPG&EMBEDPG:<†« {#DM}PG-MainSymbol »>« MapTextConcat[n.%n⟨,<†‹n›>⟩, {#DM}PG-NonMainSymbols] » ***/
/***METAPG:
%%%HXNONTERMINALS%%%
<HxTopTerm>, <HxTopPattern>, <HxAttributes>, <HxSortName>, <HxAttributeName>, <HxConstructor>,
<PresortedMetaApplication>, <PresortedVariable>, <PresortedParsed>, <SortedTerm>,
<MetaApplication>, <BracketedTerms>, <Terms>, <Term>, <Attribute>
***/
⟧

/***USERPG: prefix "†« PG-User-Prefix[#ModuleName] »" ***/
/***METAPG: prefix "†« PG-Meta-Prefix[#ModuleName] »" ***/
/***EMBEDPG: prefix "†« PG-Embed-Prefix[#ModuleName] »" ***/

/***METAPG:
declarations
%{
%%%HXDECLARATIONS%%%
String hx(String s) { return "†« PG-LastName[#ModuleName] »Hx_"+s; }
String user(String s) { return "†« PG-LastName[#ModuleName] »_"+s; }
%}
***/

/***EMBEDPG:
declarations
%{
static String unwrap(String s) {return s.substring(1, s.length()-1);}
String hx(String s) { return "†« PG-LastName[#ModuleName] »Hx_"+s; }
String user(String s) { return "†« PG-LastName[#ModuleName] »_"+s; }
%}
***/

/***USERPG&EMBEDPG:
%{
TOKEN_MGR_DECLS : { int nesting; int nestedState;} /* Used by all nesting constructs. */
%}
***/

/***METASORTS:
/* META-TERM SORTS. */

†« PG-QN[#ModuleName, "NodeSort", "Term"] » ::= (⟦
« FoldNamesWhen[ok n t.PG-then-MetaSorts-ConstructionSortCaseText[ok, #ModuleName, n, t], {#DM} PG-AllSortNames, %n⟨⟩] »⟧
);

†« PG-QN[#ModuleName, "NodeSort", "Scope"] » ::= (⟦
†« PG-QN[#ModuleName, "Tag", "Binder"] »[binder :: †« PG-QN[#ModuleName, "NodeSort", "Term"] » . †« PG-QN[#ModuleName, "NodeSort", "Scope"] »];
†« PG-QN[#ModuleName, "Tag", "Subterm"]»[†« PG-QN[#ModuleName, "NodeSort", "Term"] »]; ⟧
);
***/

/***METAPG:
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
%%%HXPREPRODUCTIONS%%%
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
***/

/***METAPG:
/* HX INTERFACE. */

<HxTopTerm> ::= <PresortedVariable> | <PresortedMetaApplication> | <HxTopPattern> .
<HxTopPattern> ::= <PresortedParsed> | <SortedTerm> .
<HxAttributes> ::= ( {$Cons} <Attribute> <HxAttributes> | {$Nil} ).
<HxSortName> ::= ( « TextJoin[MapNames[n.%n⟨"†‹n›"$⟩, UnionNames[{#DM}PG-AllTokenNames, {#DM}PG-AllSortNames]], %n⟨ | ⟩] » ).
<HxConstructor> ::= (« TextJoin[{#DM} PG-MapAllConstructorSorts[c s.%n⟨"†‹c›"$⟩], %n⟨ | ⟩] » ).

/* GENERAL TERMS. */

<PresortedVariable> ::= <HxVariable>!!!:#v ( {Special}:hx {{#v}} HX_CONCRETE$$:unwrap:{n} <HxAttributes> | <PresortedVariableIs #v> ) .
%{
/* <PresortedVariableIs #variable> */
net.sf.crsx.Sink N_PresortedVariableIs(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env, net.sf.crsx.util.Buffer variable_b) :
{}{⟦
« JJ-Construction[%n⟨user("†‹ PG-user[#ModuleName, "Wrapper"] ›")⟩,
  TextJoin[(
    JJ-StringLiteral[%n⟨storedSort⟩];
    %n⟨{sink = variable_b.term(true).copy(sink, true, net.sf.crsx.util.LinkedExtensibleMap.EMPTY_RENAMING);}⟩;
    %n⟨sink=N_HxAttributes(sink, env)⟩;),
    %n⟨
⟩]] »{return sink;}⟧
}

/* <PresortedMetaApplication> ::= */
net.sf.crsx.Sink N_PresortedMetaApplication$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) : {}{ sink=N_PresortedMetaApplication(sink, env) <EOF> {return sink;} }
net.sf.crsx.Sink N_PresortedMetaApplication(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}{⟦
« JJ-Construction[%n⟨user("†‹ PG-user[#ModuleName, "Wrapper"] ›")⟩,
  TextJoin[(
    JJ-StringLiteral[%n⟨storedSort⟩];
    %n⟨sink=N_MetaApplication(sink, env)⟩;
    %n⟨sink=N_HxAttributes(sink, env)⟩;),
    %n⟨
⟩]] »{return sink;}⟧
}

/* <PresortedParsed> ::= */
net.sf.crsx.Sink N_PresortedParsed$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) : {}{ sink=N_PresortedParsed(sink, env) <EOF> {return sink;} }
net.sf.crsx.Sink N_PresortedParsed(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{Token t;}{
  {sink = sink.start(makeTConstructor(sink, null, user("Wrapper"), null));}
  {sink = sink.start(makeTConstructor(sink, null, storedSort, null)).end();}
  t=<T_HX_CONCRETE>
  {
    try {sink = factory.parser(factory).parse(sink, "†« PG-Embed-Prefix[#ModuleName] »"+storedSort, new java.io.StringReader(unwrap(t.toString())), unit, t.beginLine, t.beginColumn+1, env);}
    catch (java.io.IOException e) {throw new ParseException(e.getMessage());}
    catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) throw (ParseException) cause; else throw new ParseException(e.getMessage());}
  }
  sink=N_HxAttributes(sink, env)
  {return sink.end();}
}

/* <SortedTerm> ::= stand-alone term with explicit sort. */
net.sf.crsx.Sink N_SortedTerm$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) : {}{ sink=N_SortedTerm(sink, env) <EOF> {return sink;} }
net.sf.crsx.Sink N_SortedTerm(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{⟦
String savedSort;
net.sf.crsx.util.Buffer b = new net.sf.crsx.util.Buffer(sink);
net.sf.crsx.Sink s = null;⟧
}{⟦
(
  sink=N_Construction(sink, env)
|⟦
{s = b.sink();}
s=N_HxSortName(s, env)
{savedSort = storedSort; storedSort = b.term(true).constructor().symbol();}
( sink=N_PresortedVariable(sink, env)
| sink=N_Construction(sink, env)
| sink=N_PresortedMetaApplication(sink, env)
| sink=N_PresortedParsed(sink, env)
)
{storedSort = savedSort;}⟧
)
{return sink;}⟧
}
%}

<Construction> ::= (⟦ « TextJoin[Map[s.%n⟨<†‹s›_Construction>⟩, FilterWhen[ok s. {#DM}PG-then-SortHasHx[ok, s], NameSetList[{#DM}PG-AllSortNames]]], %n⟨ | ⟩] »⟧ ).

<MetaApplication> ::= {MetaApplication}:hx <HxMetaVariable> <BracketedTerms> .
<BracketedTerms> ::= ( HX_LBRACKET (<Terms> | {$Nil}) HX_RBRACKET | {$Nil} ) .
<Terms> ::= {$Cons} <Term> (HX_COMMA <Terms> | {$Nil}) .

<Term> ::= <HxVariable>!!! | <SortedTerm> .

<Attribute> ::= ⟦« {#DM} PG-Meta-AttributeAlternatives[#ModuleName, NameSetList[{#DM} PG-AllSynthesizedNames], NameSetList[{#DM}PG-AllInheritedNames]] »⟧ .
***/

/* USER GRAMMAR. */

« {#DM}PG-Productions[#ModuleName] »


/***METAPG:
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
%%%HXPOSTPRODUCTIONS%%%
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
***/

/***USERPG&EMBEDPG:
/* TOKENS. */

« PG-Lexical[#Declarations, #ModuleName] »
***/
⟫
;

PG-then-MetaSorts-ConstructionSortCaseText[OK, #ModuleName, #Name, #rest]
→
%n⟪†« PG-QN[#ModuleName, "Node", #Name] »[†« PG-QN[#ModuleName, "TagSort", #Name] », $List[†« PG-QN[#ModuleName, "NodeSort", "Scope"] »]];
« #rest»⟫
;

{#DM} PG-Meta-AttributeAlternatives[#ModuleName, (), ()] → %n⟪()⟫ ;
{#DM} PG-Meta-AttributeAlternatives[#ModuleName, (#s1; #ss), ()] → %n⟪ HX_UP (⟦« {#DM} PG-Meta-AttributeBodies[#ModuleName, (#s1; #ss), %n⟨⟩] »⟧) ⟫ ;
{#DM} PG-Meta-AttributeAlternatives[#ModuleName, (), (#i1; #is)] → %n⟪ HX_DOWN (⟦« {#DM} PG-Meta-AttributeBodies[#ModuleName, (#i1; #is), %n⟨⟩] »⟧) ⟫ ;
{#DM} PG-Meta-AttributeAlternatives[#ModuleName, (#s1; #ss), (#i1; #is)] → %n⟪ HX_UP (⟦« {#DM} PG-Meta-AttributeBodies[#ModuleName, (#s1; #ss), %n⟨⟩] »⟧)
 | HX_DOWN (⟦« {#DM} PG-Meta-AttributeBodies[#ModuleName, (#i1; #is), %n⟨⟩] »⟧) ⟫ ;

-[Data[#Name]]:
{#DM} PG-Meta-AttributeBodies[#ModuleName, (#Name; #Names), #sep]
→
%n⟪«#sep» « PG-Meta-AttributeBody[#ModuleName, #Name, $[{#DM}Get, #Name, DME_NONE]] »
« PG-Meta-AttributeBodies[#ModuleName, #Names, %n⟨|⟩] »⟫
;

-[Data[#Name]]:
{#DM} PG-Meta-AttributeBodies[#ModuleName, (), #sep]
→
%n⟪⟫
;

PG-Meta-AttributeBody[#ModuleName, #Name, DME_ATTRIBUTE[#AttributeKind, #AttributeName, #AttributeForm, #AttributeOptions]]
→
%n⟪<Attribute« AttributeKindCategory[#AttributeKind] »_†«#AttributeName»>⟫
;

PG-Meta-AttributeBody[#ModuleName, #Name, $[NotMatch,DME_ATTRIBUTE[#AttributeKind, #AttributeName, #AttributeForm, #AttributeOptions],#_]]
→
PrepError[$[:,"Inconsistent attribute...",#Name]]
;

// ALTERNATE TOP LEVEL:

PG-GetModuleName[HxModule] :: Text;
PG-GetModuleName[%rawHxModule⟦ module #HxModuleName# { #HxDeclarations# } ⟧]
→
%n⟪†«$[Replace,#HxModuleName#,"\"",""]»⟫
;

PG-PrintEnvironment[HxModule] :: Text;
PG-PrintEnvironment[%rawHxModule⟦ module #HxModuleName# { #HxDeclarations# } ⟧]
→
PG1[#HxModuleName#, PG-ResolveImports[#HxDeclarations#, #HxModuleName#], dm ds.PG2Print[dm, ds, #HxModuleName#]]
;

PG2Print[DeclarationMap, $List[HxDeclaration], $String<!--ModuleName-->] :: Text ;
-[Data[#ModuleName]]:
PG2Print[{#DM}DM, #Declarations, #ModuleName]
→
%n⟪MODULE='†« $[Replace,#ModuleName,"\"",""] »'
NAME='†« PG-LastName[#ModuleName] »'
SORT='†« {#DM}PG-MainSymbol  »'
SORTS='†« {#DM}PG-MainSymbol »« MapTextConcat[n.%n⟨ †‹n›⟩, {#DM}PG-NonMainSymbols] »'
SINKCLASS='net.sf.crsx.text.TextSink'
PARSERCLASS='†« PG-ClassName[#ModuleName] »Parser'
PREFIX='†« PG-User-Prefix[#ModuleName] »'
METAPARSERCLASS='†« PG-ClassName[#ModuleName] »Hx'
METAPREFIX='†« PG-Meta-Prefix[#ModuleName] »'
EMBEDPARSERCLASS='†« PG-ClassName[#ModuleName] »Embed'
EMBEDPREFIX='†« PG-Embed-Prefix[#ModuleName] »'
⟫
;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// . PG-ResolveImports: RESOLVE IMPORTS.
//
// Echo full list of declarations with all imported modules inlined.
// TODO: Alias MyPrefix$Symbol with ImportedPrefix$Symbol for the imported names.

PG-ResolveImports[$List[HxDeclaration], $String] :: $List[HxDeclaration];

Resolve-Import:
PG-ResolveImports[%rawHxDeclarations⟪ import #HxModuleName# ; #HxDeclarations# ⟫, #ModuleName]
→
PG-ResolveImports[%rawHxDeclarations⟪ %HxEmbeddedModule« $[ParseURL, "hxEmbeddedModule", $[Replace,#HxModuleName#,"\"",""]] » ; #HxDeclarations# ⟫, #ModuleName]
;

Resolve-Module:
PG-ResolveImports[%rawHxDeclarations⟪ module #HxModuleName2# { #HxDeclarations2# } ; #HxDeclarations# ⟫, #ModuleName]
→
%rawHxDeclarations⟪
  module #HxModuleName2# { %HxDeclarations« PG-ResolveImports[#HxDeclarations2#, #HxModuleName2#] » } ;
  %HxDeclarations« PG-ResolveImports[#HxDeclarations#, #ModuleName] »
⟫
;

Resolve-Space:
PG-ResolveImports[%rawHxDeclarations⟪ space #HxRegExp# ; #HxDeclarations# ⟫, #ModuleName]
→
%rawHxDeclarations⟪ space #HxRegExp# ; %HxDeclarations« PG-ResolveImports[#HxDeclarations#, #ModuleName] » ⟫
;

Resolve-Token:
PG-ResolveImports[%rawHxDeclarations⟪ token #HxTokenName# | #HxRegExp# ; #HxDeclarations# ⟫, #ModuleName]
→
%rawHxDeclarations⟪ token #HxTokenName# | #HxRegExp# ; %HxDeclarations« PG-ResolveImports[#HxDeclarations#, #ModuleName] » ⟫
;

Resolve-Fragment:
PG-ResolveImports[%rawHxDeclarations⟪ fragment #HxTokenName# | #HxRegExp# ; #HxDeclarations# ⟫, #ModuleName]
→
%rawHxDeclarations⟪ fragment #HxTokenName# | #HxRegExp# ; %HxDeclarations« PG-ResolveImports[#HxDeclarations#, #ModuleName] » ⟫
;

Resolve-Attribute:
PG-ResolveImports[%rawHxDeclarations⟪ attribute #HxAttributeKind# #HxAttributeName# #HxAttributeForm# ; #HxDeclarations# ⟫, #ModuleName]
→
%rawHxDeclarations⟪ attribute #HxAttributeKind# #HxAttributeName# #HxAttributeForm# ; %HxDeclarations« PG-ResolveImports[#HxDeclarations#, #ModuleName] » ⟫
;

Resolve-Sort:
PG-ResolveImports[%rawHxDeclarations⟪ sort #HxSortName# #HxRepeat# #HxSortAbstraction# ; #HxDeclarations# ⟫, #ModuleName]
→
%rawHxDeclarations⟪ sort #HxSortName# #HxRepeat# #HxSortAbstraction# ; %HxDeclarations« PG-ResolveImports[#HxDeclarations#, #ModuleName] » ⟫
;

Resolve-Main-Sort:
PG-ResolveImports[%rawHxDeclarations⟪ main sort #HxSortName# #HxRepeat# #HxSortAbstraction# ; #HxDeclarations# ⟫, #ModuleName]
→
%rawHxDeclarations⟪ main sort #HxSortName# #HxRepeat# #HxSortAbstraction# ; %HxDeclarations« PG-ResolveImports[#HxDeclarations#, #ModuleName] » ⟫
;

Resolve-NakedAlternative:
PG-ResolveImports[%rawHxDeclarations⟪ #HxSortAlternatives# ; #HxDeclarations# ⟫, #ModuleName]
→
%rawHxDeclarations⟪ #HxSortAlternatives# ; %HxDeclarations« PG-ResolveImports[#HxDeclarations#, #ModuleName] » ⟫
;

ResolveRule:
PG-ResolveImports[%rawHxDeclarations⟪ rule #HxRule# ; #HxDeclarations# ⟫, #ModuleName]
→
%rawHxDeclarations⟪ rule #HxRule# ; %HxDeclarations« PG-ResolveImports[#HxDeclarations#, #ModuleName] » ⟫
;

ResolveNesting:
PG-ResolveImports[%rawHxDeclarations⟪ { #HxDeclarations1# } #HxDeclarations2# ⟫, #ModuleName]
→
%rawHxDeclarations⟪ { %HxDeclarations« PG-ResolveImports[#HxDeclarations1#, #ModuleName] » } %HxDeclarations« PG-ResolveImports[#HxDeclarations2#, #ModuleName] » ⟫
;

ResolveDone:
PG-ResolveImports[%rawHxDeclarations⟪ ⟫, #ModuleName]
→
%rawHxDeclarations⟪ ⟫
;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// . DECLARATION MAPS DATA STRUCTURE (PG-MakeDeclarationMap)
//
// Contains all declarations of tokens, attributes, sorts, and some extras,
// needed for grammar generation.

// Data sort for completed map.

{$String<!--Name--> : DeclarationMapEntry}
DeclarationMap ::=( DM; );

DeclarationMapEntry ::=(
 DME_TOKEN[$String<!--SortName-->];
 DME_ATTRIBUTE[HxAttributeKind, $String<!--AttributeName-->, HxAttributeForm, $List[HxAttributeOption]];
 DME_SORT[$List[Define], $String<!--FullSortName-->, NameSet<!--precs-->, Wrapper, Boolean<!--IsMainSort-->];
 DME_NONE;
 DME_ALIAS[HxSort];
 DME_STRING[$String];
 DME_NAMES[NameSet];
);

Wrapper ::=( NO_WRAPPER; WRAPPER[HxParsedForm]; );

{$String : $StringEntrySort}
Define ::=(
 D_ABSTRACTION[a::HxSortParam . Define];
 D_FORM[HxForm, FormKind];
 D_SYNTHESIZES[$String<!--AttributeName-->];
 D_RULE[HxRule, $String<!--sort-->, Boolean<!--IsDataEquivalence?-->];
 D_NONE;
);

FormKind ::=( FK_DATA[$List[$String]<!--Tags-->]; FK_SCHEME[NameSet<!--inherits-->]; FK_SYMBOL[$Boolean<!--IsStatic-->, $tring<!--token-->]; FK_SUGAR[HxTerm]; FK_ALIAS; );

// Extract all names.

{$String<!--Name--> : DeclarationMapEntry} PG-AllNames :: NameSet;
{#DM; "$AllNames" : DME_NAMES[#Names]} PG-AllNames → #Names ;

{$String<!--Name--> : DeclarationMapEntry} PG-AllSortNames :: NameSet;
{#DM; "$AllSortNames" : DME_NAMES[#Names]} PG-AllSortNames → #Names ;

{$String<!--Name--> : DeclarationMapEntry} PG-AllTokenNames :: NameSet;
{#DM; "$AllTokenNames" : DME_NAMES[#Names]} PG-AllTokenNames → #Names ;

{$String<!--Name--> : DeclarationMapEntry} PG-AllInheritedNames :: NameSet;
{#DM; "$AllInheritedNames" : DME_NAMES[#Names]} PG-AllInheritedNames → #Names ;

{$String<!--Name--> : DeclarationMapEntry} PG-AllInheritedMapNames :: NameSet;
{#DM; "$AllInheritedMapNames" : DME_NAMES[#Names]} PG-AllInheritedMapNames → #Names ;

{$String<!--Name--> : DeclarationMapEntry} PG-AllSynthesizedNames :: NameSet;
{#DM; "$AllSynthesizedNames" : DME_NAMES[#Names]} PG-AllSynthesizedNames → #Names ;

{$String<!--Name--> : DeclarationMapEntry} PG-AllSynthesizedMapNames :: NameSet;
{#DM; "$AllSynthesizedMapNames" : DME_NAMES[#Names]} PG-AllSynthesizedMapNames → #Names ;

// Extract just the token names.

{$String<!--TokenName--> : DeclarationMapEntry} PG-MakeTokenNames :: NameSet;
{#DM} PG-MakeTokenNames[#Names] → FilterNamesWhen[ok n.{#DM} PG-then-TestIfToken[ok, n], #Names] ;

{#DM} PG-then-TestIfToken[OK, #Name] → PG-TestIfToken1[$[{#DM}Get, #Name, DME_NONE]] ;
PG-TestIfToken1[DME_TOKEN[#Name]] → B_TRUE ;
PG-TestIfToken1[$[NotMatch,DME_TOKEN[#Name],#_]] → B_FALSE ;

// Extract just the sort names.

{$String<!--SortName--> : DeclarationMapEntry} PG-MakeSortNames :: NameSet;
{#DM} PG-MakeSortNames[#Names] → FilterNamesWhen[ok n.{#DM} PG-then-TestIfSort[ok, n], #Names] ;

{#DM} PG-then-TestIfSort[OK, #Name] → PG-TestIfSort1[$[{#DM}Get, #Name, DME_NONE]] ;
PG-TestIfSort1[DME_SORT[#Defines, #Name, #Precs, #Wrapper, #IsMain]] → B_TRUE ;
PG-TestIfSort1[$[NotMatch,DME_SORT[#Defines, #Name, #Precs, #Wrapper, #IsMain],#_]] → B_FALSE ;

// Extract main sort name.

{$String<!--SortName--> : DeclarationMapEntry} PG-MainSymbol :: $String ;
{#DM}PG-MainSymbol → {#DM}PG-MainSymbol1[NameSetList[{#DM} PG-AllSortNames], ""] ;

{$String<!--SortName--> : DeclarationMapEntry} PG-MainSymbol1[$List[$String], $String] :: $String ;
{#DM}PG-MainSymbol1[(), #main] → #main ;
-[Data[#n]]: {#DM}PG-MainSymbol1[(#n; #ns), #main] → {#DM}PG-MainSymbol2[$[{#DM}Get, #n, DME_NONE], #ns, #main] ;

{$String<!--SortName--> : DeclarationMapEntry} PG-MainSymbol2[DeclarationMapEntry, $List[$String]] :: $String ;
{#DM}PG-MainSymbol2[DME_SORT[#Defines, #Name, #Precs, #Wrapper, B_TRUE], #ns, #main] → #Name ;
-[Fallback]: {#DM}PG-MainSymbol2[#entry, #ns, #main] → {#DM}PG-MainSymbol1[#ns, #main] ;

// Extract all non-main symbols.

{$String<!--SortName--> : DeclarationMapEntry} PG-NonMainSymbols :: $List[$String] ;
{#DM}PG-NonMainSymbols → {#DM}PG-NonMainSymbols1[NameSetList[UnionNames[{#DM} PG-AllSortNames, {#DM} PG-AllTokenNames]], {#DM}PG-MainSymbol, ()] ;

{$String<!--SortName--> : DeclarationMapEntry} PG-NonMainSymbols1[$List[$String], $String<!--main-->, NameSet] :: $List[$String] ;
{#DM}PG-NonMainSymbols1[(), #main, #accumulated] → #accumulated ;
-[Data[#n]]: {#DM}PG-NonMainSymbols1[(#n; #ns), #main, #accumulated] → {#DM}PG-NonMainSymbols2[$[{#DM}Get, #n, DME_NONE], #ns, #main, #accumulated] ;

{$String<!--SortName--> : DeclarationMapEntry} PG-NonMainSymbols2[DeclarationMapEntry, $List[$String], $String, NameSet] :: $List[$String] ;
{#DM}PG-NonMainSymbols2[DME_SORT[#Defines, #Name, #Precs, #Wrapper, #IsMain], #ns, #main, #accumulated]
→
If[SameString[#main, #Name],
  {#DM}PG-NonMainSymbols1[#ns, #main, #accumulated],
  (#Name; {#DM}PG-NonMainSymbols1[#ns, #main, #accumulated])
]
;
{#DM}PG-NonMainSymbols2[DME_TOKEN[#Name], #ns, #main, #accumulated]
→
(#Name; {#DM}PG-NonMainSymbols1[#ns, #main, #accumulated])
;
-[Fallback]:
{#DM}PG-NonMainSymbols2[#entry, #ns, #main, #accumulated]
→
{#DM}PG-NonMainSymbols1[#ns, #main, #accumulated]
;



// Extract token for symbol sorts...TODO: add sorts and complete patterns.

PG-ExtractSymbolFormToken[RawHxFormParsedSorted[#SortName, #ParsedForm, #prec, #InhRefs]] → PG-ExtractSymbolParsedFormToken[#ParsedForm];
PG-ExtractSymbolFormToken[RawHxFormParsed[#ParsedForm, #prec, #InhRefs]] → PG-ExtractSymbolParsedFormToken[#ParsedForm];

PG-ExtractSymbolParsedFormToken[RawHxParsedFormSpace[#sp, #ParsedForm]] → PG-ExtractSymbolParsedFormToken[#ParsedForm];
PG-ExtractSymbolParsedFormToken[RawHxParsedFormTerm[%rawHxScopeSortPrecRepeat⟪ #HxSortName# #HxFormPrec# #HxRepeat# ⟫, #ParsedForm]] → #HxSortName# ;

-[Data[#SortName]]:
{#DM}PG-SymbolSortTokenName[#SortName]
→
PG-SymbolSortTokenName2[$[{#DM}Get,#SortName,DME_NONE]]
;

PG-SymbolSortTokenName2[DME_SORT[(D_FORM[#Form, FK_SYMBOL[#static, #TokenName]];), #Name, #Precs, #Wrapper, #IsMain]] → #TokenName ;
PG-SymbolSortTokenName2[$[NotMatch,DME_SORT[(D_FORM[#Form, FK_SYMBOL[#static, #TokenName]];), #Name, #Precs, #Wrapper, #IsMain], #_]] → "" ;

// Extract constructors-sorts relationship.

{#DM} PG-MapAllConstructorSorts[c s.#[c,s]] → {#DM} PG-MapAllConstructorsForSorts[NameSetList[{#DM} PG-AllSortNames], c s.#[c,s]] ;

{#DM} PG-MapAllConstructorsForSorts[(),        c s.#[c,s]] → () ;
{#DM} PG-MapAllConstructorsForSorts[(#s; #ss), c s.#[c,s]] → {#DM} PG-MapAllConstructorsForSorts2[{#DM} PG-ConstructorsForSort[#s], #s, #ss, c s.#[c,s]] ;

    {#DM} PG-MapAllConstructorsForSorts2[(),        #s, #ss, c s.#[c,s]] → {#DM} PG-MapAllConstructorsForSorts[#ss, c s.#[c,s]] ;
    {#DM} PG-MapAllConstructorsForSorts2[(#c; #cs), #s, #ss, c s.#[c,s]] → ( #[#c, #s] ; {#DM} PG-MapAllConstructorsForSorts2[#cs, #s, #ss, c s.#[c,s]] ) ;

{#DM} PG-ConstructorsForSort[#s] → PG-EntryConstructors[$[{#DM}Get, #s, DME_NONE]] ;

PG-EntryConstructors[DME_SORT[#Defines, #Name, #Precs, #Wrapper, #IsMain]] → PG-DefinesConstructors[#Defines] ;
PG-EntryConstructors[$[NotMatch,DME_SORT[#Defines, #Name, #Precs, #Wrapper, #IsMain], #_]] → () ;

PG-DefinesConstructors[(D_FORM[RawHxFormConstruction[#Constructor, #ScopeSorts, #InheritedRefs], #FormKind]; #Defines)]
→
(#Constructor; PG-DefinesConstructors[#Defines])
;
PG-DefinesConstructors[($[NotMatch,D_FORM[RawHxFormConstruction[#Constructor, #ScopeSorts, #InheritedRefs], #FormKind],#_]; #Defines)]
→
PG-DefinesConstructors[#Defines]
;
PG-DefinesConstructors[()] → () ;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// . DECLARATION MAP CREATION (PG-MakeDeclarationMap)
//
// Contains all declarations of tokens, attributes, sorts, and some extras,
// needed for grammar generation.

PG-MakeDeclarationMap[$List[HxDeclaration], $String<!--ModuleName-->] :: DeclarationMap ;
PG-MakeDeclarationMap[#Declarations, #ModuleName]
→
{}
PG-MakeDeclarationMap1[#Declarations, #ModuleName, "", NoNames, ok¹ s ss.PG-Finish[ss]] // data without required environment!
;

// Process declarations.

{$String<!--SortName--> : DeclarationMapEntry}
PG-MakeDeclarationMap1[$List[HxDeclaration], $String<!--ModuleName-->, $String<!--LastSortName-->, NameSet<!--Names-->,
                    ok¹::Ok s::$String<!--SortName--> ss::NameSet<!--SortNames--> . DeclarationMap] :: DeclarationMap ;

{#DM}
PG-MakeDeclarationMap1[%rawHxDeclarations⟪ module #HxModuleName2# { #HxDeclarations2# } ; #HxDeclarations# ⟫, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
→
{#DM}
PG-MakeDeclarationMap1[#HxDeclarations2# , #HxModuleName2#, "", #Names, ok¹ s ss.PG-then-Declarations1[ok¹, #HxDeclarations#, #ModuleName, #LastSortName, ss, ok2¹ s2 ss2.#[ok2¹,s2,ss2]]]
;

Declarations-space:
{#DM}
PG-MakeDeclarationMap1[%rawHxDeclarations⟪ space #HxRegExp# ; #HxDeclarations# ⟫, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
→
{#DM}
PG-MakeDeclarationMap1[#HxDeclarations#, #ModuleName, "", #Names, ok¹ s ss.#[ok¹,s,ss]]
;

Declarations-token[Data[#SortName]]:
{#DM}
PG-MakeDeclarationMap1[%rawHxDeclarations⟪ token #HxTokenName# | #HxRegExp# ; #HxDeclarations# ⟫, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
→
{#DM; #HxTokenName# : DME_TOKEN[#HxTokenName#]}
PG-MakeDeclarationMap1[#HxDeclarations#, #ModuleName, "", AddName[#Names, #HxTokenName#], ok¹ s ss.#[ok¹,s,ss]]
;
/// {#DM}
/// PG-MakeDeclarationMapInsertToken[PG-QN[#ModuleName, "NodeSort", #HxTokenName#], #HxDeclarations#, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
/// ;
///     // Local helper to compute qualified token name and insert declaration.
///     -[Data[#QualifiedName]]:
///     {#DM}PG-MakeDeclarationMapInsertToken[#QualifiedName, #Declarations, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
///     →
///     {#DM; #QualifiedName : DME_TOKEN[#QualifiedName]}
///     PG-MakeDeclarationMap1[#Declarations, #ModuleName, "", AddName[#Names, #QualifiedName], ok¹ s ss.#[ok¹,s,ss]]
///     ;

Declarations-fragment:
{#DM}
PG-MakeDeclarationMap1[%rawHxDeclarations⟪ fragment #HxTokenName# | #HxRegExp# ; #HxDeclarations# ⟫, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
→
{#DM}
PG-MakeDeclarationMap1[#HxDeclarations#, #ModuleName, "", #Names, ok¹ s ss.#[ok¹,s,ss]]
;

Declarations-attribute[Data[#HxAttributeName#,#HxAttributeForm#]]:
{#DM}
PG-MakeDeclarationMap1[%rawHxDeclarations⟪ attribute #HxAttributeKind# #HxAttributeName# #HxAttributeForm# ; #HxDeclarations# ⟫, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
→
{#DM; #HxAttributeName# : DME_ATTRIBUTE[#HxAttributeKind#, #HxAttributeName#, #HxAttributeForm#, ()]}
PG-MakeDeclarationMap1[#HxDeclarations#, #ModuleName, "", AddName[#Names, #HxAttributeName#], ok¹ s ss.#[ok¹,s,ss]]
;
/// {#DM}
/// PG-MakeDeclarationMapInsertAttribute[PG-QN[#ModuleName, "Attribute" #HxAttributeName#], #HxAttributeKind#, #HxAttributeForm#, #HxAttributeOptions#, #HxDeclarations#, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
/// ;
///     // Local helper to compute qualified attribute name and insert declaration.
///     -[Data[#QualifiedName]]:
///     {#DM}PG-MakeDeclarationMapInsertAttribute[#QualifiedName, #AttributeKind, #AttributeForm, #AttributeOptions, #Declarations, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
///     →
///     {#DM; #QualifiedName : DME_ATTRIBUTE[#AttributeKind, #QualifiedName, #AttributeForm, #AttributeOptions]}
///     PG-MakeDeclarationMap1[#Declarations, #ModuleName, "", AddName[#Names, #QualifiedName], ok¹ s ss.#[ok¹,s,ss]]
///     ;

Declarations-sort:
{#DM}
PG-MakeDeclarationMap1[%rawHxDeclarations⟪ sort #HxSortName# #HxRepeat# #HxSortAbstraction# ; #HxDeclarations# ⟫, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
→
{#DM}
PG-SortAbstraction[#HxSortAbstraction#, B_FALSE, #ModuleName, PG-SortNameWithRepeat1[#HxSortName#, #HxRepeat#], #Names, ok¹ s ss.PG-then-Declarations1[ok¹, #HxDeclarations#, #ModuleName, s, ss, ok2¹ s2 ss2.#[ok2¹,s2,ss2]]]
;
/// {#DM}
/// PG-MakeDeclarationMapInsertSort[PG-QN[#ModuleName, "NodeSort", #HxSortName#], #HxRepeat#, #HxSortAbstraction#, #HxDeclarations#, B_TRUE, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
/// ;
///     // Local helper to compute qualified sort name and insert declaration.
///     -[Data[#QualifiedName]]:
///     {#DM}PG-MakeDeclarationMapInsertSort[#QualifiedName, #Repeat, #SortAbstraction, #Declarations, #IsMain, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
///     →
///     {#DM}
///     PG-SortAbstraction[#SortAbstraction, #IsMain, #ModuleName, PG-SortNameWithRepeat1[#QualifiedName, #Repeat], #Names, ok¹ s ss.PG-then-Declarations1[ok¹, #Declarations, #ModuleName, s, ss, ok2¹ s2 ss2.#[ok2¹,s2,ss2]]]
///     ;

Declarations-main-sort:
{#DM}
PG-MakeDeclarationMap1[%rawHxDeclarations⟪ main sort #HxSortName# #HxRepeat# #HxSortAbstraction# ; #HxDeclarations# ⟫, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
→
{#DM}
PG-SortAbstraction[#HxSortAbstraction#, B_TRUE, #ModuleName, PG-SortNameWithRepeat1[#HxSortName#, #HxRepeat#], #Names, ok¹ s ss.PG-then-Declarations1[ok¹, #HxDeclarations#, #ModuleName, s, ss, ok2¹ s2 ss2.#[ok2¹,s2,ss2]]]
;
/// {#DM}
/// PG-MakeDeclarationMapInsertSort[PG-QN[#ModuleName, "NodeSort", #HxSortName#], #HxRepeat#, #HxSortAbstraction#, #HxDeclarations#, B_FALSE, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
/// ;

Declarations-alternatives:
{#DM}
PG-MakeDeclarationMap1[%rawHxDeclarations⟪ #HxSortAlternatives# ; #HxDeclarations# ⟫, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
→
{#DM}
PG-SortAlternatives[#HxSortAlternatives#, #ModuleName, #LastSortName, #Names, ok¹ s ss.PG-then-Declarations1[ok¹, #HxDeclarations#, #ModuleName, s, ss, ok2¹ s2 ss2.#[ok2¹,s2,ss2]]]
;

Declarations-rule:
{#DM}
PG-MakeDeclarationMap1[%rawHxDeclarations⟪ rule #HxRule# ; #HxDeclarations# ⟫, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
→
{#DM}
PG-InsertDefine[D_RULE[#HxRule#, PG-RuleTopSort[#HxRule#, #LastSortName], B_FALSE], B_BALSE<!--NotMain-->, #ModuleName, PG-RuleTopSort[#HxRule#, #LastSortName], #Names, ok¹ s ss.PG-then-Declarations1[ok¹, #HxDeclarations#, #ModuleName, s, ss, ok2¹ s2 ss2.#[ok2¹,s2,ss2]]]
;

    // Local helper to extract sort of rule.
    //
    PG-RuleTopSort[HxRule, $String<!--FallBackName-->] :: $String;
    PG-RuleTopSort[%rawHxRule⟪ #HxPriority# [ #HxOptions# ] #HxTopPattern# → #HxTopTerm# ⟫, #FallBack]
    →
    PG-TermTopSort[#HxTopPattern#, #FallBack]
    ;
    //
    PG-TermTopSort[HxTerm, $String<!--FallBackName-->] :: $String;
    -[Free[v::Text]]:
    PG-TermTopSort[%rawHxTerm⟪ v #HxAttributes# ⟫, #FallbackSortName] → PG-CheckString[#FallbackSortName] ;
    -[Free[v::Text]]:
    PG-TermTopSort[%rawHxTerm⟪ #HxConstructor1# #HxRepeat1# v #HxAttributes# ⟫, #FallbackSortName] → PG-SortRepeatString[#HxConstructor1#, #HxRepeat1#] ;
    PG-TermTopSort[RawHxUnparsed[#Unparsed, #Attributes], #FallbackSortName] → PG-CheckString[#FallbackSortName] ;
    PG-TermTopSort[RawHxUnparsedSorted[#SortName, #Repeat, #Unparsed, #HxAttributes#], #FallbackSortName] → #SortName ;
    PG-TermTopSort[%rawHxTerm⟪ #HxConstructor# ( #HxScopes# ) #HxAttributes# ⟫, #FallbackSortName] → PG-CheckString[#FallbackSortName] ;
    PG-TermTopSort[%rawHxTerm⟪ #HxConstructor1# #HxRepeat1# #HxConstructor2# ( #HxScopes# ) #HxAttributes# ⟫, #FallbackSortName] → PG-SortRepeatString[#HxConstructor1#, #HxRepeat1#] ;
    PG-TermTopSort[%rawHxTerm⟪ #HxMetaVariable# [ #HxTerms# ] #HxAttributes# ⟫, #FallbackSortName] → PG-CheckString[#FallbackSortName] ;
    PG-TermTopSort[%rawHxTerm⟪ #HxConstructor1# #HxRepeat1# #HxMetaVariable# [ #HxTerms# ] #HxAttributes# ⟫, #FallbackSortName] → PG-SortRepeatString[#HxConstructor1#, #HxRepeat1#] ;
    PG-TermTopSort[%rawHxTerm⟪ #HxLiteral# #HxAttributes# ⟫, #FallbackSortName] → PG-CheckString[#FallbackSortName] ;
    PG-TermTopSort[RawHxSpecial[#v, #Concrete], #FallbackSortName] → PG-CheckString[#FallbackSortName] ;
    //
    PG-CheckString[$String] :: $String;
    PG-CheckString[#String] → #String ; //$[IfEmpty, #String, PrepError[$[:,"Impossible HACS component ",#String]], #String] ;
    //
    PG-SortRepeatString[$String, HxRepeat] :: $String;
    -[Data[#SortName]]: PG-SortRepeatString[#SortName, #Repeat] → $[IfEmpty, #SortName, "", PG-SortRepeatString2[#SortName, #Repeat]] ;
    PG-SortRepeatString2[$String, HxRepeat] :: $String;
    PG-SortRepeatString2[#SortName, %rawHxRepeat⟪ ⟫] → #SortName ;
    PG-SortRepeatString2[#SortName, %rawHxRepeat⟪ ? ⟫] → $[:,#SortName,"?"] ;
    PG-SortRepeatString2[#SortName, %rawHxRepeat⟪ * ⟫] → $[:,#SortName,"*"] ;
    PG-SortRepeatString2[#SortName, %rawHxRepeat⟪ + ⟫] → $[:,#SortName,"+"] ;
    PG-SortRepeatString2[#SortName, %rawHxRepeat⟪ + _ #HxRegExpSub# ⟫] → PG-RegExpSubSuffix[#HxRegExpSub#, $[:,#SortName,"+_"]] ;
    //
    PG-RegExpSubSuffix[HxRegExpSimple, $String] :: $String;
    -[Data[#HxString#]]: PG-RegExpSubSuffix[%rawHxRegExpSub⟪ #HxString# ⟫, #prefix] → $[:,#prefix,#HxString#] ;
    -[Data[#HxSeparator#]]:   PG-RegExpSubSuffix[%rawHxRegExpSub⟪ #HxSeparator# ⟫,   #prefix] → $[:,#prefix,#HxSeparator#] ;
    //
    PG-RegExpSubWord[HxRegExpSimple] :: $String;
    -[Data[#HxString#]]: PG-RegExpSubWord[%rawHxRegExpSub⟪ #HxString# ⟫] → $[Rescape, #HxString#] ;
    -[Data[#HxSeparator#]]:   PG-RegExpSubWord[%rawHxRegExpSub⟪ #HxSeparator# ⟫] → #HxSeparator# ;

Declarations-local:
{#DM}
PG-MakeDeclarationMap1[%rawHxDeclarations⟪ { #HxDeclarations2# } #HxDeclarations# ⟫, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
→
{#DM}
PG-MakeDeclarationMap1[#HxDeclarations2# , #ModuleName, #LastSortName, #Names, ok¹ s ss.PG-then-Declarations1[ok¹, #HxDeclarations#, #ModuleName, #LastSortName, ss, ok2¹ s2 ss2.#[ok2¹,s2,ss2]]]
;

Declarations-none:
{#DM}
PG-MakeDeclarationMap1[%rawHxDeclarations⟪ ⟫, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
→
{#DM}
#[OK, #LastSortName, #Names]
;

// Delayed variant.
{$String<!--SortName--> : DeclarationMapEntry}
PG-then-Declarations1[Ok, $List[HxDeclaration], $String<!--ModuleName-->, $String<!--LastSortName-->, NameSet<!--SortNames-->,
                      ok¹::Ok s::$String<!--SortName--> ss::NameSet<!--SortNames--> . DeclarationMap] :: DeclarationMap ;
//
{#DM}
PG-then-Declarations1[OK, #Declaration*, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
→
{#DM}
PG-MakeDeclarationMap1[#Declaration*, #ModuleName, #LastSortName, #Names, ok¹ s ss.#[ok¹,s,ss]]
;

// Sort declarations factor any leading parameters over all declarations.

{$String<!--SortName--> : DeclarationMapEntry}
PG-SortAbstraction[HxSortAbstraction, Boolean<!--IsMain-->, $String<!--ModuleName-->, $String<!--SortName-->, NameSet<!--SortNames-->,
                   ok¹::Ok s::$String<!--SortName--> ss::NameSet<!--SortNames--> . DeclarationMap] :: DeclarationMap ;

{#DM}
PG-SortAbstraction[#SortAbstraction, #IsMain, #ModuleName, #Name, #Names, ok¹ s ss.#[ok¹, s, ss]]
→
{#DM}
PG-InsertDefines[PG-SortAbstractionDefines[#SortAbstraction], #IsMain, #ModuleName, #Name, #Names, ok¹ s ss.#[ok¹, s, ss]]
;
{$String<!--SortName--> : DeclarationMapEntry}
PG-SortAlternatives[$List[HxSortAlternative], $String<!--ModuleName-->, $String<!--SortName-->, NameSet<!--SortNames-->,
                   ok¹::Ok s::$String<!--SortName--> ss::NameSet<!--SortNames--> . DeclarationMap] :: DeclarationMap ;

{#DM}
PG-SortAlternatives[(), #ModuleName, #Name, #Names, ok¹ s ss.#[ok¹, s, ss]]
→
{#DM}
#[OK, #Name, #Names]
;

-[Data[#Name]]:
{#DM}
PG-SortAlternatives[(#sa;#sas), #ModuleName, #Name, #Names, ok¹ s ss.#[ok¹, s, ss]]
→
$[IfEmpty, #Name, PG-SortAlternatives-Error,
  {#DM}PG-InsertDefines[PG-SortAlternativesDefines[(#sa;#sas)], B_FALSE, #ModuleName, #Name, #Names, ok¹ s ss.#[ok¹, s, ss]]]
;
PG-SortAlternatives-Error :: DeclarationMap;
PG-SortAlternatives-Error → $[Error,"Error: cannot process stand-alone SortAlternatives with no current sort."];

PG-SortAbstractionDefines[HxSortAbstraction] :: $List[Define] ;
PG-SortAbstractionDefines[%rawHxSortAbstraction⟪ #HxSortAlternatives# ⟫] → PG-SortAlternativesDefines[#HxSortAlternatives#] ;
PG-SortAbstractionDefines[%rawHxSortAbstraction⟪ a #HxSortAbstraction#⦃a⦄  ⟫] → PG-SortAbstractionDefines2[a.PG-SortAbstractionDefines[#HxSortAbstraction#[a]]] ;

PG-SortAbstractionDefines2[a::HxSortParam.$List[Define]] :: $List[Define] ;
PG-SortAbstractionDefines2[a.$Nil] → () ;
PG-SortAbstractionDefines2[a.$Cons[#Define[a], #Defines[a]]] → ( D_ABSTRACTION[a.#Define[a]] ; PG-SortAbstractionDefines2[a.#Defines[a]] ) ;

PG-SortAlternativesDefines[$List[HxSortAlternative]] :: $List[Define] ;
PG-SortAlternativesDefines[%rawHxSortAlternatives⟪ ⟫] → () ;
PG-SortAlternativesDefines[%rawHxSortAlternatives⟪ #HxSortAlternative# #HxSortAlternatives# ⟫]
→
( PG-SortAlternativeDefine[#HxSortAlternative#] ; PG-SortAlternativesDefines[#HxSortAlternatives#] )
;

PG-SortAlternativeDefine[HxSortAlternative] :: Define ;

PG-SortAlternativeDefine[{#LOC} %rawHxSortAlternative⟪ | scheme #HxForm# ⟫] → {#LOC} D_FORM[#HxForm#, FK_SCHEME[PG-FormInheritedAttributes[#HxForm#]]] ;
PG-SortAlternativeDefine[{#LOC} %rawHxSortAlternative⟪ | data #HxForm# ⟫] → {#LOC} D_FORM[#HxForm#, FK_DATA[()]];
PG-SortAlternativeDefine[{#LOC} %rawHxSortAlternative⟪ | symbol #HxForm# ⟫] → {#LOC} D_FORM[#HxForm#, FK_SYMBOL[$False, PG-ExtractSymbolFormToken[#HxForm#]]];
PG-SortAlternativeDefine[{#LOC} %rawHxSortAlternative⟪ | static symbol #HxForm#  ⟫] → {#LOC} D_FORM[#HxForm#, FK_SYMBOL[$True, PG-ExtractSymbolFormToken[#HxForm#]]];
PG-SortAlternativeDefine[{#LOC} %rawHxSortAlternative⟪ | sugar #HxForm# → #HxTerm# ⟫] → {#LOC} D_FORM[#HxForm#, FK_SUGAR[#HxTerm#]] ;

PG-SortAlternativeDefine[{#LOC} %rawHxSortAlternative⟪ | ↑ #HxAttributeName# ⟫] → {#LOC} D_SYNTHESIZES[#HxAttributeName#] ;

    // Local helper to extract list of attributes from Form.
    //
    PG-FormInheritedAttributes[HxForm] :: NameSet;
    PG-FormInheritedAttributes[RawHxFormParsedSorted[#Name, #ParsedForm, #Prec, #InheritedRefs]] → PG-InheritedRefsList[#InheritedRefs] ;
    PG-FormInheritedAttributes[RawHxFormParsed[#ParsedForm, #Prec, #InheritedRefs]] → PG-InheritedRefsList[#InheritedRefs] ;
    PG-FormInheritedAttributes[RawHxFormConstruction[#Constructor, #ScopeSorts, #InheritedRefs]] → PG-InheritedRefsList[#InheritedRefs] ;
    //
    PG-InheritedRefsList[$List[HxInheritedRef]] :: NameSet;
    PG-InheritedRefsList[()] → NoNames ;
    PG-InheritedRefsList[(%rawHxInheritedRef⟪ ↓ #HxAttributeName1# ⟫; #refs)]
    →
    AddName[PG-InheritedRefsList[#refs], #HxAttributeName1#]
    ;

// Finish by inserting all precedence links.

{$String<!--SortName--> : DeclarationMapEntry} PG-Finish[NameSet] :: DeclarationMap;
{#DM} PG-Finish[#Names] → {#DM} PG-Finish0[#Names, #Names] ;

// Process all sort names.

{$String<!--SortName--> : DeclarationMapEntry} PG-Finish0[NameSet, NameSet] :: DeclarationMap;
{#DM} PG-Finish0[#RestNames, #Names] → {#DM} PG-Finish1[HasNames[#RestNames], #RestNames, #Names] ;

{$String<!--SortName--> : DeclarationMapEntry} PG-Finish1[Boolean, NameSet, NameSet] :: DeclarationMap;
{#DM} PG-Finish1[B_FALSE, #RestNames, #Names]
→
{#DM} PG-Finish9[#Names, {#DM} PG-MakeSortNames[#Names], {#DM} PG-MakeTokenNames[#Names], {#DM} PG-MakeInheritedNames, {#DM} PG-MakeInheritedMapNames, {#DM} PG-MakeSynthesizedNames, {#DM} PG-MakeSynthesizedMapNames]
;
{#DM} PG-Finish1[B_TRUE, #RestNames, #Names]
→
{#DM} PG-Finish2[FirstName[#RestNames], RemoveFirstName[#RestNames], #Names]
;

{$String<!--SortName--> : DeclarationMapEntry} PG-Finish2[$String, NameSet, NameSet] :: DeclarationMap;
-[Data[#Name]]: {#DM} PG-Finish2[#Name, #RestNames, #Names] → {#DM} PG-Finish3[$[{#DM}Get[DeclarationMapEntry], #Name, DME_NONE], #RestNames, #Names] ;

{$String<!--SortName--> : DeclarationMapEntry} PG-Finish3[DeclarationMapEntry, NameSet, NameSet] :: DeclarationMap;

{#DM} PG-Finish3[DME_NONE, #RestNames, #Names]
→
{#DM} PG-Finish0[#RestNames, #Names]
;

{#DM} PG-Finish3[DME_TOKEN[#Name], #RestNames, #Names]
→
{#DM} PG-Finish0[#RestNames, #Names]
;

{#DM} PG-Finish3[DME_ATTRIBUTE[#AttributeKind1, #AttributeName1, #AttributeForm1, #AttributeOptions1], #RestNames, #Names]
→
{#DM} PG-Finish0[#RestNames, #Names]
;

{#DM} PG-Finish3[DME_SORT[#Defines1, #Name1, #Precs1, #Wrapper1, #IsMain], #RestNames, #Names]
→
{#DM} PG-Finish4[#Precs1, 0, #Name1, #RestNames, #Names]
;

// Find largest precedences.

{$String<!--SortName--> : DeclarationMapEntry} PG-Finish4[NameSet, $Numeric, $String, NameSet, NameSet] :: DeclarationMap;
-[Data[#Precs]]:
{#DM} PG-Finish4[#Precs, #MaxPrec, #Name, #RestNames, #Names]
→
{#DM} PG-Finish5[HasNames[#Precs], #Precs, #MaxPrec, #Name, #RestNames, #Names]
;

{$String<!--SortName--> : DeclarationMapEntry} PG-Finish5[Boolean, NameSet, $Numeric, $String, NameSet, NameSet] :: DeclarationMap;

{#DM} PG-Finish5[B_FALSE, #Precs, #MaxPrec, #Name, #RestNames, #Names]
→
// Got the highest used precedence!
{#DM} PG-Finish7[#MaxPrec, #Name, #RestNames, #Names]
;

{#DM} PG-Finish5[B_TRUE, #Precs, #MaxPrec, #Name, #RestNames, #Names]
→
{#DM} PG-Finish6[FirstName[#Precs], RemoveFirstName[#Precs], #MaxPrec, #Name, #RestNames, #Names]
;

{$String<!--SortName--> : DeclarationMapEntry} PG-Finish6[$String, NameSet, $Numeric, $String, NameSet, NameSet] :: DeclarationMap;
-[Data[#Prec,#Precs,#MaxPrec]]:
{#DM} PG-Finish6[#Prec, #Precs, #MaxPrec, #Name, #RestNames, #Names]
→
{#DM} PG-Finish4[#Precs, $[If, $[GreaterThan, $[Decimal,#Prec], #MaxPrec], $[Decimal,#Prec], #MaxPrec], #Name, #RestNames, #Names]
;

// Add links for all precedences from max down to 0.

{$String<!--SortName--> : DeclarationMapEntry} PG-Finish7[$Numeric, $String, NameSet, NameSet] :: DeclarationMap;

-[Data[#Prec,#Name],Share[#RestNames,#Names]]:
{#DM} PG-Finish7[#Prec, #Name, #RestNames, #Names]
→
$[If, $[GreaterThan,#Prec,0],
  {#DM} PG-InsertDefine[PG-LinkDefine[#Name, #Prec], B_FALSE, "", #Name, #Names,
	ok¹ s ss.PG-then-Finish7[ok¹, $[Minus,#Prec,1], s, #RestNames, ss]],
  {#DM} PG-Finish0[#RestNames, #Names]]
;

{$String<!--SortName--> : DeclarationMapEntry} PG-then-Finish7[Ok, $Numeric, $String, NameSet, NameSet] :: DeclarationMap;
{#DM} PG-then-Finish7[OK, #Prec, #Name, #RestNames, #Names]
→
{#DM} PG-Finish7[#Prec, #Name, #RestNames, #Names]
;

{$String<!--SortName--> : DeclarationMapEntry} PG-Finish9[NameSet<!--All-->, NameSet<!--Sorts-->, NameSet<!--Tokens-->, NameSet, NameSet, NameSet, NameSet] :: DeclarationMap;
{#DM} PG-Finish9[#Names, #SortNames, #TokenNames, #InheritedNames, #InheritedMapNames, #SynthesizedNames, #SynthesizedMapNames]
→
{#DM; "$AllNames" : DME_NAMES[#Names];
      "$AllSortNames" : DME_NAMES[#SortNames];
      "$AllTokenNames" : DME_NAMES[#TokenNames];
      "$AllInheritedNames" : DME_NAMES[#InheritedNames];
      "$AllInheritedMapNames" : DME_NAMES[#InheritedMapNames];
      "$AllSynthesizedNames" : DME_NAMES[#SynthesizedNames];
      "$AllSynthesizedMapNames" : DME_NAMES[#SynthesizedMapNames]}
DM[#Names]
;

PG-LinkDefine[$String, $Numeric] :: Define;
-[Data[#Name,#Prec]]:
PG-LinkDefine[#Name, #Prec]
→
// NOTE: hand-crafted!
{}
D_FORM[
  RawHxFormParsedSorted[
    #Name,
    RawHxParsedFormTerm[
      RawHxScopeSortPrecRepeat[
        RawHxScopeSort[RawHxSort[RawHxSortName[#Name, '$Nil'], '$Nil'], RawHxRepeatSingle, '$Nil'],
        #Prec,
        RawHxRepeatSingle],
      RawHxParsedFormDone],
    $[Minus,#Prec,1],
    ()],
  FK_ALIAS]
;




// Insert list of defines.

{$String<!--SortName--> : DeclarationMapEntry}
PG-InsertDefines[$List[Define], Boolean<!--IsMain-->, $String<!--ModuleName-->, $String<!--SortName-->, NameSet<!--SortNames-->,
                 ok¹::Ok s::$String<!--SortName--> ss::NameSet<!--SortNames--> . DeclarationMap] :: DeclarationMap ;

{#DM}
PG-InsertDefines[(), #IsMain, #ModuleName, #Name, #Names, ok¹ s ss.#[ok¹,s,ss]]
→
{#DM}
PG-InsertDefinesMain[$[{#DM}Get[DeclarationMapEntry], #Name, DME_NONE], #IsMain, #Name, #Names, ok¹ s ss.#[ok¹,s,ss]]
;

    {#DM} PG-InsertDefinesMain[DME_SORT[#existingDefines1, #Name1, #Precs1, #Wrapper1, #IsMain1], #IsMain, #Name, #Names, ok¹ s ss.#[ok¹,s,ss]]
    →
    {#DM} PG-InsertDefinesMain1[#existingDefines1, #Name1, #Precs1, #Wrapper1, Or[#IsMain1, #IsMain], #Name, #Names, ok¹ s ss.#[ok¹,s,ss]]
    ;
    -[Data[#IsMain]]:
    {#DM} PG-InsertDefinesMain1[#existingDefines1, #Name1, #Precs1, #Wrapper1, #IsMain, #Name, #Names, ok¹ s ss.#[ok¹,s,ss]]
    → 
    {#DM; #Name : DME_SORT[#existingDefines1, #Name1, #Precs1, #Wrapper1, #IsMain]} #[OK, #Name, #Names]
    ;
    {#DM} PG-InsertDefinesMain[$[NotMatch,DME_SORT[#existingDefines1, #Name1, #Precs1, #Wrapper1, #IsMain1],#_], #IsMain, #Name, #Names, ok¹ s ss.#[ok¹,s,ss]]
    →
    {#DM} #[OK, #Name, #Names]
    ;

{#DM}
PG-InsertDefines[(#Define ; #Defines), #IsMain, #ModuleName, #Name, #Names, ok¹ s ss.#[ok¹,s,ss]]
→
{#DM}
PG-InsertDefine[#Define, #IsMain, #ModuleName, #Name, #Names,
	ok1¹ s1 ss1.PG-then-InsertDefines[ok1¹, #Defines, #IsMain, #ModuleName, s1, ss1, ok2¹ s2 ss2.#[ok2¹,s2,ss2]]]
;

{$String<!--SortName--> : DeclarationMapEntry}
PG-then-InsertDefines[Ok, Boolean<!--IsMain-->, $String<!--ModuleName-->, $List[Define], $String<!--SortName-->, NameSet<!--SortNames-->,
                      ok¹::Ok s::$String<!--SortName--> ss::NameSet<!--SortNames--> . DeclarationMap] :: DeclarationMap ;

{#DM}
PG-then-InsertDefines[OK, #Defines, #IsMain, #ModuleName, #Name, #Names, ok¹ s ss.#[ok¹,s,ss]]
→
{#DM}
PG-InsertDefines[#Defines, #IsMain, #ModuleName, #Name, #Names, ok¹ s ss.#[ok¹,s,ss]]
;

// Insert single define: get existing list (if any) and insert in proper sorted place.

{$String<!--SortName--> : DeclarationMapEntry}
PG-InsertDefine[Define<!--new-->, Boolean<!--IsMain-->, $String<!--ModuleName-->, $String<!--SortName-->, NameSet<!--SortNames-->,
		    ok¹::Ok s::$String<!--SortName--> ss::NameSet<!--SortNames--> . DeclarationMap] :: DeclarationMap ;

-[Data[#Name],Share[#Define,#]]:
{#DM}
PG-InsertDefine[#Define, #IsMain, #ModuleName, #Name, #Names, ok¹ s ss.#[ok¹, s, ss]]
→
{#DM}
PG-InsertDefine1[$[{#DM}Get[DeclarationMapEntry], #Name, DME_NONE], #Define, #IsMain, #ModuleName, #Name, #Names, ok¹ s ss.#[ok¹, s, ss]]
;

    {$String<!--SortName--> : DeclarationMapEntry}
    PG-InsertDefine1[DeclarationMapEntry<!--existing-->, Define<!--new-->, Boolean<!--IsMain-->, $String<!--ModuleName-->, $String<!--SortName-->, NameSet<!--SortNames-->,
		     ok¹::Ok s::$String<!--SortName--> ss::NameSet<!--SortNames--> . DeclarationMap] :: DeclarationMap ;

    {#DM}
    PG-InsertDefine1[DME_SORT[#existingDefines1, #Name1, #Precs1, #Wrapper1, #IsMain1], #newDefine, #IsMain, #ModuleName, #Name, #Names, ok¹ s ss.#[ok¹, s, ss]]
    →
    {#DM}
    PG-InsertDefine4[
	    PG-InsertDefine2[#existingDefines1, #newDefine],
	    AddNameNumber[#Precs1, PG-DefinePrec[#newDefine]],
	    #Name1,
	    #Names,
	    PG-DefineWrapper[#newDefine, #Name, #Wrapper1],
	    Or[#IsMain1, #IsMain],
	    ok¹ s ss.#[ok¹, s, ss]]
    ;
    //
    {#DM}
    PG-InsertDefine1[DME_NONE<!--not found-->, #newDefine, #IsMain, #ModuleName, #Name, #Names, ok¹ s ss.#[ok¹, s, ss]]
    →
    {#DM}
    PG-InsertDefine1b[#Name, #Names, #newDefine, AddNameNumber[NoNames, PG-DefinePrec[#newDefine]], PG-DefineWrapper[#newDefine, #Name, NO_WRAPPER], #IsMain, ok¹ s ss.#[ok¹, s, ss]]
    ;

    {$String<!--SortName--> : DeclarationMapEntry}
    PG-InsertDefine1b[$String<!--SortName-->, NameSet<!--SortNames-->, Define, NameSet<!--Precs-->, Wrapper, Boolean<!--IsMain-->,
		    ok¹::Ok s::$String<!--SortName--> ss::NameSet<!--SortNames--> . DeclarationMap] :: DeclarationMap ;
    -[Data[#newDefine,#Name,#Precs,#Wrapper]]:
    {#DM}
    PG-InsertDefine1b[#Name, #Names, #newDefine, #Precs, #Wrapper, #IsMain, ok¹ s ss.#[ok¹, s, ss]]
    →
    {#DM; #Name : DME_SORT[(#newDefine;), #Name, #Precs, #Wrapper, #IsMain]}
    #[OK, #Name, AddName[#Names, #Name]]
    ;

    PG-InsertDefine2[$List[Define]<!--existing-->, Define<!--new-->] :: $List[Define]<!--merged-->;
    //
    PG-InsertDefine2[(), #newDefine] → (#newDefine;) ;
    //
    PG-InsertDefine2[(#Define1; #Defines), #newDefine]
    →
    PG-InsertDefine3[PG-DefineLessEqual[#newDefine, #Define1], #newDefine, #Define1, #Defines]
    ;

    PG-InsertDefine3[Boolean<!--new goes before old-->, Define<!--new-->, Define<!--old-->, $List[Define]<!--old rest-->] :: $List[Define]<!--merged-->;
    //,
    PG-InsertDefine3[B_TRUE , #newDefine, #Define1, #Defines] → (#newDefine; #Define1; #Defines) ;
    PG-InsertDefine3[B_FALSE, #newDefine, #Define1, #Defines] → (#Define1; PG-InsertDefine2[#Defines, #newDefine]) ;

    {$String<!--SortName--> : DeclarationMapEntry}
    PG-InsertDefine4[$List[Define], NameSet<!--precs-->, $String<!--SortName-->, NameSet<!--SortNames-->, Wrapper, Boolean<!--IsMain-->,
		     ok¹::Ok s::$String<!--SortName--> ss::NameSet<!--SortNames--> . DeclarationMap] :: DeclarationMap ;
    //
    -[Data[#Defines,#Name,#Precs,#Wrapper]]:
    {#DM}
    PG-InsertDefine4[#Defines, #Precs, #Name, #Names, #Wrapper, #IsMain, ok¹ s ss.#[ok¹, s, ss]]
    →
    {#DM; #Name : DME_SORT[#Defines, #Name, #Precs, #Wrapper, #IsMain]}
    #[OK, #Name, #Names]
    ;

// Compare of defines.

PG-DefineLessEqual[Define, Define] :: Boolean ;

//-[Discard[#Define1, #Define2]]: PG-DefineLessEqual[#Define1, #Define2] → B_FALSE ;

// Compare (1) Basic constructs are in order Abstraction/Form-Rule-Attribute.

DLE-Abstraction-Rule     : PG-DefineLessEqual[D_ABSTRACTION[a.#D1[a]], D_RULE[#R2, #S2, #D2]] → B_TRUE ;
DLE-Rule-Abstraction     : PG-DefineLessEqual[D_RULE[#R1, #S1, #D1], D_ABSTRACTION[a.#D2[a]]] → B_FALSE ;

DLE-Synthesizes-Rule: PG-DefineLessEqual[D_SYNTHESIZES[#A1], D_RULE[#R2, #S2, #D2]] → B_TRUE ;
DLE-Rule-Synthesizes: PG-DefineLessEqual[D_RULE[#R1, #S1, #D1], D_SYNTHESIZES[#A2]] → B_FALSE ;

DLE-Form-Rule            : PG-DefineLessEqual[D_FORM[#F1, #K1], D_RULE[#R2, #S2, #D2]] → B_TRUE ;
DLE-Rule-Form            : PG-DefineLessEqual[D_RULE[#R1, #S1, #D1], D_FORM[#F2, #K2]] → B_FALSE ;

DLE-Abstraction-Synthesizes     : PG-DefineLessEqual[D_ABSTRACTION[a.#D1[a]], D_SYNTHESIZES[#A2]] → B_TRUE ;
DLE-Synthesizes-Abstraction     : PG-DefineLessEqual[D_SYNTHESIZES[#A1], D_ABSTRACTION[a.#D2[a]]] → B_FALSE ;

DLE-Abstraction-Form: PG-DefineLessEqual[D_ABSTRACTION[a.#D1[a]], D_FORM[#F2, #K2]] → B_TRUE ;
DLE-Form-Abstraction: PG-DefineLessEqual[D_FORM[#F1, #K1], D_ABSTRACTION[a.#D2[a]]] → B_FALSE ;

DLE-Form-Synthesizes: PG-DefineLessEqual[D_FORM[#F1, #K1], D_SYNTHESIZES[#A2]] → B_TRUE ;
DLE-Synthesizes-Form: PG-DefineLessEqual[D_SYNTHESIZES[#A1], D_FORM[#F2, #K2]] → B_FALSE ;

// Compare (2) Abstractions traversed in parallel.

PG-DefineLessEqual[D_ABSTRACTION[a.#Define1[a]], D_ABSTRACTION[a.#Define2[a]]]
→
PG-DefineLessEqual2[a.PG-DefineLessEqual[#Define1[a], #Define2[a]]]
;
PG-DefineLessEqual2[a::HxSortParam.Boolean] :: Boolean ;
PG-DefineLessEqual2[a.B_TRUE] → B_TRUE ;
PG-DefineLessEqual2[a.B_FALSE] → B_FALSE ;

// Compare (3) Forms sorted by precedence-tokens.

DLE-Form-Form: PG-DefineLessEqual[D_FORM[#F1, #FK1], D_FORM[#F2, #FK2]] → PG-FormLess[#F1, #F2] ;

    // Local helper to compare forms.
    //
    PG-FormLess[HxForm, HxForm] :: Boolean ;
    //
    -[Data[#Prec1,#Prec2]]:
    PG-FormLess[RawHxFormParsedSorted[#Name1, #ParsedForm1, #Prec1, #InheritedRefs1], RawHxFormParsedSorted[#Name2, #ParsedForm2, #Prec2, #InheritedRefs2]]
    →
    $[If, $[NumericEqual, #Prec1, #Prec2], PG-ParsedFormLess[#ParsedForm1, #ParsedForm2], $[If, $[LessThan, #Prec1, #Prec2], B_TRUE, B_FALSE]]
    ;
    //
    -[Data[#Prec1,#Prec2]]:
    PG-FormLess[RawHxFormParsed[#ParsedForm1, #Prec1, #InheritedRefs1], RawHxFormParsedSorted[#Name2, #ParsedForm2, #Prec2, #InheritedRefs2]]
    →
    $[If, $[NumericEqual, #Prec1, #Prec2], PG-ParsedFormLess[#ParsedForm1, #ParsedForm2], $[If, $[LessThan, #Prec1, #Prec2], B_TRUE, B_FALSE]]
    ;
    //
    -[Data[#Prec1,#Prec2]]:
    PG-FormLess[RawHxFormParsedSorted[#Name1, #ParsedForm1, #Prec1, #InheritedRefs1], RawHxFormParsed[#ParsedForm2, #Prec2, #InheritedRefs2]]
    →
    $[If, $[NumericEqual, #Prec1, #Prec2], PG-ParsedFormLess[#ParsedForm1, #ParsedForm2], $[If, $[LessThan, #Prec1, #Prec2], B_TRUE, B_FALSE]]
    ;
    //
    -[Data[#Prec1,#Prec2]]:
    PG-FormLess[RawHxFormParsed[#ParsedForm1, #Prec1, #InheritedRefs1], RawHxFormParsed[#ParsedForm2, #Prec2, #InheritedRefs2]]
    →
    $[If, $[NumericEqual, #Prec1, #Prec2], PG-ParsedFormLess[#ParsedForm1, #ParsedForm2], $[If, $[LessThan, #Prec1, #Prec2], B_TRUE, B_FALSE]]
    ;
    //
    PG-FormLess[RawHxFormConstruction[#Constructor1, #ScopeSorts1, #InheritedRefs1], #Form2] → B_FALSE ;
    //
    PG-FormLess[RawHxFormParsedSorted[#Name1, #ParsedForm1, #Prec1, #InheritedRefs1], RawHxFormConstruction[#Constructor2, #ScopeSorts2, #InheritedRefs2]] → B_TRUE;
    PG-FormLess[RawHxFormParsed[#ParsedForm1, #Prec1, #InheritedRefs1], RawHxFormConstruction[#Constructor2, #ScopeSorts2, #InheritedRefs2]] → B_TRUE ;

    PG-ParsedFormLess[HxParsedForm, HxParsedForm] :: Boolean ;
    //
    PG-ParsedFormLess[RawHxParsedFormDone, #PF2] → B_FALSE ;
    PG-ParsedFormLess[#PF1, RawHxParsedFormDone] → B_TRUE ;
    //
    PG-ParsedFormLess[RawHxParsedFormWord[#W1, #PF1], RawHxParsedFormTerm[#SSPR2, #PF2]] → B_TRUE ;
    PG-ParsedFormLess[RawHxParsedFormTerm[#SSPR1, #PF1], RawHxParsedFormWord[#W2, #PF2]] → B_FALSE ;
    //
    -[Data[#W1,#W2]]:
    PG-ParsedFormLess[RawHxParsedFormWord[#W1, #PF1], RawHxParsedFormWord[#W2, #PF2]]
    →
    $[If, $[Equal, #W1, #W2], PG-ParsedFormLess[#PF1, #PF2], $[If, $[StringLessThan, #W1, #W2], B_TRUE, B_FALSE]]
    ;
    //
    PG-ParsedFormLess[RawHxParsedFormTerm[#SSPR1, #PF1], RawHxParsedFormTerm[#SSPR2, #PF2]]
    →
    PG-ParsedFormLess[#PF1, #PF2] // to ensure short come last!
    ;
    //
    PG-ParsedFormLess[RawHxParsedFormSpace[#S1, #PF1], #PF2] → PG-ParsedFormLess[#PF1, #PF2] ;
    -[Data[#PF1]]: PG-ParsedFormLess[$[NotMatch,RawHxParsedFormSpace[#S1, #_], #PF1], RawHxParsedFormSpace[#W2, #PF2]] → PG-ParsedFormLess[#PF1, #PF2] ;
    //
    ///PG-ParsedFormLess[RawHxParsedFormAttribute[#K1, #N1, #PF1], RawHxParsedFormAttribute[#K2, #N2, #PF2]]
    ///→
    ///PG-ParsedFormLess[#PF1, #PF2] // to ensure short come last!
    ///;

// Compare (4) Rules are not sorted.

DLE-Rule-Rule: PG-DefineLessEqual[D_RULE[#R1, #S1, #D1], D_RULE[#R2, #S2, #D2]] → B_FALSE ;
DLE-Syntesizes-Synthesizes: PG-DefineLessEqual[D_SYNTHESIZES[#A1], D_SYNTHESIZES[#A2]] → B_FALSE ;

// Precedence extraction.

PG-DefinePrec[Define] :: $Numeric;
-[Fresh[dummy::HxSortParam]] : PG-DefinePrec[D_ABSTRACTION[a.#Define[a]]] → PG-DefinePrec[#Define[dummy]] ;
PG-DefinePrec[D_FORM[RawHxFormParsedSorted[#Name, #ParsedForm, #Precedence, #InheritedRefs], #Kind]] → #Precedence ;
PG-DefinePrec[D_FORM[RawHxFormParsed[#ParsedForm, #Precedence, #InheritedRefs], #Kind]] → #Precedence ;
PG-DefinePrec[D_FORM[RawHxFormConstruction[#Constructor, #ScopeSorts, #InheritedRefs], #Kind]] → 0 ;
PG-DefinePrec[D_SYNTHESIZES[#AttributeName]] → 0 ;
PG-DefinePrec[D_RULE[#Rule, #SortName, #IsData]] → 0 ;

// Wrapper extraction.

PG-DefineWrapper[Define, $String<!--SortName-->, Wrapper] :: Wrapper ;
-[Fresh[dummy::HxSortParam]] : PG-DefineWrapper[D_ABSTRACTION[a.#Define[a]], #Name, #Wrapper] → PG-DefineWrapper[#Define[dummy], #Name, #Wrapper] ;
PG-DefineWrapper[D_FORM[RawHxFormParsedSorted[#Name, #ParsedForm, #Prec, #InheritedRefs], #Kind], #Name, #Wrapper] → PG-DefineWrapperForm[#ParsedForm, #Prec, #Kind, #Name, #Wrapper] ;
PG-DefineWrapper[D_FORM[RawHxFormParsed[#ParsedForm, #Prec, #InheritedRefs], #Kind], #Name, #Wrapper] → PG-DefineWrapperForm[#ParsedForm, #Prec, #Kind, #Name, #Wrapper] ;

PG-DefineWrapper[D_FORM[RawHxFormConstruction[#Constructor, #ScopeSorts, #InheritedRefs], #Kind], #Name, #Wrapper] →  #Wrapper ;
PG-DefineWrapper[D_SYNTHESIZES[#AttributeName], #Name, #Wrapper] → #Wrapper ;
PG-DefineWrapper[D_RULE[#Rule, #SortName, #IsData], #Name, #Wrapper] → #Wrapper ;

PG-DefineWrapperForm[HxParsedForm, $Numeric, FormKind, $String<!--SortName-->, Wrapper] :: Wrapper ;
PG-DefineWrapperForm[#ParsedForm, #Prec, FK_SUGAR[#Term], #Name, #OldWrapper] → PG-DefineWrapperSugar[#ParsedForm, $False<!--NotCandidate-->, #ParsedForm, #Prec, #Term, #Name, #OldWrapper] ;
PG-DefineWrapperForm[#ParsedForm, #Prec, $[NotMatch,FK_SUGAR[#Term],#Kind], #Name, #OldWrapper] → #OldWrapper ;

PG-DefineWrapperSugar[HxParsedForm, $Boolean<!--IsCandidate-->, HxParsedForm, $Numeric<!--Prec-->, HxTerm, $String<!--SortName-->, Wrapper] :: Wrapper ;

-[Data[#Prec1,#Prec]]:
PG-DefineWrapperSugar[RawHxParsedFormTerm[RawHxScopeSortPrecRepeat[#ScopeSort1, #Prec1, #Repeat1], #ParsedForm1], #Candidate, #TopParsedForm, #TopPrec, #TopTerm, #Name, #OldWrapper]
→
$[If, #Candidate,
  #OldWrapper, // not a candidate anyway (has at least two nonterminals)
  $[If, $[LessThan, #TopPrec, #Prec1],
    #OldWrapper, // not a candidate anyway (inner has higher precedence than outer)
    PG-DefineWrapperSugar[#ParsedForm1, $True, #TopParsedForm, #TopPrec, #TopTerm, #Name, #OldWrapper]
]];
// TODO: include #Name in comparison.

PG-DefineWrapperSugar[RawHxParsedFormWord[#Word, #ParsedForm], #Candidate, #TopParsedForm, #TopPrec, #TopTerm, #Name, #OldWrapper]
→
PG-DefineWrapperSugar[#ParsedForm, #Candidate, #TopParsedForm, #TopPrec, #TopTerm, #Name, #OldWrapper]
;

PG-DefineWrapperSugar[RawHxParsedFormSpace[#Space, #ParsedForm], #Candidate, #TopParsedForm, #TopPrec, #TopTerm, #Name, #OldWrapper]
→
PG-DefineWrapperSugar[#ParsedForm, #Candidate, #TopParsedForm, #TopPrec, #TopTerm, #Name, #OldWrapper]
;

PG-DefineWrapperSugar[RawHxParsedFormDone, $False, #TopParsedForm, #TopPrec, #TopTerm, #Name, #OldWrapper] → #OldWrapper ;
PG-DefineWrapperSugar[RawHxParsedFormDone, $True,  #TopParsedForm, #TopPrec, #TopTerm, #Name, #OldWrapper] → WRAPPER[#TopParsedForm] ;








//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// . TEXT OF ALL PG NON-TERMINAL PRODUCTIONS.
//
// Productions are extracted by sort and for each sort grouped by precedence,
// each group producing a PG production.

// Iterate through all productions.

{$String<!--SortName--> : DeclarationMapEntry} PG-Productions[$String<!--ModuleName-->] :: Text;
{#DM} PG-Productions[#ModuleName] → {#DM} PG-Productions0[#ModuleName, {#DM} PG-AllNames] ;

{$String<!--SortName--> : DeclarationMapEntry} PG-Productions0[$String<!--ModuleName-->, NameSet] :: Text;
{#DM} PG-Productions0[#ModuleName, #Names] → {#DM} PG-Productions1[HasNames[#Names], #ModuleName, #Names] ;

{$String<!--SortName--> : DeclarationMapEntry} PG-Productions1[Boolean, $String<!--ModuleName-->, NameSet] :: Text;
{#DM} PG-Productions1[B_TRUE , #ModuleName, #Names] → %n⟪« {#DM} PG-Production[#ModuleName, FirstName[#Names]] »« {#DM} PG-Productions0[#ModuleName, RemoveFirstName[#Names]] »⟫ ;
{#DM} PG-Productions1[B_FALSE, #ModuleName, #Names] → %n⟪⟫ ;

// Emit productions for one declaration.

{$String<!--Name--> : DeclarationMapEntry} PG-Production[$String<!--ModuleName-->, $String<!--Name-->] :: Text;
-[Data[#Name]]:
{#DM} PG-Production[#ModuleName, #Name]
→
{#DM} PG-Production1[#ModuleName, $[{#DM}Get, #Name, DME_NONE]]
;

{$String<!--SortName--> : DeclarationMapEntry} PG-Production1[$String<!--ModuleName-->, DeclarationMapEntry] :: Text;

// Dummy.

{#DM} PG-Production1[#ModuleName, DME_NONE]
→
%n⟪⟫
;

// Token declaration.

{#DM}
PG-Production1[#ModuleName, DME_TOKEN[#SortName]]
→
%n⟪
/* Productions for †«#SortName» token. */

/***USERPG&EMBEDPG:
« PG-GenerateNonterminalDeclaration[PG-ProductionNameText[#SortName],
  %n⟨/***EMBEDPG:‹ {#DM}PG-Embed-Head[B_TRUE, #ModuleName, #SortName, #SortName, B_FALSE, 0]›***/ (‹PG-TokenNameText[#SortName]›$)⟩] »
***/
/***EMBEDPG:
« {#DM}PG-Embed-Tail[B_TRUE, #SortName, #SortName] »
***/

/***METAPG:
/* <†«#SortName»> covers Hacs terms restricted to †«#SortName» token sort. */
%{
net.sf.crsx.Sink N_†«#SortName»$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) : {}{ sink=N_†«#SortName»(sink, env) <EOF> {return sink;} }
net.sf.crsx.Sink N_†«#SortName»(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{String savedSort;}{
  {savedSort = storedSort; storedSort = "†«#SortName»";}
  ( "†«#SortName»" )?
  ( sink=N_PresortedVariable(sink, env)
  | sink=N_PresortedMetaApplication(sink, env)
  | sink=N_PresortedParsed(sink, env)
  )
  {storedSort = savedSort;}
  {return sink;}
}
%}
***/
⟫
;
/// « PG-GenerateNonterminalDeclaration[PG-ProductionNameText[#SortName], %n⟨(‹PG-TokenNameText[#SortName]›$)⟩] »

PG-GenerateNonterminalDeclaration[Text, Text] → Text;
PG-GenerateNonterminalDeclaration[#Name, #Alternatives] → %n⟪<«#Name»> ::= ⟦«#Alternatives»⟧ .⟫ ;
//TODO: use for all production declarations.

// Attribute declaration.

{#DM} PG-Production1[#ModuleName, DME_ATTRIBUTE[#Kind, #Name, #AttributeForm, #AttributeOptions]]
→
%n⟪
/***METAPG:
/* Productions for †«#Name» attribute. */
%{
« PG-MetaJJ-Production-Attribute[#ModuleName, #Kind, #Name, #AttributeForm, #AttributeOptions] »
%}
***/
⟫;

    // Handle an attribute definition.

    PG-MetaJJ-Production-Attribute[$String<!--ModuleName-->, HxAttributeKind, $String, HxAttributeForm, $List[HxAttributeOption]] :: Text;
    PG-MetaJJ-Production-Attribute[#ModuleName, #Kind, #Name, #AttributeForm, #AttributeOptions]
    →
    %n⟪
/* <Attribute« AttributeKindCategory[#Kind] »_†«#Name»> ::= ... */
net.sf.crsx.Sink N_Attribute« AttributeKindCategory[#Kind] »_†«#Name»(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{Token t;}
{
  LOOKAHEAD( {getToken(1).kind == T_HX_VAR && "†«#Name»".equals(getToken(1).image)} )
  {sink = sink.start(makeTConstructor(sink, null, hx("Attribute"), null));}
  {sink = sink.start(makeTConstructor(sink, null, hx("« AttributeKindIndicator[#Kind] »"), null)).end();}
  t=<T_HX_VAR>
  ⟦« PG-MetaJJ-AttributeFormSyntax[#ModuleName, #AttributeForm, #AttributeOptions] »⟧
  {return sink.end();}
}
⟫;

    AttributeKindCategory[HxAttributeKind] :: Text ;
    AttributeKindCategory[%rawHxAttributeKind⟪ ↑ ⟫] → %n⟪Synthesized⟫ ;
    AttributeKindCategory[%rawHxAttributeKind⟪ ↓ ⟫] → %n⟪Inherited⟫ ;

    AttributeKindIndicator[HxAttributeKind] :: Text ;
    AttributeKindIndicator[%rawHxAttributeKind⟪ ↑ ⟫] → %n⟪AttributeKindUp⟫ ;
    AttributeKindIndicator[%rawHxAttributeKind⟪ ↓ ⟫] → %n⟪AttributeKindDown⟫ ;


    PG-MetaJJ-AttributeFormSyntax[$String<!--ModuleName-->, HxAttributeForm, $List[HxAttributeOption]] :: Text ;
    PG-MetaJJ-AttributeFormSyntax[#ModuleName, %rawHxAttributeForm⟪ ( #HxSort# ) ⟫, #AttributeOptions]
    →
    %n⟪« JJ-Token[%n⟨HX_LPAREN⟩] »« JJ-Construction[%n⟨hx("AttributeValue")⟩, JJ-Nonterminal[%n⟨†‹ PG-SortName[#HxSort#] ›⟩, e.e]] »« JJ-Token[%n⟨HX_RPAREN⟩] »⟫
    ;
    PG-MetaJJ-AttributeFormSyntax[#ModuleName, %rawHxAttributeForm⟪ { #HxSort# } ⟫, #AttributeOptions]
    →
    %n⟪« JJ-Token[%n⟨HX_LBRACE⟩] »« JJ-Construction[%n⟨hx("AttributeKey")⟩, JJ-Nonterminal[%n⟨†‹ PG-SortName[#HxSort#] ›⟩, e.e]] »« JJ-Token[%n⟨HX_RBRACE⟩] »⟫
    ;
    PG-MetaJJ-AttributeFormSyntax[#ModuleName, %rawHxAttributeForm⟪ { #HxSort1# : #HxSort2# } ⟫, #AttributeOptions]
    →
    %n⟪« JJ-Token[%n⟨HX_LBRACE⟩] »«
      JJ-Construction[%n⟨hx("AttributeKeyValue")⟩,
        MapTextConcat[t.t, (
	  JJ-Nonterminal[%n⟨†‹ PG-SortName[#HxSort1#] ›⟩, e.e];
          JJ-Token[%n⟨HX_COLON⟩];
          JJ-Nonterminal[%n⟨†‹ PG-SortName[#HxSort2#] ›⟩, e.e];
      )]]
    »« JJ-Token[%n⟨HX_RBRACE⟩] »⟫
    ;

    AttributeKindToken[HxAttributeKind] :: Text ;
    AttributeKindToken[%rawHxAttributeKind⟪ ↑ ⟫] → %n⟪HX_UP⟫ ;
    AttributeKindToken[%rawHxAttributeKind⟪ ↓ ⟫] → %n⟪HX_DOWN⟫ ;

// Sort declaration.

{#DM} PG-Production1[#ModuleName, DME_SORT[#Defines, #SortName, #Precs, #Wrapper, #IsMain]]
→
%n⟪« {#DM} PG-Production-Defines[#ModuleName, #Defines, #SortName, 0, ()] »
/***METAPG:
%{
« {#DM} PG-MetaJJ-Production-Defines[#ModuleName, #Defines, #SortName, PG-DefinesHaveHx[#Defines]] »
%}
***/⟫
;

// Helper for ParsedForm and FK.
PFK_SORT ::=( PFK[HxParsedForm, FormKind]; );

// Handle a sort definition.

{$String<!--SortName--> : DeclarationMapEntry} PG-Production-Defines[$List[Define], $String, $Numeric, $List[PFK_SORT]] :: Text;

{#DM} PG-Production-Defines[#ModuleName, (), #SortName, #Prec, ()]
→
%n⟪⟫
;

{#DM} PG-Production-Defines[#ModuleName, (), #SortName, #Prec, (#PFK1;#PFKs)]
→
%n⟪

/* Productions for †«#SortName» sort with (highest) precedence †«$[FormatNumber,#Prec]». */
« {#DM} PG-Expand[#ModuleName, (#PFK1;#PFKs), #SortName, #Prec, B_TRUE] »
⟫
;

-[Fresh[dummy::HxSortParam]]:
{#DM} PG-Production-Defines[#ModuleName, (D_ABSTRACTION[a.#Define1[a]]; #Defines), #SortName, #Prec, #PrecPFKs]
→
{#DM} PG-Production-Defines[#ModuleName, (#Define1[dummy]; #Defines), #SortName, #Prec, #PrecPFKs]
;

{#DM} PG-Production-Defines[#ModuleName, (D_RULE[#Rule, #RuleSort, #IsData]; #Defines), #SortName, #Prec, #PrecPFKs]
→
{#DM} PG-Production-Defines[#ModuleName, #Defines, #SortName, #Prec, #PrecPFKs]
;

{#DM} PG-Production-Defines[#ModuleName, (D_FORM[#Form1, #Kind1]; #Defines), #SortName, #Prec, #PrecPFKs]
→
{#DM} PG-Production-Defines2[#ModuleName, #Form1, #Kind1, #Defines, #SortName, #Prec, #PrecPFKs]
;

{#DM} PG-Production-Defines[#ModuleName, (D_SYNTHESIZES[#AttributeName1]; #Defines), #SortName, #Prec, #PrecPFKs]
→
{#DM} PG-Production-Defines[#ModuleName, #Defines, #SortName, #Prec, #PrecPFKs]
;

{$String<!--SortName--> : DeclarationMapEntry} PG-Production-Defines2[HxForm, FormKind, $List[Define], $String, $Numeric, $List[PFK_SORT]] :: Text;

{#DM} PG-Production-Defines2[#ModuleName, RawHxFormParsedSorted[#Sort1, #ParsedForm1, #Prec1, #InheritedRefs], #Kind1, #Defines, #SortName, #Prec, #PrecPFKs]
→
{#DM} PG-Production-Defines3[#ModuleName, #ParsedForm1, #Prec1, #Kind1, #Defines, #SortName, #Prec, #PrecPFKs]
;

{#DM} PG-Production-Defines2[#ModuleName, RawHxFormParsed[#ParsedForm1, #Prec1, #InheritedRefs], #Kind1, #Defines, #SortName, #Prec, #PrecPFKs]
→
{#DM} PG-Production-Defines3[#ModuleName, #ParsedForm1, #Prec1, #Kind1, #Defines, #SortName, #Prec, #PrecPFKs]
;

{#DM} PG-Production-Defines2[#ModuleName, RawHxFormConstruction[#Constructor, #ScopeSortList, #InheritedRefs], #Kind1, #Defines, #SortName, #Prec, #PrecPFKs]
→
{#DM} PG-Production-Defines[#ModuleName, #Defines, #SortName, #Prec, #PrecPFKs]
;

{$String<!--SortName--> : DeclarationMapEntry} PG-Production-Defines3[HxParsedForm, $Numeric, FormKind, $List[Define], $String, $Numeric, $List[PFK_SORT]] :: Text;

-[Data[#Prec1,#Prec],Share[#ParsedForm1,#Kind1,#Defines]]:
{#DM} PG-Production-Defines3[#ModuleName, #ParsedForm1, #Prec1, #Kind1, #Defines, #SortName, #Prec, ()]
→
$[If, $[NumericEqual,#Prec1,#Prec],
  {#DM} PG-Production-Defines[#ModuleName, #Defines, #SortName, #Prec, (PFK[#ParsedForm1, #Kind1];)],
  %n⟪
<«PG-ProductionNameWithPrecText[#SortName,#Prec]»> ::= <«PG-ProductionNameWithPrecText[#SortName,#Prec1]»> .
« {#DM} PG-Production-Defines[#ModuleName, #Defines, #SortName, #Prec1, (PFK[#ParsedForm1, #Kind1];)] »⟫]
;

-[Data[#Prec1,#Prec],Share[#ParsedForm1,#Kind1,#Defines,#PFK,#PFKs]]:
{#DM} PG-Production-Defines3[#ModuleName, #ParsedForm1, #Prec1, #Kind1, #Defines, #SortName, #Prec, (#PFK;#PFKs)]
→
$[If, $[NumericEqual,#Prec1,#Prec],
  {#DM} PG-Production-Defines[#ModuleName, #Defines, #SortName, #Prec, Append[(#PFK;#PFKs), (PFK[#ParsedForm1, #Kind1];)]],
  %n⟪/***USERPG&EMBEDPG:
/* Productions for †«#SortName» sort with precedence †«$[FormatNumber,#Prec]». */
« {#DM} PG-Expand[#ModuleName, (#PFK;#PFKs), #SortName, #Prec, B_FALSE] »
***/
« {#DM} PG-Production-Defines[#ModuleName, #Defines, #SortName, #Prec1, (PFK[#ParsedForm1, #Kind1];)] »
⟫]
;

// Test if a sort has user HACS terms.

{#DM} PG-then-SortHasHx[OK, #SortName] → {#DM} PG-SortHasHx[#SortName] ;

-[Data[#SortName]]: {#DM} PG-SortHasHx[#SortName] → {#DM} PG-SortHasHx1[$[{#DM}Get, #SortName, DME_NONE]] ;

PG-SortHasHx1[DME_SORT[#Defines, #SortName, #Precs, #Wrapper, #IsMain]] → PG-DefinesHaveHx[#Defines] ;
PG-SortHasHx1[$[NotMatch,DME_SORT[#Defines, #SortName, #Precs, #Wrapper, #IsMain],#_]] → B_FALSE ;

PG-DefinesHaveHx[$List[Define]] :: Boolean;

-[Fresh[dummy::HxSortParam]]:
PG-DefinesHaveHx[(D_ABSTRACTION[a.#Define1[a]]; #Defines)]
→
PG-DefinesHaveHx[(#Define1[dummy]; #Defines)]
;

PG-DefinesHaveHx[(D_RULE[#Rule, #RuleSort, #IsData]; #Defines)]
→
PG-DefinesHaveHx[#Defines]
;

PG-DefinesHaveHx[(D_FORM[RawHxFormConstruction[#1, #2, #3], #Kind1]; #Defines)]
→
B_TRUE
;

PG-DefinesHaveHx[(D_FORM[$[NotMatch,RawHxFormConstruction[#1, #2, #3], #_], #Kind1]; #Defines)]
→
PG-DefinesHaveHx[#Defines]
;

PG-DefinesHaveHx[(D_SYNTHESIZES[#AttributeName1]; #Defines)]
→
PG-DefinesHaveHx[#Defines]
;

PG-DefinesHaveHx[(D_NONE; #Defines)]
→
PG-DefinesHaveHx[#Defines]
;

PG-DefinesHaveHx[()]
→
B_FALSE
;

{$String<!--SortName--> : DeclarationMapEntry} PG-MetaJJ-Production-Defines[$String<!--<ModuleName-->, $List[Define], $String<!--SortName-->, Boolean<!--HasHxConstructors-->] :: Text;

{#DM}
PG-MetaJJ-Production-Defines[#ModuleName, #Defines, #SortName, B_TRUE]
→
%n⟪
/* <†«#SortName»> covers Hacs terms prerestricted to †«#SortName» user sort (including user naked terms). */
net.sf.crsx.Sink N_†«#SortName»$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) : {}{ sink=N_†«#SortName»(sink, env) <EOF> {return sink;} }
net.sf.crsx.Sink N_†«#SortName»(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{String savedSort;}{
  (
    sink=N_†«#SortName»_Construction(sink, env)
  |
    {savedSort = storedSort; storedSort = "†«#SortName»";}
    (  sink=N_PresortedVariable(sink, env)
    |  sink=N_PresortedMetaApplication(sink, env)
    |  sink=N_PresortedParsed(sink, env)
    | "†«#SortName»"
      (  sink=N_PresortedVariable(sink, env)
      |  sink=N_Construction(sink, env)
      |  sink=N_PresortedMetaApplication(sink, env)
      |  sink=N_PresortedParsed(sink, env)
    ))
    {storedSort = savedSort;}
  )
  {return sink;}
}

/* <†«#SortName»_Construction> covers just Hacs user terms of †«#SortName» sort. */
net.sf.crsx.Sink N_†«#SortName»_Construction$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) : {}{ sink=N_†«#SortName»_Construction(sink, env) <EOF> {return sink;} }
net.sf.crsx.Sink N_†«#SortName»_Construction(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}{⟦
« {#DM} PG-MetaJJ-Production-Defines1[#ModuleName, #Defines, #SortName, "("] »
)
{return sink;}⟧
}
⟫;

{#DM}
PG-MetaJJ-Production-Defines[#ModuleName, #Defines, #SortName, B_FALSE]
→
%n⟪
/* <†«#SortName»> covers Hacs terms restricted to †«#SortName» user sort (no naked terms). */
net.sf.crsx.Sink N_†«#SortName»$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) : {}{ sink=N_†«#SortName»(sink, env) <EOF> {return sink;} }
net.sf.crsx.Sink N_†«#SortName»(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{String savedSort;}{
  {savedSort = storedSort; storedSort = "†«#SortName»";}
  ( "†«#SortName»" )?
  ( sink=N_PresortedVariable(sink, env)
  | sink=N_PresortedMetaApplication(sink, env)
  | sink=N_PresortedParsed(sink, env)
  )
  {storedSort = savedSort;}
  {return sink;}
}
⟫;


{$String<!--SortName--> : DeclarationMapEntry} PG-MetaJJ-Production-Defines1[$String<!--ModuleName-->, $List[Define], $String<!--SortName-->, $String<!--lead-->] :: Text;

-[Fresh[dummy::HxSortParam]]:
{#DM} PG-MetaJJ-Production-Defines1[#ModuleName, (D_ABSTRACTION[a.#Define1[a]]; #Defines), #SortName, #lead]
→
{#DM} PG-MetaJJ-Production-Defines1[#ModuleName, (#Define1[dummy]; #Defines), #SortName, #lead]
;

{#DM} PG-MetaJJ-Production-Defines1[#ModuleName, (D_RULE[#Rule, #RuleSort, #IsData]; #Defines), #SortName, #lead]
→
{#DM} PG-MetaJJ-Production-Defines1[#ModuleName, #Defines, #SortName, #lead]
;

{#DM} PG-MetaJJ-Production-Defines1[#ModuleName, (D_FORM[#Form1, #Kind1]; #Defines), #SortName, #lead]
→
{#DM} PG-MetaJJ-Production-HxForm[#ModuleName, #Form1, #Kind1, #SortName, #lead, lead.{#DM} PG-MetaJJ-Production-Defines1[#ModuleName, #Defines, #SortName, lead]]
;

{#DM} PG-MetaJJ-Production-Defines1[#ModuleName, (D_SYNTHESIZES[#AttributeName1]; #Defines), #SortName, #lead]
→
{#DM} PG-MetaJJ-Production-Defines1[#ModuleName, #Defines, #SortName, #lead]
;

{#DM} PG-MetaJJ-Production-Defines1[#ModuleName, (), #SortName, #lead]
→
%n⟪⟫
;


{$String<!--SortName--> : DeclarationMapEntry} PG-MetaJJ-Production-HxForm[HxForm, FormKind, $String<!--SortName-->, $String<!--lead-->, l::$String . Text] :: Text;
{#DM} PG-MetaJJ-Production-HxForm[#ModuleName, RawHxFormParsedSorted[#Sort1, #ParsedForm1, #Prec1, #InheritedRefs], #Kind1, #SortName, #lead, lead.#[lead]] → #[#lead] ;
{#DM} PG-MetaJJ-Production-HxForm[#ModuleName, RawHxFormParsed[#ParsedForm1, #Prec1, #InheritedRefs], #Kind1, #SortName, #lead, lead.#[lead]] → #[#lead] ;
{#DM} PG-MetaJJ-Production-HxForm[#ModuleName, RawHxFormConstruction[#Constructor, #ScopeSortList, #InheritedRefs], #Kind1, #SortName, #lead, lead.#[lead]]
→
%n⟪†«#lead» ⟦
"†«#Constructor»"
« JJ-Construction[%n⟨"†‹ PG-user[#ModuleName, "Wrapper"] ›"⟩, 
TextConcat[JJ-StringLiteral[%n⟨"†‹#SortName›"⟩],
%n⟨ ( ⟦‹ {#DM} PG-MetaJJ-Production-HxFormConstruction[#ModuleName, #SortName, #Constructor, #ScopeSortList]›⟧ )
sink=N_HxAttributes(sink, env)⟩]] »⟧
« #["|"] »⟫
;

{#DM} PG-MetaJJ-Production-HxFormConstruction[#ModuleName, #SortName, #Constructor, #ScopeSortList]
→
JJ-Construction[%n⟨user("†‹ PG-user[#ModuleName, "Wrapper"] ›")⟩,
  TextConcat[
    JJ-StringLiteral[%n⟨"†‹ #Constructor ›"⟩],
    IfEmpty[#ScopeSortList,
      %n⟨(<T_HX_LPAREN> <T_HX_RPAREN>)?⟩,
      %n⟨ <T_HX_LPAREN> ‹ {#DM} PG-MetaJJ-Production-HxScopeSortList[#ModuleName, #ScopeSortList, #SortName, B_TRUE] › <T_HX_RPAREN> ⟩]]]
;


{$String<!--SortName--> : DeclarationMapEntry} PG-MetaJJ-Production-HxScopeSortList[$List[HxScopeSort], $String, Boolean] :: Text;

{#DM} PG-MetaJJ-Production-HxScopeSortList[#ModuleName, (%rawHxScopeSort⟪ #HxSort# #HxRepeat# [ #HxSubstituteSorts# ] ⟫ ; #ScopeSortList), #SortName, #first]
→
%n⟪« If[#first, %n⟨⟩, %n⟨ <T_HX_COMMA> ⟩] »« {#DM} PG-MetaJJ-Production-HxScopeSort[#ModuleName, #HxSort#, #HxSubstituteSorts#, #SortName] »« {#DM} PG-MetaJJ-Production-HxScopeSortList[#ModuleName, #ScopeSortList, #SortName, B_FALSE] »⟫
;  //note: ignores #Repeat because arguments to Hx terms cannot use repeat-forms...or should they?

-[Free[v::Text]]:
{#DM} PG-MetaJJ-Production-HxScopeSortList[#ModuleName, (%rawHxBindersScopeSort⟪ [#HxSort# binds v] #HxBindersScopeSort# ⟫ ; #ScopeSortList), #SortName, #first]
→
{#DM} PG-MetaJJ-Production-HxScopeSortList[#ModuleName, (#HxBindersScopeSort# ; #ScopeSortList), #SortName, #first]
;

-[Free[v::Text]]:
{#DM} PG-MetaJJ-Production-HxScopeSortList[#ModuleName, (%rawHxScopeSort⟪ #HxSort# binds v ⟫ ; #ScopeSortList), #SortName, #first]
→
$[Error, "There should not be binder subterm sorts."]
;

{#DM} PG-MetaJJ-Production-HxScopeSortList[#ModuleName, (), #SortName, #first] → %n⟪⟫ ;

{$String<!--SortName--> : DeclarationMapEntry} PG-MetaJJ-Production-HxScopeSort[HxSort, $List[HxSubstituteSort], $String] :: Text;

{#DM} PG-MetaJJ-Production-HxScopeSort[#ModuleName, #HxSort#, #HxSubstituteSorts#, #SortName]
→
IfEmpty[#HxSubstituteSorts#,
  %n⟪sink=N_†«PG-SortName[#HxSort#]»(sink, env)
⟫,
  %n⟪« {#DM}PG-MetaJJ-Production-HxScope[#ModuleName, #HxSubstituteSorts#, %n⟨sink=N_†‹PG-SortName[#HxSort#]›(sink, env)⟩, %n⟨⟩, %n⟨<T_HX_LBRACKET>⟩, %n⟨[⟩] »⟫]  //start:[
;

{$String<!--SortName--> : DeclarationMapEntry} PG-MetaJJ-Production-HxScope[$String<!--ModuleName-->, $List[HxSubstituteSort], Text<!--SortRef-->, Text<!--ScopedVars-->, Text<!--Sep-->, Text<!--ArgSep-->] :: Text;

-[Fresh[x::Text]]:
{#DM}PG-MetaJJ-Production-HxScope[#ModuleName, (#SubstituteSort ; #SubstituteSorts), #SortRef, #ScopedVars, #sep, #argsep]
→
%n⟪MISSING[ «#sep» HX_VARIABLE^«x» « {#DM}PG-MetaJJ-Production-HxScope[#ModuleName, #SubstituteSorts, #SortRef, %n⟨‹#ScopedVars›‹#argsep›‹x›⟩, %n⟨<T_HX_COMMA>⟩, %n⟨,⟩] »]MISSING⟫
;

{#DM}PG-MetaJJ-Production-HxScope[#ModuleName, (), #SortRef, #ScopedVars, #sep, #argsep] → %n⟪ HX_RBRACKET « #SortRef »« #ScopedVars »]⟫ ;  //end:]

// Meta-definitions for sorts.

{$String<!--SortName--> : DeclarationMapEntry} PG-Embed-Head[Boolean<!--Last?-->, $String<!--ModuleName-->, $String, $String, Boolean<!--LeftRecursive?-->, $Numeric<!--Prec-->] :: Text;

PG-Embed-Head[B_FALSE, #ModuleName, #SortName, #Name, #isLeftRecursive, #Prec] → %n⟪⟫ ;

-[Data[#SortName],Discard[#Prec]]:
{#DM}
PG-Embed-Head[B_TRUE, #ModuleName, #SortName, #Name, B_FALSE, #Prec] →
 %n⟪
meta_« PG-TokenNameText[#Name] »$$:unwrap:{†« PG-Meta-Prefix[#ModuleName] »SortedTerm} |
⟫ ;

-[Data[#SortName]]:
{#DM}
PG-Embed-Head[B_TRUE, #ModuleName, #SortName, #Name, B_TRUE, #Prec] →
 %n⟪
meta_« PG-TokenNameText[#Name] »$$:unwrap:{†« PG-Meta-Prefix[#ModuleName] »SortedTerm}:#1 <« PG-ProductionNameWithPrecText[#SortName, #Prec] »LR #1> |
⟫ ;


PG-Embed-Tail[Boolean, $String, $String] :: Text;

PG-Embed-Tail[B_FALSE, #SortName, #Name] → %n⟪⟫ ;

-[Data[#SortName]]: PG-Embed-Tail[B_TRUE, #SortName, #Name] → %n⟪
%{
/* Meta token for embedded user †«#SortName». */ 
MORE : { < "\u27e8" (" ")* †« Stringify[#SortName] » (" ")* ~["\u27e8","\u27e9"] > { nesting = 0; nestedState = curLexState; } : IN_META_«PG-TokenNameText[#Name]» }
<IN_META_«PG-TokenNameText[#Name]»> MORE : { "\u27e8" { nesting = 1; } : IN_NESTED_META_«PG-TokenNameText[#Name]» }
<IN_NESTED_META_«PG-TokenNameText[#Name]»> MORE : { "\u27e8" { nesting++; } }
<IN_NESTED_META_«PG-TokenNameText[#Name]»> MORE : { "\u27e9" { if (--nesting <= 0) SwitchTo(IN_META_«PG-TokenNameText[#Name]»); } }
<IN_META_«PG-TokenNameText[#Name]»> TOKEN : { < T_meta_«PG-TokenNameText[#Name]» : "\u27e9" > { SwitchTo(nestedState); } }
<IN_META_«PG-TokenNameText[#Name]»,IN_NESTED_META_«PG-TokenNameText[#Name]»> MORE : { < ~[] > }
%}
⟫ ;



// Text of single sort+precedence production expansion.
//
// Emits the left recursion handler, if any, and the PG grammar production
// for the sort+precedence combination, with left factored buffering.

CONSUMPTION_SORT ::=( C_BUFFER[$String<!--SortName-->, $Numeric<!--precedence-->]; C_LEFTRECURSIVE[$String<!--SortName-->, $Numeric<!--precedence-->]; <!--C_INLINE;--> );
/// C_INLINE DISABLED.

{$String<!--SortName--> : DeclarationMapEntry} PG-Expand[$List[PFK_SORT], $String, $Numeric, Boolean<!--Last-->] :: Text;
{#DM} PG-Expand[#ModuleName, #PrecPFKs, #SortName, #Prec, #Last?]
→
{#DM} PG-LeftRecursive[#ModuleName, #PrecPFKs, #SortName, #Prec, #Last?, (), ()]
;

// Generate optional left recursion production helper, normal production, and optional meta-production.

{$String<!--SortName--> : DeclarationMapEntry} PG-LeftRecursive[$List[PFK_SORT], $String, $Numeric, Boolean, $List[PFK_SORT], $List[PFK_SORT]] :: Text;
{$String<!--SortName--> : DeclarationMapEntry} PG-LeftRecursive2[Boolean, PFK_SORT, $List[PFK_SORT], $String, $Numeric, Boolean, $List[PFK_SORT], $List[PFK_SORT]] :: Text;

{#DM} PG-LeftRecursive[#ModuleName, (#PFK1; #PFKs), #SortName, #Prec, #Last?, #LeftRecursivePFKs, #OtherPFKs]
→
{#DM} PG-LeftRecursive2[#ModuleName, PG-isLeftRecursive[#SortName, #Prec, #PFK1], #PFK1, #PFKs, #SortName, #Prec, #Last?, #LeftRecursivePFKs, #OtherPFKs]
;

    // HAND-CODED HACK to recognize and strip left recursive production (because Hx.pg cannot match parsed forms...).

    PG-isLeftRecursive[$String, $Numeric, PFK_SORT] :: Boolean;

    PG-isLeftRecursive[#SortName, #Prec, PFK[RawHxParsedFormSpace[#Space, #ParsedForm1], #Kind]]
    →
    PG-isLeftRecursive[#SortName, #Prec, PFK[#ParsedForm1, #Kind]]
    ;

    PG-isLeftRecursive[#SortName, #Prec, PFK[RawHxParsedFormWord[#Word, #ParsedForm1], #Kind]]
    →
    B_FALSE
    ;

    -[Data[#Sort]]:
    PG-isLeftRecursive[#SortName, #Prec, PFK[RawHxParsedFormTerm[RawHxScopeSortPrecRepeat[#Sort1, #Prec1, #Repeat1], #ParsedForm1], #Kind]]
    →
    $[If, $[NumericEqual,#Prec,#Prec1], PG-isLeftRecursive1[#SortName, #Sort1], B_FALSE]
    ;

    PG-isLeftRecursive[#SortName, #Prec, PFK[RawHxParsedFormDone, #Kind]]
    →
    B_FALSE
    ;

    PG-isLeftRecursive1[$String, HxScopeSort] :: Boolean;

    PG-isLeftRecursive1[#SortName,
      RawHxScopeSort[
	RawHxSort[RawHxSortName[#SortName1, #_1], '$Nil'],
	RawHxRepeatSingle,
	'$Nil']]
    →
    SameString[#SortName,#SortName1]
    ;

    -[Data[#Kind]]:
    PG-isLeftRecursive1[#SortName, $[NotMatch,
      RawHxScopeSort[
	RawHxSort[RawHxSortName[#SortName1, #_1], '$Nil'],
	RawHxRepeatSingle,
	'$Nil'],#_]]
    →
    B_FALSE
    ;

    PG-stripLeftRecursion[PFK_SORT] :: PFK_SORT;
    PG-stripLeftRecursion[PFK[RawHxParsedFormSpace[#Space, #ParsedForm1], #Kind]]
    →
    PG-stripLeftRecursion[PFK[#ParsedForm1, #Kind]]
    ;
    PG-stripLeftRecursion[
      PFK[
	RawHxParsedFormTerm[
	  RawHxScopeSortPrecRepeat[
	    RawHxScopeSort[
	      RawHxSort[RawHxSortName[#SortName, #_], '$Nil'],
	      RawHxRepeatSingle,
	      '$Nil'],
	    #Prec,
	    #Repeat],
	      #ParsedForm],
	#Kind]]
    →
    PFK[#ParsedForm, #Kind]
    ;

{#DM} PG-LeftRecursive2[#ModuleName, B_TRUE, #PFK1, #PFKs, #SortName, #Prec, #Last?, #LeftRecursivePFKs, #OtherPFKs]
→
{#DM} PG-LeftRecursive[#ModuleName, #PFKs, #SortName, #Prec, #Last?, Append[#LeftRecursivePFKs, (PG-stripLeftRecursion[#PFK1];)], #OtherPFKs]
;

{#DM} PG-LeftRecursive2[#ModuleName, B_FALSE, #PFK1, #PFKs, #SortName, #Prec, #Last?, #LeftRecursivePFKs, #OtherPFKs]
→
{#DM} PG-LeftRecursive[#ModuleName, #PFKs, #SortName, #Prec, #Last?, #LeftRecursivePFKs, Append[#OtherPFKs, (#PFK1;)]]
;

{#DM} PG-LeftRecursive[#ModuleName, (), #SortName, #Prec, #Last?, #LeftRecursivePFKs, #OtherPFKs]
→
IfEmpty[#LeftRecursivePFKs,
  // There is no left recursion -- use the plain expansion.
  {#DM} PG-Produce[#ModuleName, #SortName, #Prec, #Last?, #OtherPFKs, C_BUFFER[#SortName, #Prec]],
  // There is left recursion...
  {#DM} PG-ProduceBody[#ModuleName, #SortName, #LeftRecursivePFKs, 2, (%n⟨#1⟩;), (), C_LEFTRECURSIVE[#SortName, #Prec], in funs tags after .
    %n⟪
/***USERPG&EMBEDPG:
/* Handle left recursion. */
<«PG-ProductionNameWithPrecText[#SortName, #Prec]»LR #1> ::= ⟦
/***EMBEDPG: « {#DM}PG-Embed-Head[#Last?, #ModuleName, #SortName, #SortName, B_FALSE, 0] »***/
«in»
| {{#1}}⟧
. ***/
/***SORTS: †«PG-QN[#ModuleName, "NodeSort", #SortName]» ::= ( «tags» ); ***/

«funs»
« TextJoinMap[after, %n⟨
⟩] »
« {#DM} PG-Produce[#ModuleName, #SortName, #Prec, #Last?, #OtherPFKs, C_LEFTRECURSIVE[#SortName, #Prec]] »⟫]]
;

// 

{$String<!--SortName--> : DeclarationMapEntry} PG-Produce[$String<!--ModuleName-->, $String<!--SortName-->, $Numeric<!--Prec-->, Boolean<!--Last?-->, $List[PFK_SORT], CONSUMPTION_SORT] :: Text;

{#DM} PG-Produce[#ModuleName, #SortName, #Prec, #Last?, #PFKs, C_LEFTRECURSIVE[#SortName9, #Prec9]]
→
{#DM} PG-ProduceBody[#ModuleName, #SortName, #PFKs, 1, (), (), C_LEFTRECURSIVE[#SortName9, #Prec9], in funs tags after .
  %n⟪
/***USERPG&EMBEDPG:
<«PG-ProductionNameWithPrecText[#SortName, #Prec]»> ::= ⟦
«in»⟧ .
***/

/***SORTS: †«PG-QN[#ModuleName, "NodeSort", #SortName]» ::= ( «tags» ); ***/
«funs»
/***EMBEDPG:
« {#DM}PG-Embed-Tail[#Last?, #SortName, #SortName] »« TextJoinMap[after, %n⟨
⟩] »
***/
⟫]
;


-[Data[#consumer]]:
{#DM} PG-Produce[#ModuleName, #SortName, #Prec, #Last?, #PFKs, $[NotMatch,C_LEFTRECURSIVE[#_SortName, #_Prec],#consumer]]
→
{#DM} PG-ProduceBody[#ModuleName, #SortName, #PFKs, 1, (), (), #consumer, in funs tags after .
  %n⟪
/***USERPG&EMBEDPG:
<«PG-ProductionNameWithPrecText[#SortName,#Prec]»> ::= ⟦
/***EMBEDPG: « {#DM}PG-Embed-Head[#Last?, #ModuleName, #SortName, #SortName, B_FALSE, 0] »***/
«in»⟧ .
***/

« PG-TagSortDeclaration[#ModuleName, #SortName, funs, tags] »
/***EMBEDPG:
« {#DM}PG-Embed-Tail[#Last?, #SortName, #SortName] »« TextJoinMap[after, %n⟨
⟩] »
***/
⟫]
;


PG-TagSortDeclaration[#ModuleName, #SortName, #funs, #tags]
→
%n⟪
/***SORTS: †«PG-QN[#ModuleName, "TagSort", #SortName]» ::= ( « #tags » ); ***/
«#funs»⟫
;

{$String<!--SortName--> : DeclarationMapEntry} PG-ProduceBody[$String<!--ModuleName-->, $String<!--HostSort-->, $List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

-[Data[#PFKs]]:
{#DM} PG-ProduceBody[#ModuleName, #SortName, #PFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBody1[#ModuleName, #SortName, #PFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

// Pick branching kind.

{$String<!--SortName--> : DeclarationMapEntry} PG-ProduceBody1[$String<!--ModuleName-->, $String<!--HostSort-->, $List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

{#DM} PG-ProduceBody1[#ModuleName, #SortName, (), #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
#[%n⟪⟫, %n⟪⟫, %n⟪⟫, EmptyTextMap]
;

{#DM} PG-ProduceBody1[#ModuleName, #SortName, (PFK[RawHxParsedFormWord[#word, #ParsedForm], #Kind]; #Rest), #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyWord1[#ModuleName, #SortName, #Rest, (), #word, (PFK[#ParsedForm, #Kind];), #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{#DM} PG-ProduceBody1[#ModuleName, #SortName, (PFK[RawHxParsedFormTerm[RawHxScopeSortPrecRepeat[#ScopeSort, #Prec, #Repeat], #ParsedForm], #Kind]; #Rest), #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyTerm1[#ModuleName, #SortName, #Rest, (), #ScopeSort, #Prec, #Repeat, #Kind, (PFK[#ParsedForm, #Kind];), #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{#DM} PG-ProduceBody1[#ModuleName, #SortName, (PFK[RawHxParsedFormSpace[#space, #ParsedForm], #Kind]; #Rest), #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBody1[#ModuleName, #SortName, (PFK[#ParsedForm, #Kind]; #Rest), #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{#DM} PG-ProduceBody1[#ModuleName, #SortName, (PFK[RawHxParsedFormDone, #Kind]; #Rest), #n, #terms, #words, C_BUFFER[#SortName, #Prec], in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBody2[#ModuleName, #SortName, #Rest, #n, #terms, #words, C_BUFFER[#SortName, #Prec], in funs tags after . #[in,funs,tags,after],
  PG-AttributeCollection[#ModuleName, #Kind, #SortName, #Prec, PG-ProductionConstructionText[#ModuleName, #SortName, #Prec, #Kind, #words, #terms], B_FALSE],
  PG-ProductionSortFunsText[#ModuleName, #SortName, #Prec, #Kind, #words, #terms],
  PG-ProductionSortTagsText[#ModuleName, #SortName, #Prec, #Kind, #words, #terms],
  PG-AttributeProduction[#ModuleName, #Kind, #SortName, #Prec, B_FALSE]]
;

{#DM} PG-ProduceBody1[#ModuleName, #SortName, (PFK[RawHxParsedFormDone, #Kind]; #Rest), #n, #terms, #words, C_LEFTRECURSIVE[#SortName, #Prec], in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBody2[#ModuleName, #SortName, #Rest, #n, #terms, #words, C_LEFTRECURSIVE[#SortName, #Prec], in funs tags after . #[in,funs,tags,after],
  PG-AttributeCollection[#ModuleName, #Kind, #SortName, #Prec, PG-ProductionConstructionText[#ModuleName, #SortName, #Prec, #Kind, #words, #terms], B_TRUE],
  PG-ProductionSortFunsText[#ModuleName, #SortName, #Prec, #Kind, #words, #terms],
  PG-ProductionSortTagsText[#ModuleName, #SortName, #Prec, #Kind, #words, #terms],
  PG-AttributeProduction[#ModuleName, #Kind, #SortName, #Prec, B_TRUE]]
;

{$String<!--SortName--> : DeclarationMapEntry} PG-ProduceBody2[$String<!--ModuleName-->, $String<!--HostSort-->, $List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text, Text, TextMapSort] :: Text;
-[Data[#in2,#sort2,#after2]]:
{#DM} PG-ProduceBody2[#ModuleName, #SortName, #Rest, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after], #in2, #funs2, #tags2, #after2]
→
{#DM} PG-ProduceBody1[#ModuleName, #SortName, #Rest, #n, #terms, #words, #consumer, in funs tags after . #[%n⟪« #in2 »«in»⟫, %n⟪« #funs2 »«funs»⟫, %n⟪« #tags2 »«tags»⟫, JoinTextMaps[#after2, after]]]
;

PG-AttributeCollection[FormKind, $String, $Numeric, Text, Boolean] :: Text;

PG-AttributeCollection[#ModuleName, #Kind, #SortName, #Prec, #Construct, B_FALSE] → #Construct ;
PG-AttributeCollection[#ModuleName, #Kind, #SortName, #Prec, #Construct, B_TRUE] → %n⟪<«PG-ProductionNameWithPrecText[#SortName,#Prec]»LR «#Construct»>⟫ ;

PG-AttributeProduction[FormKind, $String, $Numeric, Boolean] :: TextMapSort;
PG-AttributeProduction[#ModuleName, #dontcare, #SortName, #Prec, #IsLeftRecursive]
→
EmptyTextMap //TODO: eliminate?
;

PG-ProductionSortFunsText[$String<!--ModuleName-->, $String, $Numeric, FormKind, $List[Text], $List[Text]] :: Text;

-[Data[#SortName,#Prec],Data[#words]]:
PG-ProductionSortFunsText[#ModuleName, #SortName, #Prec, #scheme, #words, #terms]
→
%n⟪
/***METAELIM: †«PG-QN[#ModuleName, "Node", #SortName]»[†« PG-QN[#ModuleName, "Tag", StringJoin[(PG-ProductionNameWithPrec[#SortName, #Prec]; IfEmpty[#words, "EMPTY", MapWhen[ok x.TextToStringWhen[ok, x], #words]]), "_"]] »« WrappedTextJoin[#terms, %n⟨, (⟩, %n⟨; ⟩, %n⟨;)⟩] »]; ***/
⟫;

PG-ProductionSortTagsText[$String<!--ModuleName-->, $String, $Numeric, FormKind, $List[Text], $List[Text]] :: Text;

-[Data[#SortName,#Prec],Data[#words]]:
PG-ProductionSortTagsText[#ModuleName, #SortName, #Prec, #scheme, #words, #terms]
→
%n⟪†« PG-QN[#ModuleName, #SortName, StringJoin[(PG-ProductionNameWithPrec[#SortName, #Prec]; IfEmpty[#words, "EMPTY", MapWhen[ok x.TextToStringWhen[ok, x], #words]]), "_"]] »; ⟫
;




// Generate PG instructions to construct a result term.

PG-ProductionConstructionText[$String<!--ModuleName-->, $String, $Numeric, FormKind, $List[Text], $List[Text]] :: Text;

-[Data[#SortName,#Prec],Data[#words]]:
PG-ProductionConstructionText[#ModuleName, #SortName, #Prec, FK_SCHEME[#Inh], #words, #terms]
→
%n⟪⟦ {{ '†« PG-QN[#ModuleName, #SortName, IfEmpty[#words, "EMPTY", MapStringConcatWhen[ok x.TextToStringWhen[ok, x], #words]]] »'« WrappedTextJoin[#terms, %n⟨[⟩, %n⟨, ⟩, %n⟨]⟩] » }}⟧
⟫
;

-[Data[#SortName,#Prec],Data[#words]]:
PG-ProductionConstructionText[#ModuleName, #SortName, #Prec, FK_SUGAR[#Inh], #words, #terms]
→
%n⟪ {{ « WrappedTextJoin[#terms, %n⟨⟩, %n⟨ ⟩, %n⟨⟩] » }}
⟫
;


-[Data[#SortName,#Prec,#Kind],Data[#words]]:
PG-ProductionConstructionText[#ModuleName, #SortName, #Prec, $[NotMatch,FK_SCHEME[#_Inh],$[NotMatch,FK_SUGAR[#_term],#Kind]], #words, #terms]
→
IfAliasKind[#Kind, WrappedTextJoin[#terms, %n⟨ {{⟩, %n⟨ ⟩, %n⟨}}⟩],
  %n⟪⟦ {{ '†« PG-QN[#ModuleName, #SortName, IfEmpty[#words, "EMPTY", MapStringConcatWhen[ok x.TextToStringWhen[ok, x], #words]]] »'« WrappedTextJoin[#terms, %n⟨[⟩, %n⟨, ⟩, %n⟨]⟩] » }}⟧
⟫]
;

    ∀ a . IfAliasKind[FormKind, a, a] :: a;
    IfAliasKind[FK_ALIAS, #1, #2] → #1 ;
    IfAliasKind[FK_SYMBOL[#IsStatic, #t], #1, #2] → #1 ;
    -[Data[#Kind]]: IfAliasKind[$[NotMatch,FK_ALIAS,$[NotMatch,FK_SYMBOL[#IsStatic, #t],#Kind]], #1, #2] → #2 ;




// (1) Constant Token Case: (a) collect productions starting with the constant token and ...

{$String<!--SortName--> : DeclarationMapEntry} PG-ProduceBodyWord1[$String<!--ModuleName-->, $String<!--HostSort-->, $List[PFK_SORT], $List[PFK_SORT], $String, $List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

-[Data[#word1,#word],Share[#ParsedForm1,#Kind1,#Rest,#wordPFKs,#n,#terms,#words,#consumer]]:
{#DM} PG-ProduceBodyWord1[#ModuleName, #SortName, (PFK[RawHxParsedFormWord[#word1, #ParsedForm1], #Kind1]; #Rest), #Failed, #word, #wordPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
$[If, $[Equal, #word, #word1],
  {#DM} PG-ProduceBodyWord1[#ModuleName, #SortName, #Rest, #Failed, #word, Append[#wordPFKs, (PFK[#ParsedForm1, #Kind1];)], #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]],
  {#DM} PG-ProduceBodyWord1[#ModuleName, #SortName, #Rest, Append[#Failed, (PFK[RawHxParsedFormWord[#word1, #ParsedForm1], #Kind1];)], #word, #wordPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]]
;

{#DM} PG-ProduceBodyWord1[#ModuleName, #SortName, (PFK[RawHxParsedFormTerm[#ScopeSortPrecRepeat1, #ParsedForm1], #Kind]; #Rest), #Failed, #word, #wordPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyWord1[#ModuleName, #SortName, #Rest, Append[#Failed, (PFK[RawHxParsedFormTerm[#ScopeSortPrecRepeat1, #ParsedForm1], #Kind];)], #word, #wordPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{#DM} PG-ProduceBodyWord1[#ModuleName, #SortName, (PFK[RawHxParsedFormSpace[#space1, #ParsedForm1], #Kind1]; #Rest), #Failed, #word, #wordPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyWord1[#ModuleName, #SortName, (PFK[#ParsedForm1, #Kind1]; #Rest), #Failed, #word, #wordPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{#DM} PG-ProduceBodyWord1[#ModuleName, #SortName, (PFK[RawHxParsedFormDone, #Kind]; #Rest), #Failed, #word, #wordPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyWord1[#ModuleName, #SortName, #Rest, Append[#Failed, (PFK[RawHxParsedFormDone, #Kind];)], #word, #wordPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{#DM} PG-ProduceBodyWord1[#ModuleName, #SortName, (), #Failed, #word, #wordPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyWord2[#ModuleName, #SortName, #Failed, #word, #wordPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

// ... (b) emit constant token branch.

{$String<!--SortName--> : DeclarationMapEntry} PG-ProduceBodyWord2[$String<!--ModuleName-->, $String<!--HostSort-->, $List[PFK_SORT], $String, $List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

{#DM} PG-ProduceBodyWord2[#ModuleName, #SortName, (), #word, #wordPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBody[#ModuleName, #SortName, #wordPFKs, #n, #terms, Append[#words, (%n⟨†‹$[Escape[""],#word]›⟩;)], #consumer, in1 funs1 tags1 after1 . #[%n⟪« ProductionWord[#word] »⟦« in1 »⟧⟫, funs1, tags1, after1]]
;

{#DM} PG-ProduceBodyWord2[#ModuleName, #SortName, (#PFK1;#PFKs), #word, #wordPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBody[#ModuleName, #SortName, #wordPFKs, #n, #terms, Append[#words, (%n⟨†‹$[Escape[""],#word]›⟩;)], #consumer, in1 funs1 tags1 after1 .
  {#DM} PG-ProduceBody[#ModuleName, #SortName, (#PFK1;#PFKs), #n, #terms, #words, #consumer, in2 funs2 tags2 after2 .
    #[%n⟪(« ProductionWord[#word] » « in1 »
| « in2 » ) ⟫, %n⟪«funs1»«funs2»⟫, %n⟪«tags1»«tags2»⟫, JoinTextMaps[after1, after2]]]]
;

    ProductionWord[$String] :: Text;
    ProductionWord[#word] → %n⟪†« Stringify[#word] »⟫ ;

// (2) Common Nonterminal: (a) collect productions starting with the nonterminal and...

{$String : DeclarationMapEntry} PG-ProduceBodyTerm1[$String<!--ModuleName-->, $String<!--HostSort-->,
	$List[PFK_SORT], $List[PFK_SORT], HxScopeSort, $Numeric, HxRepeat, FormKind, $List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

{#DM} PG-ProduceBodyTerm1[#ModuleName, #SortName, (PFK[RawHxParsedFormWord[#word1, #ParsedForm1], #Kind1]; #Rest), #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyTerm1[#ModuleName, #SortName, #Rest, Append[#Failed, (PFK[RawHxParsedFormWord[#word1, #ParsedForm1], #Kind1];)], #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{#DM} PG-ProduceBodyTerm1[#ModuleName, #SortName, (PFK[RawHxParsedFormTerm[RawHxScopeSortPrecRepeat[#ScopeSort1, #Prec1, #Repeat1], #ParsedForm1], #Kind1]; #Rest), #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyTerm1x[#ModuleName, #SortName, PG-SameScopeSort[#ScopeSort1, #Prec1, #Repeat1, #ScopeSort, #Prec, #Repeat], #ScopeSort1, #Prec1, #Repeat1, #ParsedForm1, #Kind1, #Rest, #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

    // Local test if two ScopeSorts are the same.

    PG-SameScopeSort[HxScopeSort, $Numeric, HxRepeat, HxScopeSort, $Numeric, HxRepeat] :: Boolean;
    PG-SameScopeSort[#Sort1, #Prec1, #Repeat1, #Sort2, #Prec2, #Repeat2] → PG-SameScopeSort2[#Sort1, #Sort2, #Prec1, #Repeat1, #Prec2, #Repeat2] ;

    PG-SameScopeSort2[HxScopeSort, HxScopeSort, $Numeric, HxRepeat, $Numeric, HxRepeat] :: Boolean;

    PG-SameScopeSort2[%rawHxScopeSort⟪ #HxSort1# [ #HxSubstituteSorts1# ] ⟫, %rawHxScopeSort⟪ #HxSort2# [ #HxSubstituteSorts2# ] ⟫, #Prec1, #Repeat1, #Prec2, #Repeat2]
    →
    And[PG-SameSort[#HxSort1#, #HxSort2#], And[PG-SamePrec[#Prec1, #Prec2], PG-SubRepeat[#Repeat1, #Repeat2]]]
    ;
    -[Free[v1::Text]]:
    PG-SameScopeSort2[%rawHxScopeSort⟪ #HxSort1# binds v1 ⟫                , %rawHxScopeSort⟪ #HxSort2# [ #HxSubstituteSorts2# ] ⟫, #P1, #R1, #P2, #R2] → B_FALSE ;
    -[Free[v2::Text]]:
    PG-SameScopeSort2[%rawHxScopeSort⟪ #HxSort1# [ #HxSubstituteSorts1# ] ⟫, %rawHxScopeSort⟪ #HxSort2# binds v2 ⟫, #P1, #R1, #P2, #R2] → B_FALSE ;
    -[Free[v1::Text,v2::Text]]:
    PG-SameScopeSort2[%rawHxScopeSort⟪ #HxSort1# binds v1 ⟫                , %rawHxScopeSort⟪ #HxSort2# binds v2 ⟫, #P1, #R1, #P2, #R2] → PG-SameSort[#HxSort1#, #HxSort2#] ;

    PG-SameSort[HxSort, HxSort] :: Boolean;
    -[Data[#1,#2]]: PG-SameSort[#1, #2] → PG-SameSort2[#1, #2] ;

    PG-SameSort2[HxSort, HxSort] :: Boolean;

    -[Data[#HxSortName1#,#HxSortName2#]]:
    PG-SameSort2[%rawHxSort⟪ #HxSortName1# #HxMetaVariables1# #HxSimpleSorts1# ⟫, %rawHxSort⟪ #HxSortName2# #HxMetaVariables2# #HxSimpleSorts2# ⟫]
    →
    $[If, $[Equal, #HxSortName1#, #HxSortName2#], B_TRUE, B_FALSE]
    ;

    PG-SameSort2[$[NotMatch,%rawHxSort⟪ #HxSortName1# #HxMetaVariables1# #HxSimpleSorts1# ⟫,#1], #2]
    →
    B_FALSE
    ;

    PG-SameSort2[#1,$[NotMatch,%rawHxSort⟪ #HxSortName2# #HxMetaVariables2# #HxSimpleSorts2# ⟫,#2]]
    →
    B_FALSE
    ;

    PG-SamePrec[$Numeric, $Numeric] :: Boolean;
    -[Data[#Prec1,#Prec2]]: PG-SamePrec[#Prec1, #Prec2] → $[If, $[NumericEqual, #Prec1, #Prec2], B_TRUE, B_FALSE] ;

    PG-SubRepeat[HxRepeat, HxRepeat] :: Boolean;

    PG-SubRepeat-single: PG-SubRepeat[%rawHxRepeat⟪ ⟫, #Repeat2] → B_TRUE ;

    PG-SubRepeat-maybe-single: PG-SubRepeat[%rawHxRepeat⟪ ? ⟫, %rawHxRepeat⟪ ⟫] → B_FALSE;
    PG-SubRepeat-maybe-maybe: PG-SubRepeat[%rawHxRepeat⟪ ? ⟫, %rawHxRepeat⟪ ? ⟫] → B_TRUE;
    PG-SubRepeat-maybe-many: PG-SubRepeat[%rawHxRepeat⟪ ? ⟫, %rawHxRepeat⟪ * ⟫] → B_TRUE;
    PG-SubRepeat-maybe-some: PG-SubRepeat[%rawHxRepeat⟪ ? ⟫, %rawHxRepeat⟪ + ⟫] → B_FALSE;
    PG-SubRepeat-maybe-somesep: PG-SubRepeat[%rawHxRepeat⟪ ? ⟫, %rawHxRepeat⟪ + _ #HxRegExpSub2# ⟫] → B_FALSE;

    PG-SubRepeat-some-single: PG-SubRepeat[%rawHxRepeat⟪ + ⟫, %rawHxRepeat⟪ ⟫] → B_FALSE;
    PG-SubRepeat-some-maybe: PG-SubRepeat[%rawHxRepeat⟪ + ⟫, %rawHxRepeat⟪ ? ⟫] → B_FALSE;
    PG-SubRepeat-some-many: PG-SubRepeat[%rawHxRepeat⟪ + ⟫, %rawHxRepeat⟪ * ⟫] → B_TRUE;
    PG-SubRepeat-some-some: PG-SubRepeat[%rawHxRepeat⟪ + ⟫, %rawHxRepeat⟪ + ⟫] → B_TRUE;
    PG-SubRepeat-some-somesep: PG-SubRepeat[%rawHxRepeat⟪ + ⟫, %rawHxRepeat⟪ + _ #HxRegExpSub2# ⟫] → B_FALSE;

    PG-SubRepeat-many-many: PG-SubRepeat[%rawHxRepeat⟪ * ⟫, %rawHxRepeat⟪ * ⟫] → B_TRUE ;
    PG-SubRepeat-many-other[Data[#_]]: PG-SubRepeat[%rawHxRepeat⟪ * ⟫, $[NotMatch,%rawHxRepeat⟪ * ⟫,#_]] → B_FALSE;

    PG-SubRepeat-somesep-single: PG-SubRepeat[%rawHxRepeat⟪ + _ #HxRegExpSub1# ⟫, %rawHxRepeat⟪ ⟫] → B_FALSE;
    PG-SubRepeat-somesep-maybe: PG-SubRepeat[%rawHxRepeat⟪ + _ #HxRegExpSub1# ⟫, %rawHxRepeat⟪ ? ⟫] → B_FALSE;
    PG-SubRepeat-somesep-many: PG-SubRepeat[%rawHxRepeat⟪ + _ #HxRegExpSub1# ⟫, %rawHxRepeat⟪ * ⟫] → B_FALSE;
    PG-SubRepeat-somesep-some: PG-SubRepeat[%rawHxRepeat⟪ + _ #HxRegExpSub1# ⟫, %rawHxRepeat⟪ + ⟫] → B_FALSE;

    PG-SubRepeat-somesep-string-string: PG-SubRepeat[%rawHxRepeat⟪ + _ #HxString1# ⟫, %rawHxRepeat⟪ + _ #HxString2# ⟫] → SameString[UnString[#HxString1#], UnString[#HxString2#]] ;
    PG-SubRepeat-somesep-string-word: PG-SubRepeat[%rawHxRepeat⟪ + _ #HxString1# ⟫, %rawHxRepeat⟪ + _ #HxSeparator2# ⟫] → SameString[UnString[#HxString1#], #HxSeparator2#] ;
    PG-SubRepeat-somesep-word-string: PG-SubRepeat[%rawHxRepeat⟪ + _ #HxSeparator1# ⟫, %rawHxRepeat⟪ + _ #HxString2# ⟫] → SameString[#HxSeparator1#, UnString[#HxString2#]] ;
    PG-SubRepeat-somesep-word-word: PG-SubRepeat[%rawHxRepeat⟪ + _ #HxSeparator1# ⟫, %rawHxRepeat⟪ + _ #HxSeparator2# ⟫] → SameString[#HxSeparator1#, #HxSeparator2#] ;







{#DM} PG-ProduceBodyTerm1[#ModuleName, #SortName, (PFK[RawHxParsedFormSpace[#space1, #ParsedForm1], #Kind1]; #Rest), #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyTerm1[#ModuleName, #SortName, (PFK[#ParsedForm1, #Kind1]; #Rest), #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{#DM} PG-ProduceBodyTerm1[#ModuleName, #SortName, (PFK[RawHxParsedFormDone, #Kind1]; #Rest), #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyTerm1[#ModuleName, #SortName, #Rest, Append[#Failed, (PFK[RawHxParsedFormDone, #Kind1];)], #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{#DM} PG-ProduceBodyTerm1[#ModuleName, #SortName, (), #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyTerm2[#ModuleName, #SortName, #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

// ... helper to filter identical scope sorts...

{$String : DeclarationMapEntry}
PG-ProduceBodyTerm1x[$String<!--ModuleName-->, $String<!--HostSort-->, Boolean, HxScopeSort, $Numeric, HxRepeat, HxParsedForm, FormKind,
	$List[PFK_SORT], $List[PFK_SORT], HxScopeSort, $Numeric, HxRepeat, FormKind, $List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

{#DM} PG-ProduceBodyTerm1x[#ModuleName, #SortName, B_FALSE, #ScopeSort1, #Prec1, #Repeat1, #ParsedForm1, #Kind1, #Rest, #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyTerm1[#ModuleName, #SortName, #Rest, Append[#Failed, (PFK[RawHxParsedFormTerm[RawHxScopeSortPrecRepeat[#ScopeSort1, #Prec1, #Repeat1], #ParsedForm1], #Kind1];)], #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{#DM} PG-ProduceBodyTerm1x[#ModuleName, #SortName, B_TRUE, #ScopeSort1, #Prec1, #Repeat1, #ParsedForm1, #Kind1, #Rest, #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyTerm1[#ModuleName, #SortName, #Rest, #Failed, #ScopeSort, #Prec, #Repeat, #Kind, Append[#nonterminalPFKs, (PFK[#ParsedForm1, #Kind1];)], #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

// ... (b) emit branch (with recursive nesting of tail).

{$String : DeclarationMapEntry} PG-ProduceBodyTerm2[$String<!--ModuleName-->, $String<!--HostSort-->, $List[PFK_SORT], HxScopeSort, $Numeric, HxRepeat, FormKind, $List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

{#DM} PG-ProduceBodyTerm2[#ModuleName, #SortName, (), #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyTerm3[#ModuleName, #SortName, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{#DM} PG-ProduceBodyTerm2[#ModuleName, #SortName, (#PFK1;#PFKs), #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyTerm3[#ModuleName, #SortName, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in1 funs1 tags1 after1 .
  {#DM} PG-ProduceBody[#ModuleName, #SortName, (#PFK1;#PFKs), #n, #terms, #words, #consumer, in2 funs2 tags2 after2 .
    #[%n⟪(« in1 »
| « in2 »)⟫, %n⟪«funs1»«funs2»⟫, %n⟪«tags1»«tags2»⟫, JoinTextMaps[after1, after2]]]]
;

{$String : DeclarationMapEntry} PG-ProduceBodyTerm3[$String<!--ModuleName-->, $String<!--HostSort-->, HxScopeSort, $Numeric, HxRepeat, FormKind, $List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

-[Free[v::Text]]:
{#DM} PG-ProduceBodyTerm3[#ModuleName, #SortName, %rawHxScopeSort⟪ #HxSort# binds v ⟫, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
IfSingletonRepeat[#Repeat,
  {#DM} PG-ProduceBody[#ModuleName, #SortName, #nonterminalPFKs, #n, #terms,  Append[#words, (%n⟨†‹SortVar[#HxSort#]›⟩;)], #consumer, in funs tags after .
    #[%n⟪⟦ <«PG-ProductionNameWithPrecText[{#DM}PG-SymbolSortTokenName[PG-SortName[#HxSort#]], #Prec]»>^«v» ⟦« in »⟧ ⟧⟫, funs, tags, after]],
  PrepError["Cannot use repeat specification on binder"]]
;

    SortVar[HxSort] :: $String;
    -[Data[#Sort]]: SortVar[#Sort] → SortVar2[#Sort] ;
    SortVar2[HxSort] :: $String;
    -[Data[#SortName]]: SortVar2[           %rawHxSort⟪ #HxSortName# #HxMetaVariables# #HxSimpleSorts# ⟫] → SortVar3[#HxSortName#, #HxMetaVariables#] ;
                        SortVar2[$[NotMatch,%rawHxSort⟪ #HxSortName# #HxMetaVariables# #HxSimpleSorts# ⟫,#]] →  "bad" ;
    SortVar3[$String, $List[$String]] :: $String;
    SortVar3[#SortName, ()] → $[:,"v",#SortName] ;
    SortVar3[#SortName, (#MetaVar;)] → $[:,"v",#SortName,$[Replace,#MetaVar,"#",""]] ;

{#DM} PG-ProduceBodyTerm3[#ModuleName, #SortName, %rawHxScopeSort⟪ #HxSort# #HxRepeat# [ #HxSubstituteSorts# ] ⟫, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBodyTerm4[#ModuleName, #SortName, #HxSort#, #HxSubstituteSorts#, PG-ProductionNameWithPrecRepeatText[PG-SortName[#HxSort#], #Prec, NestedRepeat[#HxRepeat#, #Repeat]], #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{$String : DeclarationMapEntry} PG-ProduceBodyTerm4[$String<!--ModuleName-->, $String<!--HostSort-->, HxSort, $List[HxSubstituteSort], Text, $Numeric, HxRepeat, FormKind, $List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

-[Data[#consumer]]:
{#DM} PG-ProduceBodyTerm4[#ModuleName, #SortName, #HxSort#, #HxSubstituteSorts#, #ProductionName, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #terms, #words, <!--$[NotMatch,C_INLINE,-->#consumer<!--]-->, in funs tags after . #[in,funs,tags,after]]
→
{#DM} PG-ProduceBody[#ModuleName, #SortName, #nonterminalPFKs, $[Plus,#n,1],
  Append[#terms, (%n⟨†‹ PG-SortMetaVar[#HxSort#, #n] ›⟩;)],
  Append[#words, (%n⟨†‹ PG-SortName[#HxSort#] ›⟩;)],
  #consumer,
  in funs tags after .
    #[%n⟪⟦( <« #ProductionName »>«
	WrappedTextJoin[Map[s.PG-ExtractSubstitutedSort[s], #HxSubstituteSorts#], %n⟨[⟩, %n⟨,⟩, %n⟨]⟩] »«
	PG-VariableMarker[#Kind, %n⟨:†‹ PG-SortMetaVar[#HxSort#, #n] ›⟩] » ⟦« in »⟧ )
      ⟧⟫, funs, tags, after]]
///    #[%n⟪⟦( « PG-VariablePrefix[#Kind, #ModuleName, #SortName, #ProductionName] » <« #ProductionName »>«
///	WrappedTextJoin[Map[s.PG-ExtractSubstitutedSort[s], #HxSubstituteSorts#], %n⟨[⟩, %n⟨,⟩, %n⟨]⟩] »«
///	PG-VariableMarker[#Kind, %n⟨:†‹ PG-SortMetaVar[#HxSort#, #n] ›⟩] » ⟦« in »⟧ )
///      ⟧⟫, funs, tags, after]]
;

    PG-SortMetaVar[HxSort, $Numeric] :: $String;
    -[Data[#Sort]]: PG-SortMetaVar[#Sort, #n] → PG-SortMetaVar2[#Sort, #n] ;
    PG-SortMetaVar2[HxSort, $Numeric] :: $String;
    PG-SortMetaVar2[           %rawHxSort⟪ #HxSortName# #HxMetaVariable# #HxSimpleSorts# ⟫,    #n] → #HxMetaVariable# ;
    PG-SortMetaVar2[           %rawHxSort⟪ #HxSortName#                #HxSimpleSorts# ⟫,    #n] → $[:,"#_",#HxSortName#,"_",$[FormatNumber,#n]] ;
    PG-SortMetaVar2[$[NotMatch,%rawHxSort⟪ #HxSortName# #HxMetaVariables# #HxSimpleSorts# ⟫,#], #n] →  "#bad" ;

    // TODO: Eliminate redundant repeat productions!

    PG-ExtractSubstitutedSort[HxSubstituteSort] :: Text;
    -[Free[v1::Text]]:
    PG-ExtractSubstitutedSort[%rawHxSubstituteSort⟪ v1 as #HxSort2# ⟫] → %n⟪«v1»⟫ ;

///    PG-VariablePrefix[FormKind, $String<!--ModuleName-->, $String<!--SortName-->, Text<!--Other-->] :: Text;
///    -[Data[#Kind,#ModuleName,#SortName]]: PG-VariablePrefix[#Kind, #ModuleName, #SortName, #Other] → PG-VariablePrefix2[#Kind, #ModuleName, #SortName, #Other] ;
///
///    PG-VariablePrefix2[FormKind, $String<!--ModuleName-->, $String<!--SortName-->, Text<!--Other-->] :: Text;
///    PG-VariablePrefix2[FK_SYMBOL[#free, #t], #ModuleName, #SortName, #Other] → %n⟪/***EMBEDPG:{†« PG-QN[#ModuleName,"Var", #SortName] »_«#Other»}***/⟫ ;
///    PG-VariablePrefix2[$[NotMatch,FK_SYMBOL[#IsStatic,#t],#Kind], #ModuleName, #SortName, #Other] → %n⟪⟫ ;

    PG-VariableMarker[FormKind, Text] :: Text;
    -[Data[#Kind]]: PG-VariableMarker[#Kind, #Other] → PG-VariableMarker2[#Kind, #Other] ;

    PG-VariableMarker2[FormKind, Text] :: Text;
    PG-VariableMarker2[FK_SYMBOL[$False,#t], #Other] → %n⟪!!!« #Other »⟫ ;
    PG-VariableMarker2[FK_SYMBOL[$True,#t], #Other] → %n⟪!!« #Other »⟫ ;
    PG-VariableMarker2[$[NotMatch,FK_SYMBOL[#IsStatic,#t],#Kind], #Other] → #Other ;


// REPEATS.

∀ a . IfSingletonRepeat[HxRepeat, a, a] :: a;
IfSingletonRepeat[%rawHxRepeat⟪ ⟫, #1, #2] → #1 ;
IfSingletonRepeat[%rawHxRepeat⟪ ? ⟫, #1, #2] → #2 ;
IfSingletonRepeat[%rawHxRepeat⟪ * ⟫, #1, #2] → #2 ;
IfSingletonRepeat[%rawHxRepeat⟪ + ⟫, #1, #2] → #2 ;
IfSingletonRepeat[%rawHxRepeat⟪ + _ #HxRegExpSub# ⟫, #1, #2] → #2 ;

NestedRepeat[HxRepeat, HxRepeat] :: HxRepeat;
NestedRepeat-single-single:   NestedRepeat[%rawHxRepeat⟪ ⟫, %rawHxRepeat⟪ ⟫]                                     → %rawHxRepeat⟪ ⟫ ;
NestedRepeat-single-maybe :   NestedRepeat[%rawHxRepeat⟪ ⟫, %rawHxRepeat⟪ ? ⟫]                                   → %rawHxRepeat⟪ ? ⟫ ;
NestedRepeat-single-many:     NestedRepeat[%rawHxRepeat⟪ ⟫, %rawHxRepeat⟪ * ⟫]                                   → %rawHxRepeat⟪ * ⟫ ;
NestedRepeat-single-some:     NestedRepeat[%rawHxRepeat⟪ ⟫, %rawHxRepeat⟪ + ⟫]                                   → %rawHxRepeat⟪ + ⟫ ;
NestedRepeat-single-somesep:  NestedRepeat[%rawHxRepeat⟪ ⟫, %rawHxRepeat⟪ + _ #HxRegExpSub2# ⟫]                   → %rawHxRepeat⟪ + _ #HxRegExpSub2# ⟫ ;
NestedRepeat-maybe-single:    NestedRepeat[%rawHxRepeat⟪ ? ⟫, %rawHxRepeat⟪ ⟫]                                   → %rawHxRepeat⟪ ? ⟫ ;
NestedRepeat-maybe-maybe :    NestedRepeat[%rawHxRepeat⟪ ? ⟫, %rawHxRepeat⟪ ? ⟫]                                 → %rawHxRepeat⟪ ? ⟫ ;
NestedRepeat-maybe-many:      NestedRepeat[%rawHxRepeat⟪ ? ⟫, %rawHxRepeat⟪ * ⟫]                                 → %rawHxRepeat⟪ * ⟫ ;
NestedRepeat-maybe-some:      NestedRepeat[%rawHxRepeat⟪ ? ⟫, %rawHxRepeat⟪ + ⟫]                                 → %rawHxRepeat⟪ * ⟫ ;
NestedRepeat-maybe-somesep:   NestedRepeat[%rawHxRepeat⟪ ? ⟫, %rawHxRepeat⟪ + _ #HxRegExpSub2# ⟫]                 → $[Error,"Cannot nest ? in +_'...' repeater."] ;
NestedRepeat-many-single:     NestedRepeat[%rawHxRepeat⟪ * ⟫, %rawHxRepeat⟪ ⟫]                                   → %rawHxRepeat⟪ * ⟫ ;
NestedRepeat-many-maybe :     NestedRepeat[%rawHxRepeat⟪ * ⟫, %rawHxRepeat⟪ ? ⟫]                                 → %rawHxRepeat⟪ * ⟫ ;
NestedRepeat-many-many:       NestedRepeat[%rawHxRepeat⟪ * ⟫, %rawHxRepeat⟪ * ⟫]                                 → %rawHxRepeat⟪ * ⟫ ;
NestedRepeat-many-some:       NestedRepeat[%rawHxRepeat⟪ * ⟫, %rawHxRepeat⟪ + ⟫]                                 → %rawHxRepeat⟪ * ⟫ ;
NestedRepeat-many-somesep:    NestedRepeat[%rawHxRepeat⟪ * ⟫, %rawHxRepeat⟪ + _ #HxRegExpSub2# ⟫]                 → $[Error,"Cannot nest * in +_'...' repeater."] ;
NestedRepeat-some-single:     NestedRepeat[%rawHxRepeat⟪ + ⟫, %rawHxRepeat⟪ ⟫]                                   → %rawHxRepeat⟪ + ⟫ ;
NestedRepeat-some-maybe :     NestedRepeat[%rawHxRepeat⟪ + ⟫, %rawHxRepeat⟪ ? ⟫]                                 → %rawHxRepeat⟪ * ⟫ ;
NestedRepeat-some-many:       NestedRepeat[%rawHxRepeat⟪ + ⟫, %rawHxRepeat⟪ * ⟫]                                 → %rawHxRepeat⟪ * ⟫ ;
NestedRepeat-some-some:       NestedRepeat[%rawHxRepeat⟪ + ⟫, %rawHxRepeat⟪ + ⟫]                                 → %rawHxRepeat⟪ + ⟫ ;
NestedRepeat-some-somesep:    NestedRepeat[%rawHxRepeat⟪ + ⟫, %rawHxRepeat⟪ + _ #HxRegExpSub2# ⟫]                 → %rawHxRepeat⟪ + _ #HxRegExpSub2# ⟫ ;
NestedRepeat-somesep-single:  NestedRepeat[%rawHxRepeat⟪ + _ #HxRegExpSub1# ⟫, %rawHxRepeat⟪ ⟫]                   → %rawHxRepeat⟪ + _ #HxRegExpSub1# ⟫ ;
NestedRepeat-somesep-maybe :  NestedRepeat[%rawHxRepeat⟪ + _ #HxRegExpSub1# ⟫, %rawHxRepeat⟪ ? ⟫]                 → $[Error,"Cannot nest +_'...' in ? repeater."] ;
NestedRepeat-somesep-many:    NestedRepeat[%rawHxRepeat⟪ + _ #HxRegExpSub1# ⟫, %rawHxRepeat⟪ * ⟫]                 → $[Error,"Cannot nest +_'...' in * repeater."] ;
NestedRepeat-somesep-some:    NestedRepeat[%rawHxRepeat⟪ + _ #HxRegExpSub1# ⟫, %rawHxRepeat⟪ + ⟫]                 → $[Error,"Cannot nest +_'...' in + repeater."] ;
NestedRepeat-somesep-somesep: NestedRepeat[%rawHxRepeat⟪ + _ #HxRegExpSub1# ⟫, %rawHxRepeat⟪ + _ #HxRegExpSub2# ⟫] → $[Error,"Cannot nest +_'...' in another +_'...' repeater."] ;








//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// . TEXT OF LEXICAL DECLARATIONS.

// a.

// Instantiate CPS processing.
PG-Lexical[$List[HxDeclaration], $String<!--ModuleName-->] :: Text ;
PG-Lexical[#Declarations, #ModuleName] → PG-Lexical2[#Declarations, #ModuleName, B_FALSE, hasskip.PG-Lexical2Tail[hasskip]] ;

// Generate PG token instructions per HACS declaration.

PG-Lexical2[$List[HxDeclaration], $String, Boolean, ha::Boolean.Text] :: Text ;

Lexical-module:
PG-Lexical2[%rawHxDeclarations⟪ module #HxModuleName2# { #HxDeclarations2# } ; #HxDeclarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
PG-Lexical2[#HxDeclarations2#, #HxModuleName2#, #hasSkip, hasskip.PG-Lexical2[#HxDeclarations#, #ModuleName, hasskip, hasskip2.#[hasskip2]]]
;

Lexical-space:
PG-Lexical2[%rawHxDeclarations⟪ space #HxRegExp# ; #HxDeclarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
%n⟪skip ::= ' ' | ⟦« PG-InlineRegExp[#HxRegExp#, #ModuleName, "space$"] »⟧ .
« PG-DeclareRegExp[#HxRegExp#, #ModuleName, "space$"] »« PG-Lexical2[#HxDeclarations#, #ModuleName, B_TRUE, hasskip.#[hasskip]] »⟫
;

Lexical-token:
PG-Lexical2[%rawHxDeclarations⟪ token #HxTokenName# | #HxRegExp# ; #HxDeclarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
%n⟪token «PG-TokenNameText[#HxTokenName#]» ::= ⟦« PG-InlineRegExp[#HxRegExp#, #ModuleName, #HxTokenName#] »⟧ .
« PG-DeclareRegExp[#HxRegExp#, #ModuleName, #HxTokenName#] »« PG-Lexical2[#HxDeclarations#, #ModuleName, #hasSkip, hasskip.#[hasskip]] »⟫
;

Lexical-fragment:
PG-Lexical2[%rawHxDeclarations⟪ fragment #HxTokenName# | #HxRegExp# ; #HxDeclarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
%n⟪token fragment «PG-TokenNameText[#HxTokenName#]» ::= ⟦« PG-InlineRegExp[#HxRegExp#, #ModuleName, #HxTokenName#] »⟧ .
« PG-DeclareRegExp[#HxRegExp#, #ModuleName, #HxTokenName#] »« PG-Lexical2[#HxDeclarations#, #ModuleName, #hasSkip, hasskip.#[hasskip]] »⟫
;

Lexical-attribute:
PG-Lexical2[%rawHxDeclarations⟪ attribute #HxAttributeKind# #HxAttributeName# #HxAttributeForm# ; #HxDeclarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
PG-Lexical2[#HxDeclarations#, #ModuleName, #hasSkip, hasskip.#[hasskip]]
;

Lexical-sort:
PG-Lexical2[%rawHxDeclarations⟪ sort #HxSortName# #HxRepeat# #HxSortAbstraction# ; #HxDeclarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
PG-Lexical2[#HxDeclarations#, #ModuleName, #hasSkip, hasskip.#[hasskip]]
;

Lexical-main-sort:
PG-Lexical2[%rawHxDeclarations⟪ main sort #HxSortName# #HxRepeat# #HxSortAbstraction# ; #HxDeclarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
PG-Lexical2[#HxDeclarations#, #ModuleName, #hasSkip, hasskip.#[hasskip]]
;

Lexical-alternatives:
PG-Lexical2[%rawHxDeclarations⟪ #HxSortAlternatives# ; #HxDeclarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
PG-Lexical2[#HxDeclarations#, #ModuleName, #hasSkip, hasskip.#[hasskip]]
;

Lexical-rule:
PG-Lexical2[%rawHxDeclarations⟪ rule #HxRule# ; #HxDeclarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
PG-Lexical2[#HxDeclarations#, #ModuleName, #hasSkip, hasskip.#[hasskip]]
;

Lexical-nest:
PG-Lexical2[%rawHxDeclarations⟪ { #HxDeclarations2# } #HxDeclarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
PG-Lexical2[#HxDeclarations2#, #ModuleName, #hasSkip, hasskip.PG-Lexical2[#HxDeclarations#, #ModuleName, hasskip, hasskip2.#[hasskip2]]]
;

Lexical-done:
PG-Lexical2[%rawHxDeclarations⟪ ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
#[#hasSkip]
;

// The final continuation.
PG-Lexical2Tail[Boolean] :: Text;
PG-Lexical2Tail[B_TRUE] → %n⟪⟫ ;
PG-Lexical2Tail[B_FALSE] → %n⟪skip ::= " " .
⟫ ;

// b. Inline Text of Regular Expression.

//

PG-InlineRegExp[$List[HxRegExpChoice], $String<!--ModuleName-->, $String<!--identifier-->] :: Text ;
PG-InlineRegExp[(#RegExpChoice; #RegExp), #ModuleName, #id]
→
%n⟪⟦« PG-InlineRegExpChoice[#RegExpChoice, #ModuleName, #id] »⟧ « PG-InlineRegExp2[#RegExp, #ModuleName, #id] »⟫
;

PG-InlineRegExp2[$List[HxRegExpChoice], $String<!--ModuleName-->, $String<!--identifier-->] :: Text ;
PG-InlineRegExp2[(#RegExpChoice; #RegExp), #ModuleName, #id]
→
%n⟪| ⟦« PG-InlineRegExpChoice[#RegExpChoice, #ModuleName, #id] »⟧ « PG-InlineRegExp2[#RegExp, #ModuleName, #id] »⟫
;
PG-InlineRegExp2[(), #ModuleName, #id]
→
%n⟪⟫
;

//

PG-InlineRegExpChoice[HxRegExpChoice, $String<!--ModuleName-->, $String] :: Text;

PG-InlineRegExpChoice[%rawHxRegExpChoice⟪ nested #HxRegExpSimple1# #HxRegExpSimple2# ⟫, #ModuleName, #id]
→
%n⟪NESTED_«PG-TokenNameText[#id]»⟫
;
PG-InlineRegExpChoice[%rawHxRegExpChoice⟪ #HxRegExpUnits# ⟫, #ModuleName, #id]
→
PG-InlineRegExpUnits[#HxRegExpUnits#, #ModuleName, #id]
;

//

PG-InlineRegExpUnits[$List[HxRegExpUnit], $String<!--ModuleName-->, $String] :: Text;

PG-InlineRegExpUnits[%rawHxRegExpUnits⟪ #HxRegExpUnit# #HxRegExpUnits# ⟫, #ModuleName, #id]
→
%n⟪« PG-InlineRegExpUnit[#HxRegExpUnit#, #ModuleName, #id] » « PG-InlineRegExpUnits[#HxRegExpUnits#, #ModuleName, #id] »⟫
;
PG-InlineRegExpUnits[%rawHxRegExpUnits⟪ ⟫, #ModuleName, #id]
→
%n⟪⟫
;

//

PG-InlineRegExpUnit[HxRegExpUnit, $String<!--ModuleName-->, $String] :: Text;

PG-InlineRegExpUnit[%rawHxRegExpUnit⟪ #HxRegExpSimple# ⟫, #ModuleName, #id]
→
PG-InlineRegExpSimple[#HxRegExpSimple#, #ModuleName, #id]
;

PG-InlineRegExpUnit[%rawHxRegExpUnit⟪ #HxRegExpSimple# ? ⟫, #ModuleName, #id]
→
%n⟪( « PG-InlineRegExpSimple[#HxRegExpSimple#, #ModuleName, #id] » )?⟫
;

PG-InlineRegExpUnit[%rawHxRegExpUnit⟪ #HxRegExpSimple# * ⟫, #ModuleName, #id]
→
%n⟪( « PG-InlineRegExpSimple[#HxRegExpSimple#, #ModuleName, #id] » )*⟫
;

PG-InlineRegExpUnit[%rawHxRegExpUnit⟪ #HxRegExpSimple# + ⟫, #ModuleName, #id]
→
%n⟪( « PG-InlineRegExpSimple[#HxRegExpSimple#, #ModuleName, #id] » )+⟫
;

PG-InlineRegExpUnit[%rawHxRegExpUnit⟪ #HxRegExpSimple# + _ #HxRegExpSub# ⟫, #ModuleName, #id]
→
%n⟪( « PG-InlineRegExpSimple[#HxRegExpSimple#, #ModuleName, #id] » ( « PG-InlineRegExpSimple[#HxRegExpSub#, #ModuleName, #id] » « PG-InlineRegExpSimple[#HxRegExpSimple#, #ModuleName, #id] » )* )⟫
;

//

PG-InlineRegExpSimple[HxRegExpSimple, $String<!--ModuleName-->, $String] :: Text;

PG-InlineRegExpSimple[%rawHxRegExpSimple⟪ #HxString# ⟫, #ModuleName, #id]
→
%n⟪†«#HxString#»⟫ // TODO: manually decode HACS and recode PG escapes (or at least check)!
;

PG-InlineRegExpSimple[%rawHxRegExpSimple⟪ #HxRegExpWord# ⟫, #ModuleName, #id]
→
%n⟪†« Stringify[#HxRegExpWord#] »⟫
;

PG-InlineRegExpSimple[%rawHxRegExpSimple⟪ #HxFragmentRef# ⟫, #ModuleName, #id]
→
%n⟪«PG-TokenNameText[#HxFragmentRef#]»⟫
;

PG-InlineRegExpSimple[%rawHxRegExpSimple⟪ . ⟫, #ModuleName, #id]
→
PG-InlineRegExpSimple[%rawHxRegExpSimple⟪ [^\n\r\f] ⟫, #ModuleName, #id]
;

PG-InlineRegExpSimple[%rawHxRegExpSimple⟪ #HxRegExpClass# ⟫, #ModuleName, #id]
→
PG-InlineRegExpClass1[#HxRegExpClass#, #ModuleName, #id]
;

PG-InlineRegExpSimple[%rawHxRegExpSimple⟪ ( #HxRegExp# ) ⟫, #ModuleName, #id]
→
%n⟪( « PG-InlineRegExp[#HxRegExp#, #ModuleName, #id] » )⟫
;

//

PG-InlineRegExpClass1[HxRegExpClass, $String<!--ModuleName-->, $String] :: Text;

PG-InlineRegExpClass1[RawHxRegExpClassNot[#RegExpClass], #ModuleName, #id]
→
%n⟪~[« PG-InlineRegExpClass2[#RegExpClass, #ModuleName, #id, %n⟨⟩] »]⟫
;

PG-InlineRegExpClass1[$[NotMatch,RawHxRegExpClassNot[#_],#RegExpClass], #ModuleName, #id]
→
%n⟪[« PG-InlineRegExpClass2[#RegExpClass, #ModuleName, #id, %n⟨⟩] »]⟫
;

PG-InlineRegExpClass2[HxRegExpClass, $String<!--ModuleName-->, $String, Text] :: Text;

PG-InlineRegExpClass2[RawHxRegExpClassChar[#Char, #RegExpClass], #ModuleName, #id, #sep]
→
%n⟪«#sep»« PG-InlineRegExpRangeChar[#Char, #ModuleName, #id] »« PG-InlineRegExpClass2[#RegExpClass, #ModuleName, #id, %n⟨,⟩] »⟫
;

PG-InlineRegExpClass2[RawHxRegExpClassRange[#lo, #hi, #RegExpClass], #ModuleName, #id, #sep]
→
%n⟪«#sep»« PG-InlineRegExpRangeChar[#lo, #ModuleName, #id] »-« PG-InlineRegExpRangeChar[#hi, #ModuleName, #id] »« PG-InlineRegExpClass2[#RegExpClass, #ModuleName, #id, %n⟨,⟩] »⟫
;

PG-InlineRegExpClass2[RawHxRegExpClassDone, #ModuleName, #id, #sep]
→
%n⟪⟫
;
PG-InlineRegExpRangeChar[$String, $String<!--ModuleName-->, $String] :: Text;
-[Data[#HxRegExpRangeStartChar#]]:
PG-InlineRegExpRangeChar[#HxRegExpRangeStartChar#, #ModuleName, #id]
→
$[If, $[Equal,#HxRegExpRangeStartChar#,"'"], %n⟪"'"⟫, %n⟪'†« #HxRegExpRangeStartChar# »'⟫]
;

//

PG-DeclareRegExp[$List[HxRegExpChoice], $String<!--ModuleName-->, $String<!--identifier-->] :: Text ;
PG-DeclareRegExp[(#RegExpChoice; #RegExp), #ModuleName, #id]
→
%n⟪« PG-DeclareRegExpChoice[#RegExpChoice, #ModuleName, #id] »« PG-DeclareRegExp[#RegExp, #ModuleName, #id] »⟫
;
PG-DeclareRegExp[(), #ModuleName, #id]
→
%n⟪⟫
;

PG-DeclareRegExpChoice[HxRegExpChoice, $String<!--ModuleName-->, $String] :: Text;
PG-DeclareRegExpChoice[%rawHxRegExpChoice⟪ nested #HxRegExpSimple1# #HxRegExpSimple2# ⟫, #ModuleName, #id]
→
%n⟪
%{
/* token †«#id». */
MORE : { < « PG-InlineRegExpSimple[#HxRegExpSimple1#, #ModuleName, #id] » > { nesting = 0; nestedState = curLexState; } : IN_«PG-TokenNameText[#id]» }
<IN_«PG-TokenNameText[#id]»> MORE : { < « PG-InlineRegExpSimple[#HxRegExpSimple1#, #ModuleName, #id] » > { nesting = 1; } : IN_NESTED_«PG-TokenNameText[#id]» }
<IN_NESTED_«PG-TokenNameText[#id]»> MORE : { < « PG-InlineRegExpSimple[#HxRegExpSimple1#, #ModuleName, #id] » > { nesting++; } }
<IN_NESTED_«PG-TokenNameText[#id]»> MORE : { < « PG-InlineRegExpSimple[#HxRegExpSimple2#, #ModuleName, #id] » > { if (--nesting <= 0) SwitchTo(IN_«PG-TokenNameText[#id]»); } }
<IN_«PG-TokenNameText[#id]»> †« $[If,$[Equal,#id,"space$"],"SKIP","TOKEN"] » : { < T_NESTED_«PG-TokenNameText[#id]» : « PG-InlineRegExpSimple[#HxRegExpSimple2#, #ModuleName, #id] » > { SwitchTo(nestedState); } }
<IN_«PG-TokenNameText[#id]»,IN_NESTED_«PG-TokenNameText[#id]»> MORE : { < ~[] > }
%}
⟫
;
PG-DeclareRegExpChoice[%rawHxRegExpChoice⟪ #HxRegExpUnits# ⟫, #ModuleName, #id]
→
PG-DeclareRegExpUnits[#HxRegExpUnits#, #ModuleName, #id]
;

PG-DeclareRegExpUnits[$List[HxRegExpUnit], $String<!--ModuleName-->, $String] :: Text;
PG-DeclareRegExpUnits[%rawHxRegExpUnits⟪ #HxRegExpUnit# #HxRegExpUnits# ⟫, #ModuleName, #id]
→
%n⟪« PG-DeclareRegExpUnit[#HxRegExpUnit#, #ModuleName, #id] »« PG-DeclareRegExpUnits[#HxRegExpUnits#, #ModuleName, #id] »⟫
;
PG-DeclareRegExpUnits[%rawHxRegExpUnits⟪ ⟫, #ModuleName, #id]
→
%n⟪⟫
;

PG-DeclareRegExpUnit[HxRegExpUnit, $String<!--ModuleName-->, $String] :: Text;
PG-DeclareRegExpUnit[%rawHxRegExpUnit⟪ #HxRegExpSimple# ⟫, #ModuleName, #id] → PG-DeclareRegExpSimple[#HxRegExpSimple#, #ModuleName, #id] ;
PG-DeclareRegExpUnit[%rawHxRegExpUnit⟪ #HxRegExpSimple# ? ⟫, #ModuleName, #id] → PG-DeclareRegExpSimple[#HxRegExpSimple#, #ModuleName, #id] ;
PG-DeclareRegExpUnit[%rawHxRegExpUnit⟪ #HxRegExpSimple# * ⟫, #ModuleName, #id] → PG-DeclareRegExpSimple[#HxRegExpSimple#, #ModuleName, #id] ;
PG-DeclareRegExpUnit[%rawHxRegExpUnit⟪ #HxRegExpSimple# + ⟫, #ModuleName, #id] → PG-DeclareRegExpSimple[#HxRegExpSimple#, #ModuleName, #id] ;
PG-DeclareRegExpUnit[%rawHxRegExpUnit⟪ #HxRegExpSimple# + _ #HxRegExpSub# ⟫, #ModuleName, #id] → %n⟪« PG-DeclareRegExpSimple[#HxRegExpSimple#, #ModuleName, #id] »« PG-DeclareRegExpSimple[#HxRegExpSub#, #ModuleName, #id] »⟫ ;

PG-DeclareRegExpSimple[HxRegExpSimple, $String<!--ModuleName-->, $String] :: Text;
PG-DeclareRegExpSimple[%rawHxRegExpSimple⟪ #HxString# ⟫, #ModuleName, #id] → %n⟪⟫ ;
PG-DeclareRegExpSimple[%rawHxRegExpSimple⟪ #HxFragmentRef# ⟫, #ModuleName, #id] → %n⟪⟫ ;
PG-DeclareRegExpSimple[%rawHxRegExpSimple⟪ . ⟫, #ModuleName, #id] → %n⟪⟫ ;
PG-DeclareRegExpSimple[%rawHxRegExpSimple⟪ #HxRegExpClass# ⟫, #ModuleName, #id] → %n⟪⟫ ;
PG-DeclareRegExpSimple[%rawHxRegExpSimple⟪ ( #HxRegExp# ) ⟫, #ModuleName, #id] → PG-DeclareRegExp[#HxRegExp#, #ModuleName, #id] ;
PG-DeclareRegExpSimple[%rawHxRegExpSimple⟪ #HxRegExpWord# ⟫, #ModuleName, #id] → %n⟪⟫ ;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// . PG TEXT NAMING CONVENTIONS.

// PG token name and constructor.

PG-TokenNameText[$String] :: Text;
-[Data[#Name]]: PG-TokenNameText[#Name] → %n⟪†«#Name»⟫ ;

PG-TokenConstructorText[$String<!--ModuleName-->, $String] :: Text;
PG-TokenConstructorText[#ModuleName, #Name] → %n⟪†« PG-QN[#ModuleName, "Token", #Name] »⟫ ;

// PG production (= non-terminal = sort) name and constructor.

PG-ProductionNameText[$String] :: Text;
-[Data[#Name]]: PG-ProductionNameText[#Name] → %n⟪†« #Name »⟫ ;

// PG special production name for non-terminals with precedence.

PG-ProductionNameWithPrecText[$String, $Numeric] :: Text;
-[Data[#Name,#Prec],Copy[#Name,#Prec]]: PG-ProductionNameWithPrecText[#Name, #Prec] → PG-ProductionNameText[$[If, $[NumericEqual,#Prec,0], #Name, $[:,#Name,$[FormatNumber,#Prec]]]] ;

PG-ProductionNameWithPrec[$String, $Numeric] :: $String;
-[Data[#Name,#Prec],Copy[#Name,#Prec]]: PG-ProductionNameWithPrec[#Name, #Prec] → $[If, $[NumericEqual,#Prec,0], #Name, $[:,#Name,$[FormatNumber,#Prec]]] ;

// PG special production name for non-terminals with precedence and repeat...

PG-ProductionNameWithPrecRepeatText[$String, $Numeric, HxRepeat] :: Text;
PG-ProductionNameWithPrecRepeatText[#Name, #Prec, %rawHxRepeat⟪ ⟫] → PG-ProductionNameWithPrecText[#Name, #Prec] ;
PG-ProductionNameWithPrecRepeatText[#Name, #Prec, %rawHxRepeat⟪ ? ⟫]→ %n⟪« PG-ProductionNameWithPrecText[#Name, #Prec] »_Maybe⟫ ;
PG-ProductionNameWithPrecRepeatText[#Name, #Prec, %rawHxRepeat⟪ * ⟫]→ %n⟪« PG-ProductionNameWithPrecText[#Name, #Prec] »_MaybeSome⟫ ;
-[Data[#HxRegExpSimple#]]:
PG-ProductionNameWithPrecRepeatText[#Name, #Prec, %rawHxRepeat⟪ + ⟫]→ %n⟪« PG-ProductionNameWithPrecText[#Name, #Prec] »_Some⟫ ;
-[Data[#HxRegExpSub#]]:
PG-ProductionNameWithPrecRepeatText[#Name, #Prec, %rawHxRepeat⟪ + _ #HxRegExpSub# ⟫]→ %n⟪« PG-ProductionNameWithPrecText[#Name, #Prec] »« PG-RegExpSubNameText["", #HxRegExpSub#] »⟫ ;

    // Convert regular expression to name fragment...
    PG-RegExpSubNameText[$String, HxRegExpSimple] :: Text;
    -[Data[#Name,#HxString#]]:      PG-RegExpSubNameText[#Name, %rawHxRegExpSub⟪ #HxString# ⟫] → %n⟪†«#Name»_SomeS†« $[Mangle,#HxString#] »⟫ ;
    -[Data[#Name,#HxSeparator#]]:        PG-RegExpSubNameText[#Name, %rawHxRegExpSub⟪ #HxSeparator# ⟫] → %n⟪†«#Name»_SomeW†« $[Mangle,#HxSeparator#] »⟫ ;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// . JJ HELPERS.


JJ-Construction[#Constructor, #Content]
→
%n⟪{sink = sink.start(makeTConstructor(sink, null, «#Constructor», null));}
«#Content»{sink = sink.end();}
⟫;

JJ-StringLiteral[#Literal]
→
%n⟪{sink = sink.start(makeTConstructor(sink, null, «#Literal», net.sf.crsx.CRS.STRING_SORT)).end();}
⟫;

JJ-Token[#TokenName]
→
%n⟪<T_« #TokenName »>
⟫
;

JJ-Nonterminal[#NonTerminal, env.#[env]]
→
%n⟪sink=N_« #NonTerminal »(sink, « #[%n⟨env⟩] »)
⟫
;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// . OTHER HELPERS.

// Convert hx module name string to Java style class name.

PG-ClassName[$String] :: $String;
-[Data[#Name]]: PG-ClassName[#Name] → $[Replace, $[Replace, #Name, "/","."], "\"", ""] ;

// Convert hx module name to lower case prefix.

PG-Prefix[$String] :: $String;
-[Data[#Name]]: PG-Prefix[#Name] → $[If, $[Contains,#Name,"."], PG-Prefix[$[AfterFirst,#Name,"."]], $[Replace,$[DownCase,#Name],"\"",""]] ;

PG-Embed-Prefix[$String] :: $String;
PG-Embed-Prefix[#ModuleName] → StringConcat[PG-Prefix[#ModuleName], "Embed_"] ;

PG-Meta-Prefix[$String] :: $String;
PG-Meta-Prefix[#ModuleName] → StringConcat[PG-Prefix[#ModuleName], "Meta_"] ;

PG-User-Prefix[$String] :: $String;
PG-User-Prefix[#ModuleName] → StringConcat[PG-Prefix[#ModuleName], "_"] ;

PG-user[#ModuleName, #Name] → StringConcat3[PG-LastName[#ModuleName], "_", #Name] ;

// Extract last component of module name.

PG-LastName[$String] :: $String;
-[Data[#Name]]: PG-LastName[#Name]  → $[If, $[Contains,#Name,"."], PG-LastName[$[AfterFirst,#Name,"."]], $[Replace,#Name,"\"",""]] ;
// TODO: Sanity check that it is a capitalized word!

// Create qualified name.

PG-QN[$String<!--ModuleName-->, $String<!--Kind-->, $String<!--LocalName-->] :: $String ;
PG-QN[#ModuleName, #Kind, #Name] → PG-QN2[PG-LastName[#ModuleName], #Kind, #Name] ;
-[Data[#ModuleBase,#Kind,#Name]]: PG-QN2[#ModuleBase, #Kind, #Name] → $[If, $[Contains,#Name,'$'], $[:,#Kind,'_',#Name], $[:,#ModuleBase,'$',#Kind,'_',#Name]] ;

// Local name.

PG-LN[$String<!--BaseName-->, $String<!--Type-->] :: $String ;
-[Data[#BaseName,#Kind]] : PG-LN[#BaseName, #Kind] → $[:,#BaseName,'_',#Kind] ;

// Generate sort name for sort with repetition.

PG-SortNameWithRepeat[HxSort, HxRepeat] :: $String;
PG-SortNameWithRepeat[#Sort, #Repeat] → PG-SortNameWithRepeat1[PG-SortName[#Sort], #Repeat] ;
PG-SortNameWithRepeat1[$String, HxRepeat] :: $String;
-[Data[#FullSortName]] : PG-SortNameWithRepeat1[#FullSortName, #Repeat] → If[SameString["", #FullSortName], "", PG-SortNameWithRepeat2[#FullSortName, #Repeat]] ;
PG-SortNameWithRepeat2[$String, HxRepeat] :: $String;
PG-SortNameWithRepeat2[#FullSortName, %rawHxRepeat⟪ ⟫] → #FullSortName ;
PG-SortNameWithRepeat2[#FullSortName, %rawHxRepeat⟪ ? ⟫] → $[:,#FullSortName,"_Maybe"] ;
PG-SortNameWithRepeat2[#FullSortName, %rawHxRepeat⟪ * ⟫] → $[:,#FullSortName,"_MaybeSome"] ;
PG-SortNameWithRepeat2[#FullSortName, %rawHxRepeat⟪ + ⟫] → $[:,#FullSortName,"_Some"] ;
PG-SortNameWithRepeat2[#FullSortName, %rawHxRepeat⟪ + _ #HxRegExpSub# ⟫] → RegExpSubSuffix[#HxRegExpSub#, $[:,#FullSortName,"_Some_"]] ;

// Extract sort name from sort.

PG-SortName[HxSort] :: $String;
-[Data[#Sort]]: PG-SortName[#Sort] → PG-SortName2[#Sort] ;

PG-SortName2[HxSort] :: $String;
PG-SortName2[           %rawHxSort⟪ #HxSortName# #HxMetaVariables# #HxSimpleSorts# ⟫] → #HxSortName# ;
PG-SortName2[$[NotMatch,%rawHxSort⟪ #HxSortName# #HxMetaVariables# #HxSimpleSorts# ⟫,#]] →  $[Show,#] ;

PG-BaseSortName[HxSort] :: $String;
-[Data[#Sort]]: PG-BaseSortName[#Sort] → PG-BaseSortName2[#Sort] ;
PG-BaseSortName2[HxSort] :: $String;
PG-BaseSortName2[           %rawHxSort⟪ #HxSortName# #HxMetaVariables# #HxSimpleSorts# ⟫] → #HxSortName# ;
PG-BaseSortName2[$[NotMatch,%rawHxSort⟪ #HxSortName# #HxMetaVariables# #HxSimpleSorts# ⟫,#]] →  "BAD" ;

// Extract inherited map attribute names (from all schemes).

{$String : DeclarationMapEntry} PG-MakeInheritedNames :: NameSet ;
{#DM} PG-MakeInheritedNames → FoldWhen[ok k ns.{#DM} KeepInheritedEntry[ok, k, ns], $[{#DM}Keys[$String]], NoNames] ;

    {$String : DeclarationMapEntry} KeepInheritedEntry[Ok, $String, NameSet] :: NameSet;
    {#DM} KeepInheritedEntry[OK, #name, #synthesized] → KeepInheritedEntry1[$[{#DM}Get[DeclarationMapEntry], #name, DME_NONE], #synthesized] ;

    KeepInheritedEntry1[DeclarationMapEntry, NameSet] :: NameSet;
    -[Data[#entry]]:
    KeepInheritedEntry1[#entry, #synthesized] → KeepInheritedEntry2[#entry, #synthesized] ;

    KeepInheritedEntry2[DeclarationMapEntry, NameSet] :: NameSet;
    KeepInheritedEntry2[DME_ATTRIBUTE[%rawHxAttributeKind⟪ ↓ ⟫, #name, #form, #options], #synthesized] → AddName[#synthesized, #name] ;
    KeepInheritedEntry2[$[NotMatch,DME_ATTRIBUTE[%rawHxAttributeKind⟪ ↓ ⟫, #name, #form, #options], #_], #synthesized] → #synthesized ;

{$String : DeclarationMapEntry} PG-MakeInheritedMapNames :: NameSet ;
{#DM} PG-MakeInheritedMapNames → FoldWhen[ok k ns.{#DM} KeepInheritedMapEntry[ok, k, ns], $[{#DM}Keys[$String]], NoNames] ;

    {$String : DeclarationMapEntry} KeepInheritedMapEntry[Ok, $String, NameSet] :: NameSet;
    {#DM} KeepInheritedMapEntry[OK, #name, #inheritedmaps] → KeepInheritedMapEntry1[$[{#DM}Get[DeclarationMapEntry], #name, DME_NONE], #inheritedmaps] ;

    KeepInheritedMapEntry1[DeclarationMapEntry, NameSet] :: NameSet;
    -[Data[#entry]]:
    KeepInheritedMapEntry1[#entry, #inheritedmaps] → KeepInheritedMapEntry2[#entry, #inheritedmaps] ;

    KeepInheritedMapEntry2[DeclarationMapEntry, NameSet] :: NameSet;
    KeepInheritedMapEntry2[DME_ATTRIBUTE[%rawHxAttributeKind⟪ ↓ ⟫, #name, %rawHxAttributeForm⟪ { #HxSort1# : #HxSort2# } ⟫, #options], #inheritedmaps] → AddName[#inheritedmaps, #name] ;
    KeepInheritedMapEntry2[$[NotMatch,DME_ATTRIBUTE[%rawHxAttributeKind⟪ ↓ ⟫, #name, %rawHxAttributeForm⟪ { #HxSort1# : #HxSort2# } ⟫, #options], #_], #inheritedmaps] → #inheritedmaps ;

{$String : DeclarationMapEntry} PG-MakeSynthesizedNames :: NameSet ;
{#DM} PG-MakeSynthesizedNames → FoldWhen[ok k ns.{#DM} KeepSynthesizedEntry[ok, k, ns], $[{#DM}Keys[$String]], NoNames] ;

    {$String : DeclarationMapEntry} KeepSynthesizedEntry[Ok, $String, NameSet] :: NameSet;
    {#DM} KeepSynthesizedEntry[OK, #name, #synthesized] → KeepSynthesizedEntry1[$[{#DM}Get[DeclarationMapEntry], #name, DME_NONE], #synthesized] ;

    KeepSynthesizedEntry1[DeclarationMapEntry, NameSet] :: NameSet;
    -[Data[#entry]]:
    KeepSynthesizedEntry1[#entry, #synthesized] → KeepSynthesizedEntry2[#entry, #synthesized] ;

    KeepSynthesizedEntry2[DeclarationMapEntry, NameSet] :: NameSet;
    KeepSynthesizedEntry2[DME_ATTRIBUTE[%rawHxAttributeKind⟪ ↑ ⟫, #name, #form, #options], #synthesized] → AddName[#synthesized, #name] ;
    KeepSynthesizedEntry2[$[NotMatch,DME_ATTRIBUTE[%rawHxAttributeKind⟪ ↑ ⟫, #name, #form, #options], #_], #synthesized] → #synthesized ;

{$String : DeclarationMapEntry} PG-MakeSynthesizedMapNames :: NameSet ;
{#DM} PG-MakeSynthesizedMapNames → FoldWhen[ok k ns.{#DM} KeepSynthesizedMapEntry[ok, k, ns], $[{#DM}Keys], NoNames] ;

    {$String : DeclarationMapEntry} KeepSynthesizedMapEntry[Ok, $String, NameSet] :: NameSet;
    {#DM} KeepSynthesizedMapEntry[OK, #name, #synthesizedmaps] → KeepSynthesizedMapEntry1[$[{#DM}Get[DeclarationMapEntry], #name, DME_NONE], #synthesizedmaps] ;

    KeepSynthesizedMapEntry1[DeclarationMapEntry, NameSet] :: NameSet;
    -[Data[#entry]]:
    KeepSynthesizedMapEntry1[#entry, #synthesizedmaps] → KeepSynthesizedMapEntry2[#entry, #synthesizedmaps] ;

    KeepSynthesizedMapEntry2[DeclarationMapEntry, NameSet] :: NameSet;
    KeepSynthesizedMapEntry2[DME_ATTRIBUTE[%rawHxAttributeKind⟪ ↑ ⟫, #name, %rawHxAttributeForm⟪ { #HxSort1# : #HxSort2# } ⟫, #options], #synthesizedmaps] → AddName[#synthesizedmaps, #name] ;
    KeepSynthesizedMapEntry2[$[NotMatch,DME_ATTRIBUTE[%rawHxAttributeKind⟪ ↑ ⟫, #name, %rawHxAttributeForm⟪ { #HxSort1# : #HxSort2# } ⟫, #options], #_], #synthesizedmaps] → #synthesizedmaps ;


// Errors.

∀ a . PrepError[$String] :: a;
-[Data[#message]]: PrepError[#message] → $[Error, #message] ;


)] //PG


/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// // PG-ProductionNames: Extract top level productions.
/// //
/// // Only include productions for tokens and sorts that have syntax.
///
/// {$String<!--SortName--> : DeclarationMapEntry} PG-ProductionNames[$List[$String]] :: $List[$String];
/// {#DM}PG-ProductionNames[()] → () ;
/// {#DM}PG-ProductionNames[(#1;#s)] → {#DM}PG-ProductionNames2[$[{#DM}Get[DeclarationMapEntry],#1,DME_NONE], #1, #s] ;
///
/// {$String<!--SortName--> : DeclarationMapEntry} PG-ProductionNames2[DeclarationMapEntry, $String, $List[$String]] :: $List[$String];
/// {#DM}PG-ProductionNames2[DME_NONE, #1, #s] → {#DM}PG-ProductionNames[#s] ;
/// {#DM}PG-ProductionNames2[DME_TOKEN[#SortName], #1, #s] → (#1 ; {#DM}PG-ProductionNames[#s]) ;
/// {#DM}PG-ProductionNames2[DME_ATTRIBUTE[#Kind, #Name, #AttributeForm, #AttributeOptions], #1, #s] → {#DM}PG-ProductionNames[#s] ;
/// {#DM}PG-ProductionNames2[DME_SORT[#Defines, #SortName, #Precs, #Wrapper], #1, #s] → {#DM}PG-ProductionNames3[#Defines, #1, #s] ;
///
/// {$String<!--SortName--> : DeclarationMapEntry} PG-ProductionNames3[$List[Define], $String, $List[$String]] :: $List[$String];
/// -[Fresh[dummy::HxSortParam]]:
/// {#DM} PG-ProductionNames3[(D_ABSTRACTION[a.#Define1[a]]; #Defines), #1, #s] → {#DM} PG-ProductionNames3[(#Define1[dummy]; #Defines), #1, #s] ;
/// {#DM} PG-ProductionNames3[(D_RULE[#Rule, #RuleSort, #IsData]; #Defines), #1, #s] → {#DM} PG-ProductionNames3[#Defines, #1, #s] ;
/// {#DM} PG-ProductionNames3[(D_FORM[#Form1, #Kind1]; #Defines), #1, #s] → {#DM} PG-ProductionNames4[#Form1, #Defines, #1, #s] ;
/// {#DM} PG-ProductionNames3[(D_NONE; #Defines), #1, #s] → {#DM} PG-ProductionNames3[#Defines, #1, #s] ;
/// {#DM} PG-ProductionNames3[(), #1, #s] → {#DM}PG-ProductionNames[#s] ;
///
/// {$String<!--SortName--> : DeclarationMapEntry} PG-ProductionNames4[HxForm, $List[Define], $String, $List[$String]] :: $List[$String];
/// {#DM} PG-ProductionNames4[RawHxFormParsedSorted[#Sort1, #ParsedForm1, #Prec1, #InheritedRefs], #Defines, #1, #s] → (#1; {#DM}PG-ProductionNames[#s]) ;
/// {#DM} PG-ProductionNames4[RawHxFormParsed[#ParsedForm1, #Prec1, #InheritedRefs], #Defines, #1, #s] → (#1; {#DM}PG-ProductionNames[#s]) ;
/// {#DM} PG-ProductionNames4[RawHxFormConstruction[#Constructor, #ScopeSortList, #InheritedRefs], #Defines, #1, #s] → {#DM} PG-ProductionNames3[#Defines, #1, #s] ;
///
///
///
///
///
///
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// // TEXT LIST OF REPEAT-DERIVED DECLARATIONS.
///
/// PG-ProduceDerived[DERIVED_SORT] :: TextMapSort;
/// PG-ProduceDerived[DERIVED[#SortName, #Prec, #Repeat]] → PG-ProduceRepeat[#Repeat, #SortName, #Prec, PG-ProductionNameWithPrecRepeatText[#SortName, #Prec, #Repeat]] ;
///
/// PG-ProduceRepeat[HxRepeat, $String, $Numeric, Text] :: TextMapSort;
///
/// PG-ProduceRepeat[%rawHxRepeat⟪ ⟫, #s, #p, #name] → EmptyTextMap ;
///
/// -[Data[#s]]:
/// PG-ProduceRepeat[%rawHxRepeat⟪ ? ⟫, #s, #p, #name]
/// →
/// SingletonTextMap[TextToString[#name], %n⟪
/// <«#name»> ::= «
///   PG-Head[B_TRUE, #ModuleName, $[:,#s,"?"], TextToString[#name], B_FALSE, 0]
/// »( <«PG-ProductionNameWithPrecText[#s, #p]»>:#1 {{ $Cons[#1,$Nil] }} | {{ $Nil }} ).
/// « PG-Embed-Tail[B_TRUE, $[:,#s,"?"], TextToString[#name]] »⟫]
/// ;
///
/// -[Data[#s]]:
/// PG-ProduceRepeat[%rawHxRepeat⟪ * ⟫, #s, #p, #name]
/// →
/// SingletonTextMap[TextToString[#name], %n⟪
/// <«#name»> ::= «
///   PG-Head[B_TRUE, #ModuleName, $[:,#s,"*"], TextToString[#name], B_FALSE, 0]
/// »( <«PG-ProductionNameWithPrecText[#s, #p]»>:#1 <«#name»>:#2 {{ $Cons[#1,#2] }} | {{ $Nil }} ).
/// « PG-Embed-Tail[B_TRUE, $[:,#s,"*"], TextToString[#name]] »⟫]
/// ;
///
/// -[Data[#s]]:
/// PG-ProduceRepeat[%rawHxRepeat⟪ + ⟫, #s, #p, #name]
/// →
/// SingletonTextMap[TextToString[#name], %n⟪
/// <«#name»> ::= «
///   PG-Head[B_TRUE, #ModuleName, $[:,#s,"+"], TextToString[#name], B_FALSE, 0]
/// » <«PG-ProductionNameWithPrecText[#s, #p]»>:#1 ( <«#name»>:#2 {{ $Cons[#1,#2] }} | {{ $Cons[#1,$Nil] }} ) .
/// « PG-Embed-Tail[B_TRUE, $[:,#s,"+"], TextToString[#name]] »⟫]
/// ;
///
/// -[Data[#s]]:
/// PG-ProduceRepeat[%rawHxRepeat⟪ + _ #HxRegExpSub# ⟫, #s, #p, #name]
/// →
/// SingletonTextMap[TextToString[#name], %n⟪
/// <«#name»> ::= «
///   PG-Head[B_TRUE, #ModuleName, RegExpSubSuffix[#HxRegExpSub#, $[:,#s,"+_"]], TextToString[#name], B_FALSE, 0]
/// » <«PG-ProductionNameWithPrecText[#s, #p]»>:#1 ( « PG-InlineRegExpSimple[#HxRegExpSub#, ""] » <«#name»>:#2 {{ $Cons[#1,#2] }} | {{ $Cons[#1,$Nil] }} ) .
/// « PG-Embed-Tail[B_TRUE, RegExpSubSuffix[#HxRegExpSub#, $[:,#s,"+_"]], TextToString[#name]] »⟫]
/// ;
///
///
///
///
///
///
///
///
///
///
///
///
///
///
///
///
///
///
///
///
///
///
///
///
///
///
///
///
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///
/// // PrepBase.crs: CRSX3 SUPPORT LIBRARY FOR HACS PREPROCESSOR OPERATIONS.
/// //
/// // Declarations here depend only on the Prelude and the Hx syntax.
/// //
/// PrepBase[(
///
/// $Use["org/crsx/hacs/Prelude.crs"];
///
/// // Syntax and sorts of hx terms (%rawHx...⟪...⟫).
/// $Use["org/crsx/hacs/Hx.crs"];
///
/// // Syntax and sorts of text (%n⟪...⟫).
/// $CheckGrammar["net.sf.crsx.text.Text"];
/// $Use["net/sf/crsx/text/Text.crs"];
///
/// $Lax;
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// // LOCATION EXTRACTION.
///
/// $StringEntrySort ::=( STRING[$String]; );
///
/// {$String : $StringEntrySort}MakeLocation :: $String;
/// {#L}MakeLocation → MakeLocation2[$[{#L}Get[$StringEntrySort],"$FileLocation",STRING[""]], $[{#L}Get[$StringEntrySort],"$LineLocation",STRING[""]], $[{#L}Get[$StringEntrySort],"$ColumnLocation",STRING[""]]] ;
/// MakeLocation2[$StringEntrySort, $StringEntrySort, $StringEntrySort] :: $String;
/// MakeLocation2[STRING[#file], STRING[#line], STRING[#column]] → $[:,#file," ",#line,":",#column] ;
///
///
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// // SORT EXTRACTION.
///
/// ScopePG-SortName[HxScopeSort] :: $String;
/// ScopePG-SortName[%rawHxScopeSort⟪ #HxSort# #HxRepeat# [ #HxSubstituteSorts# ] ⟫] → SortNameWithRepeat[#HxSort#, #HxRepeat#] ;
/// -[Free[v::Text]]:
/// ScopePG-SortName[%rawHxScopeSort⟪ [ v : #HxSort# ] ⟫                  ] → PG-SortName[#HxSort#] ;
/// -[Free[v::Text]]:
/// ScopePG-SortName[%rawHxBindersScopeSort⟪ [ v : #HxSort# ] #HxBindersScopeSort# ⟫] → ScopePG-SortName[#HxBindersScopeSort#] ;
///
/// ScopeSortMetaVar[HxScopeSort, $Numeric] :: $String;
/// -[Discard[#HxSubstituteSorts#]]: ScopeSortMetaVar[%rawHxScopeSort⟪ #HxSort# [ #HxSubstituteSorts# ] ⟫, #n] → SortMetaVar[#HxSort#, #n] ;
/// -[Free[v::Text]]: ScopeSortMetaVar[%rawHxScopeSort⟪ [ v : #HxSort# ] ⟫                  , #n] → SortMetaVar[#HxSort#, #n] ;
///

///
///
///
///
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// // PRODUCTION NAMES.
///
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// // ERRORS.
///
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///
///
///
///
///
///
///
///
///


///
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// // COMPARISON OF FORMS.
///
///
///
///
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// // Extract all repeat-derived sort forms from DM structure.
///
/// DERIVED_SORT ::=( DERIVED[$String, $Numeric<!--Precedence-->, HxRepeat]; );
///
/// {$String<!--SortName--> : DeclarationMapEntry} DerivedSorts[NameSet] :: $List[DERIVED_SORT];
/// {#DM} DerivedSorts[#Names] → FoldNamesWhen[ok x y.{#DM} Then-DerivedSorts2[ok, x, y], #Names, ()] ;
///
/// {$String<!--SortName--> : DeclarationMapEntry} Then-DerivedSorts2[Ok, $String, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// {#DM} Then-DerivedSorts2[OK, #name, #derived] → DerivedSorts2[$[{#DM}Get[DeclarationMapEntry], #name, DME_NONE], #derived];
///
/// DerivedSorts2[DeclarationMapEntry, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
///
/// DerivedSorts2[DME_NONE, #derived] → #derived ;
/// DerivedSorts2[DME_TOKEN[#name], #derived] → #derived ;
/// DerivedSorts2[DME_ATTRIBUTE[#kind, #name, #form, #options], #derived] → #derived ;
///
/// DerivedSorts2[DME_SORT[#Defines, #Name, #Precs, #Wrapper], #derived]
/// →
/// FoldWhen[ok defined derived.Then-DerivedSorts-Defines[ok, defined, derived], #Defines, #derived]
/// ;
///
/// Then-DerivedSorts-Defines[Ok, Define, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// -[Fresh[dummy::HxSortParam]]: Then-DerivedSorts-Defines[OK, D_ABSTRACTION[a . #Define[a]], #derived] → Then-DerivedSorts-Defines[OK, #Define[dummy], #derived] ;
/// Then-DerivedSorts-Defines[OK, D_FORM[#Form, #Kind], #derived] → DerivedSorts-Form[#Form, #derived] ;
/// Then-DerivedSorts-Defines[OK, D_RULE[#Rule, #SortName, #IsDataEquivalence], #derived] → DerivedSorts-Rule[#Rule, #derived] ;
/// Then-DerivedSorts-Defines[OK, D_SYNTHESIZES[#AttributeName], #derived] → #derived ;
/// Then-DerivedSorts-Defines[OK, D_NONE, #derived] → #derived ;
///
/// DerivedSorts-Form[HxForm, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-Form[RawHxFormParsedSorted[#HxSort#, #HxParsedForm#, #HxPrec#, #InheritedRefs], #derived] → DerivedSorts-ParsedForm[#HxParsedForm#, #derived] ;
/// DerivedSorts-Form[RawHxFormParsed[#HxParsedForm#, #HxPrec#, #InheritedRefs], #derived] → DerivedSorts-ParsedForm[#HxParsedForm#, #derived] ;
/// DerivedSorts-Form[RawHxFormConstruction[#HxConstructor#, #HxScopeSorts#, #InheritedRefs], #derived] → #derived ;
///
/// DerivedSorts-ParsedForm[HxParsedForm, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-ParsedForm[RawHxParsedFormWord[#Word, #ParsedForm], #derived] → DerivedSorts-ParsedForm[#ParsedForm, #derived] ;
/// DerivedSorts-ParsedForm[RawHxParsedFormSpace[#Space, #ParsedForm], #derived] → DerivedSorts-ParsedForm[#ParsedForm, #derived] ;
/// DerivedSorts-ParsedForm[RawHxParsedFormDone, #derived] → #derived ;
/// DerivedSorts-ParsedForm[RawHxParsedFormTerm[RawHxScopeSortPrecRepeat[#ScopeSort, #Precedence, #Repeat], #ParsedForm], #derived]
/// →
/// DerivedSorts-ScopeSort[#ScopeSort, #Precedence, #Repeat, DerivedSorts-ParsedForm[#ParsedForm, #derived]]
/// ;
///
/// DerivedSorts-ScopeSort[HxScopeSort, $Numeric, HxRepeat, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-ScopeSort[%rawHxScopeSort⟪ #HxSort# #HxRepeat# [ #HxSubstituteSorts1# ] ⟫, #Precedence, #Repeat, #derived] → DerivedSorts-Sort[#HxSort#, #Precedence, NestedRepeat[#HxRepeat#, #Repeat], #derived] ;
/// -[Free[v::Text]]:
/// DerivedSorts-ScopeSort[%rawHxScopeSort⟪ [ v : #HxSort# ] ⟫, #Precedence, #Repeat, #derived] → #derived ;
///
/// DerivedSorts-Sort[HxSort, $Numeric, HxRepeat, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// -[Data[#Repeat]]:
/// DerivedSorts-Sort[#Sort, #Precedence, #Repeat, #derived] → DerivedSorts-Sort2[#Repeat, #Precedence, PG-BaseSortName[#Sort], #derived] ;
///
/// DerivedSorts-Sort2[HxRepeat, $Numeric, $String, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-Sort2[%rawHxRepeat⟪ ⟫, #Precedence, #Name, #derived] → #derived ;
/// -[Data[#Repeat,#Name]]:
/// DerivedSorts-Sort2[$[NotMatch,%rawHxRepeat⟪ ⟫,#Repeat], #Precedence, #Name, #derived]
/// →
/// $[IfEmpty, #Name, #derived, (DERIVED[#Name, #Precedence, #Repeat] ; #derived)]
/// ;
///
/// DerivedSorts-Rule[HxRule, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-Rule[%rawHxRule⟪ #HxPriority# #HxConstruction# : #HxConstruction_Pattern# → #HxTerm_Contraction# ⟫, #derived]
/// →
/// DerivedSorts-Term[#HxConstruction_Pattern#, DerivedSorts-Term[#HxTerm_Contraction#, #derived]]
/// ;
///
/// DerivedSorts-Term[HxTerm, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
///
/// DerivedSorts-Term[RawHxOMITTED, #derived] → #derived ;
///
/// -[Free[v::Text]]:
/// DerivedSorts-Term[%rawHxTerm⟪ v #HxAttributes# ⟫, #derived] → DerivedSorts-Attributes[#HxAttributes#, #derived] ;
///
/// -[Free[v::Text]]:
/// DerivedSorts-Term[%rawHxTerm⟪ #HxConstructor# #HxRepeat# v #HxAttributes# ⟫, #derived]
/// →
/// DerivedSorts-Repeat[#HxConstructor#, #HxRepeat#, DerivedSorts-Attributes[#HxAttributes#, #derived]] ;
///
/// DerivedSorts-Term[%rawHxTerm⟪ #HxLiteral# #HxAttributes# ⟫, #derived] → DerivedSorts-Attributes[#HxAttributes#, #derived] ;
///
/// DerivedSorts-Term[RawHxUnparsed[#Unparsed, #Attributes], #derived] → #derived ;
/// DerivedSorts-Term[RawHxUnparsedSorted[#Name, #Repeat, #Unparsed, #Attributes], #derived] → #derived ;
///
/// DerivedSorts-Term[%rawHxTerm⟪ #HxConstructor# (#HxScopes#) #HxAttributes# ⟫, #derived] → DerivedSorts-Scopes[#HxScopes#, DerivedSorts-Attributes[#HxAttributes#, #derived]] ;
///
/// DerivedSorts-Term[%rawHxTerm⟪ #HxConstructor1# #HxRepeat# #HxConstructor# (#HxScopes#) #HxAttributes# ⟫, #derived]
/// →
/// DerivedSorts-Repeat[#HxConstructor1#, #HxRepeat#, DerivedSorts-Scopes[#HxScopes#, DerivedSorts-Attributes[#HxAttributes#, #derived]]]
/// ;
///
/// DerivedSorts-Term[%rawHxTerm⟪ #HxMetaVariable# [#HxTerms#] #HxAttributes# ⟫, #derived]
/// →
/// DerivedSorts-Terms[#HxTerms#, DerivedSorts-Attributes[#HxAttributes#, #derived]]
/// ;
///
/// DerivedSorts-Term[%rawHxTerm⟪ #HxConstructor_Sort# #HxRepeat# #HxMetaVariable# [#HxTerms#] #HxAttributes# ⟫, #derived]
/// →
/// DerivedSorts-Repeat[#HxConstructor_Sort#, #HxRepeat#, DerivedSorts-Terms[#HxTerms#, #derived]]
/// ;
///
/// DerivedSorts-Term[RawHxSpecial[#v, #Concrete], #derived] → #derived ;
///
/// DerivedSorts-Repeat[$String, HxRepeat, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-Repeat[#Name, %rawHxRepeat⟪ ⟫, #derived] → #derived ;
/// -[Data[#Name,#Repeat]]: DerivedSorts-Repeat[#Name, $[NotMatch,%rawHxRepeat⟪ ⟫,#Repeat], #derived]
/// →
/// $[IfEmpty, #Name, #derived, (DERIVED[#Name, 0, #Repeat] ; #derived)]
/// ;
///
/// DerivedSorts-Scopes[$List[HxScope], $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-Scopes[#Scopes, #derived] → FoldWhen[ok scope derived.Then-DerivedSorts-Scope[ok, scope, derived], #Scopes, #derived] ;
///
/// Then-DerivedSorts-Scope[Ok, HxScope, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// Then-DerivedSorts-Scope[OK, RawHxScope[#vs, #Term], #derived] → DerivedSorts-Term[#Term, #derived] ;
///
/// DerivedSorts-Terms[$List[HxTerm], $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-Terms[#Terms, #derived] → FoldWhen[ok term derived.Then-DerivedSorts-Term[ok, term, derived], #Terms, #derived] ;
///
/// Then-DerivedSorts-Term[Ok, HxTerm, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// Then-DerivedSorts-Term[OK, #Term, #derived] → DerivedSorts-Term[#Term, #derived] ;
///
/// DerivedSorts-Attributes[$List[HxAttribute], $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-Attributes[(), #derived] → #derived ;
/// DerivedSorts-Attributes[(#a1;#as), #derived] → DerivedSorts-Attribute[#a1, DerivedSorts-Attributes[#as, #derived]] ;
///
/// DerivedSorts-Attribute[HxAttribute, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-Attribute[%rawHxAttribute⟪ #HxAttributeKind# #HxAttributeName# ( #HxTerm# ) ⟫, #derived] → DerivedSorts-Term[#HxTerm#, #derived] ;
/// DerivedSorts-Attribute[%rawHxAttribute⟪ #HxAttributeKind# #HxAttributeName# { #HxTerm# } ⟫, #derived] → DerivedSorts-Term[#HxTerm#, #derived] ;
/// DerivedSorts-Attribute[%rawHxAttribute⟪ #HxAttributeKind# #HxAttributeName# { #HxTerm1# : #HxTerm2# } ⟫, #derived] → DerivedSorts-Term[#HxTerm1#, DerivedSorts-Term[#HxTerm2#, #derived]] ;
/// DerivedSorts-Attribute[%rawHxAttribute⟪ #HxAttributeKind# #HxAttributeName# { ¬ #HxTerm# } ⟫, #derived] → DerivedSorts-Term[#HxTerm#, #derived] ;
///
/// // Name.
/// ProductionNameDerived[DERIVED_SORT] :: Text;
/// ProductionNameDerived[DERIVED[#Name, #Prec, #Repeat]] → PG-ProductionNameWithPrecRepeatText[#Name, #Prec, #Repeat] ;
///
/// Un$Hx[HxTerm] :: HxTerm ;
/// Un$Hx[#] → # ;
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// // Extract scope sorts for unparsed constructor.
///
/// {$String : DeclarationMapEntry}
/// ConstructorScopeSorts[$String<!--SortName-->, $String<!--Constructor-->] :: Lifted[$List[HxScopeSort]] ;
///
/// -[Data[#TopSortName]]:
/// {#DM}ConstructorScopeSorts[#TopSortName, #Constructor]
/// →
/// ConstructorScopeSorts0[$[{#DM}Get[DeclarationMapEntry], #TopSortName, DME_NONE], #Constructor]
/// ;
///
/// ConstructorScopeSorts0[DeclarationMapEntry, $String<!--Constructor-->] :: Lifted[$List[HxScopeSort]] ;
/// -[Data[#Entry, #Constructor]]:
/// ConstructorScopeSorts0[#Entry, #Constructor]
/// →
/// ConstructorScopeSorts1[#Entry, #Constructor]
/// ;
///
/// ConstructorScopeSorts1[DeclarationMapEntry, $String<!--Constructor-->] :: Lifted[$List[HxScopeSort]] ;
///
/// ConstructorScopeSorts1[DME_SORT[#Defines, #Name, #Precs, #Wrapper], #Constructor]
/// →
/// ConstructorScopeSorts2[#Defines, #Constructor]
/// ;
/// ConstructorScopeSorts1[$[NotMatch,DME_SORT[#Defines, #Name, #Precs, #Wrapper],#_], #Constructor] → BOTTOM ;
///
/// ConstructorScopeSorts2[$List[Define], $String<!--Constructor-->] :: Lifted[$List[HxScopeSort]] ;
///
/// ConstructorScopeSorts2[(), #Constructor] → BOTTOM ;
///
/// -[Fresh[param::HxSortParam]]:
/// ConstructorScopeSorts2[(D_ABSTRACTION[a.#Define[a]]; #Defines), #Constructor] → ConstructorScopeSorts2[(#Define[param]; #Defines), #Constructor] ;
///
/// ConstructorScopeSorts2[(D_RULE[#Rule, #sort, #IsDataEquivalence?]; #Defines), #Constructor] → ConstructorScopeSorts2[#Defines, #Constructor] ;
///
/// ConstructorScopeSorts2[(D_FORM[#Form, #Kind]; #Defines), #Constructor]
/// →
/// ConstructorScopeSorts3[#Form, #Defines, #Constructor]
/// ;
///
/// ConstructorScopeSorts2[(D_SYNTHESIZES[#AttributeName]; #Defines), #Constructor] → ConstructorScopeSorts2[#Defines, #Constructor] ;
///
/// ConstructorScopeSorts3[HxForm, $List[Define], $String<!--Constructor-->] :: Lifted[$List[HxScopeSort]] ;
/// -[Data[#Constructor1,#Constructor2]]:
/// ConstructorScopeSorts3[RawHxFormConstruction[#Constructor1, #ScopeSorts, #InheritedRefs], #Defines, #Constructor2]
/// →
/// $[If, $[Equal,#Constructor1,#Constructor2], LIFTED[#ScopeSorts], ConstructorScopeSorts2[#Defines, #Constructor2]]
/// ;
/// -[Data[#_]]:
/// ConstructorScopeSorts3[$[NotMatch,RawHxFormConstruction[#Constructor, #ScopeSorts, #InheritedRefs],#_], #Defines, #Constructor2] → ConstructorScopeSorts2[#Defines, #Constructor2] ;
///
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// // Extract sort names.
///
/// {$String : DeclarationMapEntry} SortNameList :: $List[$String] ;
/// {#DM} SortNameList → {#DM} SortNameList2[$[{#DM}Keys[$String]]] ;
///
/// {$String : DeclarationMapEntry} SortNameList2[$List[$String]] :: $List[$String] ;
/// {#DM} SortNameList2[()] → () ;
/// {#DM} SortNameList2[(#Name; #Names)] → {#DM} SortNameList3[$[{#DM}Get[DeclarationMapEntry], #Name], #Names] ;
///
/// {$String : DeclarationMapEntry} SortNameList3[DeclarationMapEntry, $List[$String]] :: $List[$String] ;
/// {#DM} SortNameList3[DME_SORT[#Defines1, #Name1, #Precs1, #Wrapper1], #Names]
/// →
/// (#Name1 ; {#DM} SortNameList2[#Names])
/// ;
///
/// {#DM} SortNameList3[$[NotMatch, DME_SORT[#Defines1, #Name1, #Precs1, #Wrapper1], #_], #Names]
/// →
/// {#DM} SortNameList2[#Names]
/// ;
///
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// // Extract token names.
///
/// {$String : DeclarationMapEntry} TokenNameList :: $List[$String] ;
/// {#DM} TokenNameList → {#DM} TokenNameList2[$[{#DM}Keys[$String]]] ;
///
/// {$String : DeclarationMapEntry} TokenNameList2[$List[$String]] :: $List[$String] ;
/// {#DM} TokenNameList2[()] → () ;
/// {#DM} TokenNameList2[(#Name; #Names)] → {#DM} TokenNameList3[$[{#DM}Get[DeclarationMapEntry], #Name], #Name, #Names] ;
///
/// {$String : DeclarationMapEntry} TokenNameList3[DeclarationMapEntry, $String, $List[$String]] :: $List[$String] ;
/// {#DM} TokenNameList3[DME_TOKEN[#String1], #Name, #Names]
/// →
/// (#Name ; {#DM} TokenNameList2[#Names])
/// ;
///
/// {#DM} TokenNameList3[$[NotMatch, DME_TOKEN[#String1], #_], #Name, #Names]
/// →
/// {#DM} TokenNameList2[#Names]
/// ;
///
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// // Extract attribute names.
///
/// {$String : DeclarationMapEntry} AttributeNameList :: $List[$String] ;
/// {#DM} AttributeNameList → {#DM} AttributeNameList2[$[{#DM}Keys[$String]]] ;
///
/// {$String : DeclarationMapEntry} AttributeNameList2[$List[$String]] :: $List[$String] ;
/// {#DM} AttributeNameList2[()] → () ;
/// {#DM} AttributeNameList2[(#Name; #Names)] → {#DM} AttributeNameList3[$[{#DM}Get[DeclarationMapEntry], #Name], #Names] ;
///
/// {$String : DeclarationMapEntry} AttributeNameList3[DeclarationMapEntry, $List[$String]] :: $List[$String] ;
/// {#DM} AttributeNameList3[DME_ATTRIBUTE[#HxAttributeKind#, #HxAttributeName#, #HxAttributeForm#, #HxAttributeOptions#], #Names]
/// →
/// (#HxAttributeName# ; {#DM} AttributeNameList2[#Names])
/// ;
///
/// {#DM} AttributeNameList3[$[NotMatch, DME_ATTRIBUTE[#HxAttributeKind#, #HxAttributeName#, #HxAttributeForm#, #HxAttributeOptions#], #_], #Names]
/// →
/// {#DM} AttributeNameList2[#Names]
/// ;
///
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// // Sort name for attribute value.
///
/// {$String : DeclarationMapEntry} AttributeValuePG-SortName[$String] :: $String;
/// {#DM}AttributeValuePG-SortName[#AttributeName] → {#DM}AttributeValueSortName1[$[{#DM}Get[DeclarationMapEntry], #AttributeName, DME_NONE], #AttributeName] ;
///
/// {$String : DeclarationMapEntry} AttributeValueSortName1[DeclarationMapEntry, $String] :: $String;
/// -[Data[#Entry]]:
/// {#DM}AttributeValueSortName1[#Entry, #AttributeName] → {#DM}AttributeValueSortName2[#Entry, #AttributeName] ;
///
/// {$String : DeclarationMapEntry} AttributeValueSortName2[DeclarationMapEntry, $String] :: $String;
/// {#DM}AttributeValueSortName2[DME_ATTRIBUTE[#AttributeKind, #AttributeName, %rawHxAttributeForm⟪ ( #HxSort# ) ⟫, #AttributeOptions], #SortName] → PG-SortName[#HxSort#];
/// {#DM}AttributeValueSortName2[DME_ATTRIBUTE[#AttributeKind, #AttributeName, %rawHxAttributeForm⟪ { #HxSort# } ⟫, #AttributeOptions], #SortName] → "";
/// {#DM}AttributeValueSortName2[DME_ATTRIBUTE[#AttributeKind, #AttributeName, %rawHxAttributeForm⟪ { #HxSort1# : #HxSort2# } ⟫, #AttributeOptions], #SortName] → PG-SortName[#HxSort2#];
/// -[Data[#_]]: {#DM}AttributeValueSortName2[$[NotMatch,DME_ATTRIBUTE[#AttributeKind, #AttributeName, #AttributeForm, #AttributeOptions],#_], #SortName] → $[Error,"No declaration of attribute"] ;
///
/// {$String : DeclarationMapEntry} AttributeKeyPG-SortName[$String] :: $String;
/// {#DM}AttributeKeyPG-SortName[#SortName] → {#DM}AttributeKeySortName1[$[{#DM}Get[DeclarationMapEntry], #SortName, DME_NONE], #SortName] ;
///
/// {$String : DeclarationMapEntry} AttributeKeySortName1[DeclarationMapEntry, $String] :: $String;
/// -[Data[#Entry]]:
/// {#DM}AttributeKeySortName1[#Entry, #SortName] → {#DM}AttributeKeySortName2[#Entry, #SortName] ;
///
/// {$String : DeclarationMapEntry} AttributeKeySortName2[DeclarationMapEntry, $String] :: $String;
/// {#DM}AttributeKeySortName2[DME_ATTRIBUTE[#AttributeKind, #AttributeName, %rawHxAttributeForm⟪ ( #HxSort# ) ⟫, #AttributeOptions], #SortName] → "" ;
/// {#DM}AttributeKeySortName2[DME_ATTRIBUTE[#AttributeKind, #AttributeName, %rawHxAttributeForm⟪ { #HxSort# } ⟫, #AttributeOptions], #SortName] → PG-SortName[#HxSort#];
/// {#DM}AttributeKeySortName2[DME_ATTRIBUTE[#AttributeKind, #AttributeName, %rawHxAttributeForm⟪ { #HxSort1# : #HxSort2# } ⟫, #AttributeOptions], #SortName] → PG-SortName[#HxSort1#];
/// {#DM}AttributeKeySortName2[$[NotMatch,DME_ATTRIBUTE[#AttributeKind, #AttributeName, #AttributeForm, #AttributeOptions],#_], #SortName] → "" ;
///
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// // Initialize otherwise unused maps.
///
/// {$String : DeclarationMapEntry} PG-InitOtherMaps[$List[HxAttribute], $String] :: Text;
///
/// {#DM; "$AllInheritedMapNames" : NAMES[#InheritedMapNames]}
/// PG-InitOtherMaps[#Attributes, #sep] → PG-InitOtherMaps1[FoldWhen[ok a ns.ThenRemoveAttributeName[ok, a, ns], #Attributes, #InheritedMapNames], #sep, $False] ;
///
/// {$String : DeclarationMapEntry} PG-CaptureOtherMaps[$List[HxAttribute]] :: Text;
/// {#DM; "$AllInheritedMapNames" : NAMES[#InheritedMapNames]}
/// PG-CaptureOtherMaps[#Attributes] → PG-InitOtherMaps1[FoldWhen[ok a ns.ThenRemoveAttributeName[ok, a, ns], #Attributes, #InheritedMapNames], "; ", $True] ;
///
/// ThenRemoveAttributeName[Ok, HxAttribute, NameSet] :: NameSet;
/// ThenRemoveAttributeName[OK, %rawHxAttribute⟪ #HxAttributeKind# #HxAttributeName# #HxAttributeValue# ⟫, #MapNames] → RemoveName[#MapNames, #HxAttributeName#] ;
///
/// PG-InitOtherMaps1[NameSet, $String, $Boolean] :: Text;
/// PG-InitOtherMaps1[#MapNames, #sep, #capture] → PG-InitOtherMaps2[NameSetList[#MapNames], #sep, #capture] ;
///
/// PG-InitOtherMaps2[$List[$String], $String, $Boolean] :: Text;
/// PG-InitOtherMaps2[(), #sep, #capture] → %n⟪⟫ ;
/// PG-InitOtherMaps2[(#a;#as), #sep, #capture] → %n⟪†«#sep»"†«#a»" : {« $[If, #capture, %n⟨#InheritedMap_†‹#a›⟩, %n⟨⟩] »}Inherited_†«#a»« PG-InitOtherMaps2[#as, "; ", #capture] »⟫ ;
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// )]//PrepN
