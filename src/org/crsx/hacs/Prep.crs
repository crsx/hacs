// Prep.crs: CRSX3 RULES FOR CONVERTING HACS .hx FORM TO DESCRIPTIVE PARSER ARTIFACTS.
// Copyright © 2012,2014 Kristoffer H. Rose <krisrose@crsx.org>

// "Preparation" stage for converting HACS specification to PG/JavaCC parser + CRSX rules combination.
//
// Reads the HACS (.hx) file as a "raw Hx" term and emits a single text containing multiple files (using /***...***/ delimiters):
// * .pg parser for user's language (unmarked + USERPG).
// * .crs sort declarations for user's terms (SORTS).
// * .pgtemplate for HACS parser extended with user's meta-terms (METAPG).
// * .pg parser for user's meta-terms as embedded in rules (EMBEDPG).
// * .crs sort declarations for meta-terms (METASORTS).
//
// Units:
// 1. Top level (Prep).
// 5. Generate text of all non-terminal productions (P-Productions).
// 6. Generate single sort/precedence combination (P-Expand).
// 7. Generate text of all lexical declarations (P-Lexical).
// 8. Helpers for managing repeats.
// 9. Text naming conventions.
// 10. JJ Helpers.
// 11. Other Helpers.

Prep[(

// Input format is full "raw" HACS syntax %raw….⟦…⟧.
$CheckGrammar["org.crsx.hacs.HxRaw"];
$Use["org/crsx/hacs/Hx.crs"];

// Output format is text %n⟪...⟫.
$CheckGrammar["net.sf.crsx.text.Text"];
$Use["net/sf/crsx/text/Text.crs"];

// Standard functions.
$Use["org/crsx/hacs/Prelude.crs"];

// Utilities shared with other stages.
$Use["org/crsx/hacs/Util.crs"];

// Infer options.
$Lax;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 1. TOP LEVEL
//
// Prep1: Extract declarations from HACS hx term with all modules inlined.
// Prep2: Generate actual text.

Prep[HxModule] :: Text;
Prep[%rawHxModule⟦ module #HxModuleName# { #HxDeclarations# } ⟧]
→
Prep1[#HxModuleName#, U-ResolveImports[#HxDeclarations#, #HxModuleName#, "raw"], dm ds.Prep2[dm, ds, #HxModuleName#]]
;

Prep1[$String<!--ModuleName-->, $List[HxDeclaration], ok::Ok dm::DeclarationMap.Text] :: Text;
Prep1[#ModuleName, #Declarations, ok dm.#[ok,dm]]
→
#[{} U-MakeDeclarationMap[#Declarations, #ModuleName], #Declarations]
;

Prep2[DeclarationMap, $List[HxDeclaration], $String<!--ModuleName-->] :: Text ;
-[Data[#Declarations]]:
Prep2[{#DM}DM, #Declarations, #ModuleName]
→
%n⟪/* P Grammar for /***METAPG&EMBED: HACS module specialized for parsed***/ †« #ModuleName » terms /***EMBEDPG: (embedded terms)***/ */

/* INTERFACE. */

class †« P-ClassName[#ModuleName] »/***USERPG:Parser***//***METAPG:Hx***//***EMBEDPG:Embed***/ :⟦
/***USERPG&EMBEDPG:<†« {#DM}U-MainSymbol »>« MapTextConcat[n.%n⟨,<†‹n›>⟩, {#DM}U-NonMainSymbols] » ***/
/***METAPG:
%%%HXNONTERMINALS%%%
<HxTopTerm>, <HxTopPattern>, <HxAttributes>, <HxSortName>, <HxAttributeName>, <HxConstructor>,
<PresortedMetaApplication>, <PresortedVariable>, <PresortedParsed>, <SortedTerm>,
<BracketedTerms>, <Terms>, <Term>, <Attribute>
***/
⟧

/***USERPG: prefix "†« P-User-Prefix[#ModuleName] »" ***/
/***METAPG: prefix "†« P-Meta-Prefix[#ModuleName] »" ***/
/***EMBEDPG: prefix "†« P-Embed-Prefix[#ModuleName] »" ***/

/***METAPG:
declarations
%{
%%%HXDECLARATIONS%%%
String hx(String s) { return "Hx_"+s; }
String user(String s) { return "†« U-LastName[#ModuleName] »_"+s; }
%}
***/

/***EMBEDPG:
declarations
%{
static String unwrap(String s) {return s.substring(1, s.length()-1);}
String hx(String s) { return "Hx_"+s; }
String user(String s) { return "†« U-LastName[#ModuleName] »_"+s; }
%}
***/

/***USERPG&EMBEDPG:
%{
TOKEN_MGR_DECLS : { int nesting; int nestedState;} /* Used by all nesting constructs. */
%}
***/

/***METASORTS:
/* META-TERM SORTS. */

†« U-QN[#ModuleName, "NodeSort", "Term"] » ::= (⟦
« FoldNamesWhen[ok n t.P-then-MetaSorts-ConstructionSortCaseText[ok, #ModuleName, n, t], {#DM} U-AllSortNames, %n⟨⟩] »⟧
);

†« U-QN[#ModuleName, "NodeSort", "Scope"] » ::= (⟦
†« U-QN[#ModuleName, "Tag", "Binder"] »[binder :: †« U-QN[#ModuleName, "NodeSort", "Term"] » . †« U-QN[#ModuleName, "NodeSort", "Scope"] »];
†« U-QN[#ModuleName, "Tag", "Subterm"]»[†« U-QN[#ModuleName, "NodeSort", "Term"] »]; ⟧
);
***/

/***METAPG:
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
%%%HXPREPRODUCTIONS%%%
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
***/

/***METAPG:
/* HX INTERFACE. */

<HxTopTerm> ::= <PresortedVariable> | <PresortedMetaApplication> | <HxTopPattern> .
<HxTopPattern> ::= <PresortedParsed> | <SortedTerm> .
<HxAttributes> ::= ( {$Cons} <Attribute> <HxAttributes> | {$Nil} ).
<HxSortName> ::= ( « TextJoin[MapNames[n.%n⟨"†‹n›"$⟩, UnionNames[{#DM}U-AllTokenNames, {#DM}U-AllSortNames]], %n⟨ | ⟩] » ).
<HxConstructor> ::= (« TextJoin[{#DM} U-MapAllConstructorSorts[c s.%n⟨"†‹c›"$⟩], %n⟨ | ⟩] » ).

/* GENERAL TERMS. */

<PresortedVariable> ::= <HxVariable>!!!:#v ( {Special}:hx {{#v}} HX_CONCRETE$$:unwrap:{n} <HxAttributes> | <PresortedVariableIs #v> ) .
%{
/* <PresortedVariableIs #variable> */
net.sf.crsx.Sink N_PresortedVariableIs(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env, net.sf.crsx.util.Buffer variable_b) :
{}{⟦
« JJ-Construction[%n⟨"†‹ P-hx[#ModuleName, "VariableUseSorted"] ›"⟩, TextJoin[(
    JJ-StringLiteral[%n⟨storedSort⟩];
    JJ-Construction[%n⟨hx("RepeatSingle")⟩, %n⟨⟩];
    %n⟨{sink = variable_b.term(true).copy(sink, true, net.sf.crsx.util.LinkedExtensibleMap.EMPTY_RENAMING);}⟩;
    JJ-Nonterminal[%n⟨sink⟩, %n⟨HxAttributes⟩, e.e];),
    %n⟨¶⟩]] »
{return sink;}⟧
}

/* <PresortedMetaApplication> ::= */
net.sf.crsx.Sink N_PresortedMetaApplication$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) : {}{ « JJ-Nonterminal[%n⟨sink⟩, %n⟨PresortedMetaApplication⟩, e.e] » <EOF> {return sink;} }
net.sf.crsx.Sink N_PresortedMetaApplication(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}{⟦
« JJ-Construction[%n⟨"†‹ P-hx[#ModuleName, "MetaApplicationSorted"] ›"⟩, TextJoin[(
    JJ-StringLiteral[%n⟨storedSort⟩];
    JJ-Construction[%n⟨"†‹ P-hx[#ModuleName, "RepeatSingle"] ›"⟩, %n⟨⟩];
    JJ-Nonterminal[%n⟨sink⟩, %n⟨HxMetaVariable⟩, e.e];
    JJ-Nonterminal[%n⟨sink⟩, %n⟨BracketedTerms⟩, e.e];
    JJ-Nonterminal[%n⟨sink⟩, %n⟨HxAttributes⟩, e.e];),
    %n⟨¶⟩]] »{return sink;}⟧
}

/* <PresortedParsed> ::= */
net.sf.crsx.Sink N_PresortedParsed$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) : {}{ « JJ-Nonterminal[%n⟨sink⟩, %n⟨PresortedParsed⟩, e.e] » <EOF> {return sink;} }
net.sf.crsx.Sink N_PresortedParsed(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{Token t;}{⟦
{sink = sink.start(makeTConstructor(sink, null, "C-AttributeWrapperSorted", null));}
« JJ-StringLiteral[%n⟨storedSort⟩]
»t=<T_HX_CONCRETE>
{
  try {sink = factory.parser(factory).parse(sink, "†« P-Embed-Prefix[#ModuleName] »"+storedSort, new java.io.StringReader(unwrap(t.toString())), unit, t.beginLine, t.beginColumn+1, env);}
  catch (java.io.IOException e) {throw new ParseException(e.getMessage());}
  catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) throw (ParseException) cause; else throw new ParseException(e.getMessage());}
}
« JJ-Nonterminal[%n⟨sink⟩, %n⟨HxAttributes⟩, e.e] »
{return sink.end();}⟧
}

/* <SortedTerm> ::= stand-alone term with explicit or implied sort. */
net.sf.crsx.Sink N_SortedTerm$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) : {}{ « JJ-Nonterminal[%n⟨sink⟩, %n⟨SortedTerm⟩, e.e] » <EOF> {return sink;} }
net.sf.crsx.Sink N_SortedTerm(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{⟦
String savedSort;
net.sf.crsx.util.Buffer b = new net.sf.crsx.util.Buffer(sink);
net.sf.crsx.Sink s = null;⟧
}{⟦
(
  « JJ-Nonterminal[%n⟨sink⟩, %n⟨Construction⟩, e.e] »
|⟦
{s = b.sink();}
« JJ-Nonterminal[%n⟨s⟩, %n⟨HxSortName⟩, e.e]
»{savedSort = storedSort; storedSort = net.sf.crsx.util.Util.symbol(b.term(true));}
( « JJ-Nonterminal[%n⟨sink⟩, %n⟨PresortedVariable⟩, e.e] »
| « JJ-Nonterminal[%n⟨sink⟩, %n⟨Construction⟩, e.e] »
| « JJ-Nonterminal[%n⟨sink⟩, %n⟨PresortedMetaApplication⟩, e.e] »
| « JJ-Nonterminal[%n⟨sink⟩, %n⟨PresortedParsed⟩, e.e] »
)
{storedSort = savedSort;}⟧
)
{return sink;}⟧
}
%}

<Construction> ::= (⟦ « TextJoin[Map[s.%n⟨<†‹s›_Construction>⟩, FilterWhen[ok s. {#DM}P-then-SortHasHx[ok, s], NameSetList[{#DM}U-AllSortNames]]], %n⟨ | ⟩] »⟧ ).

<BracketedTerms> ::= ( HX_LBRACKET (<Terms> | {$Nil}) HX_RBRACKET | {$Nil} ) .
<Terms> ::= {$Cons} <Term> (HX_COMMA <Terms> | {$Nil}) .

<Term> ::= <HxVariable>!!! | <SortedTerm> .

<Attribute> ::= ⟦« {#DM} P-Meta-AttributeAlternatives[#ModuleName, NameSetList[{#DM} U-AllSynthesizedNames], NameSetList[{#DM}U-AllInheritedNames]] »⟧ .
***/

/* USER GRAMMAR. */

« {#DM}P-Productions[#ModuleName] »


/***METAPG:
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
%%%HXPOSTPRODUCTIONS%%%
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
***/

/***USERPG&EMBEDPG:
/* TOKENS. */

« P-Lexical[#Declarations, #ModuleName] »
***/
⟫
;

P-then-MetaSorts-ConstructionSortCaseText[OK, #ModuleName, #Name, #rest]
→
%n⟪†« U-QN[#ModuleName, "Node", #Name] »[†« U-QN[#ModuleName, "TagSort", #Name] », $List[†« U-QN[#ModuleName, "NodeSort", "Scope"] »]];
« #rest»⟫
;

{#DM} P-Meta-AttributeAlternatives[#ModuleName, (), ()] → %n⟪()⟫ ;
{#DM} P-Meta-AttributeAlternatives[#ModuleName, (#s1; #ss), ()] → %n⟪ HX_UP (⟦« {#DM} P-Meta-AttributeBodies[#ModuleName, (#s1; #ss), %n⟨⟩] »⟧) ⟫ ;
{#DM} P-Meta-AttributeAlternatives[#ModuleName, (), (#i1; #is)] → %n⟪ HX_DOWN (⟦« {#DM} P-Meta-AttributeBodies[#ModuleName, (#i1; #is), %n⟨⟩] »⟧) ⟫ ;
{#DM} P-Meta-AttributeAlternatives[#ModuleName, (#s1; #ss), (#i1; #is)] → %n⟪ HX_UP (⟦« {#DM} P-Meta-AttributeBodies[#ModuleName, (#s1; #ss), %n⟨⟩] »⟧)
 | HX_DOWN (⟦« {#DM} P-Meta-AttributeBodies[#ModuleName, (#i1; #is), %n⟨⟩] »⟧) ⟫ ;

-[Data[#Name]]:
{#DM} P-Meta-AttributeBodies[#ModuleName, (#Name; #Names), #sep]
→
%n⟪«#sep» « P-Meta-AttributeBody[#ModuleName, #Name, $[{#DM}Get, #Name, DME_NONE]] »
« P-Meta-AttributeBodies[#ModuleName, #Names, %n⟨|⟩] »⟫
;

-[Data[#Name]]:
{#DM} P-Meta-AttributeBodies[#ModuleName, (), #sep]
→
%n⟪⟫
;

P-Meta-AttributeBody[#ModuleName, #Name, DME_ATTRIBUTE[#AttributeKind, #AttributeName, #AttributeForm, #AttributeOptions]]
→
%n⟪<Attribute« AttributeKindCategory[#AttributeKind] »_†«#AttributeName»>⟫
;

P-Meta-AttributeBody[#ModuleName, #Name, $[NotMatch,DME_ATTRIBUTE[#AttributeKind, #AttributeName, #AttributeForm, #AttributeOptions],#_]]
→
PrepError[$[:,"Inconsistent attribute...",#Name]]
;

// ALTERNATE TOP LEVEL:

P-GetModuleName[HxModule] :: Text;
P-GetModuleName[%rawHxModule⟦ module #HxModuleName# { #HxDeclarations# } ⟧]
→
%n⟪†«$[Replace,#HxModuleName#,"\"",""]»⟫
;

P-PrintEnvironment[HxModule] :: Text;
P-PrintEnvironment[%rawHxModule⟦ module #HxModuleName# { #HxDeclarations# } ⟧]
→
Prep1[#HxModuleName#, U-ResolveImports[#HxDeclarations#, #HxModuleName#, "raw"], dm ds.P2Print[dm, ds, #HxModuleName#]]
;

P2Print[DeclarationMap, $List[HxDeclaration], $String<!--ModuleName-->] :: Text ;
-[Data[#ModuleName]]:
P2Print[{#DM}DM, #Declarations, #ModuleName]
→
%n⟪MODULE='†« $[Replace,#ModuleName,"\"",""] »'
NAME='†« U-LastName[#ModuleName] »'
SORT='†« {#DM}U-MainSymbol  »'
SORTS='†« {#DM}U-MainSymbol »« MapTextConcat[n.%n⟨ †‹n›⟩, {#DM}U-NonMainSymbols] »'
SINKCLASS='net.sf.crsx.text.TextSink'
PARSERCLASS='†« P-ClassName[#ModuleName] »Parser'
PREFIX='†« P-User-Prefix[#ModuleName] »'
METAPARSERCLASS='†« P-ClassName[#ModuleName] »Hx'
METAPREFIX='†« P-Meta-Prefix[#ModuleName] »'
EMBEDPARSERCLASS='†« P-ClassName[#ModuleName] »Embed'
EMBEDPREFIX='†« P-Embed-Prefix[#ModuleName] »'
⟫
;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 5. TEXT OF ALL NON-TERMINAL PRODUCTIONS.
//
// Productions are extracted by sort and for each sort grouped by precedence,
// each group producing a P production.

// Iterate through all productions.

{$String<!--SortName--> : DeclarationMapEntry} P-Productions[$String<!--ModuleName-->] :: Text;
{#DM} P-Productions[#ModuleName] → {#DM} P-Productions0[#ModuleName, {#DM} U-AllNames] ;

{$String<!--SortName--> : DeclarationMapEntry} P-Productions0[$String<!--ModuleName-->, NameSet] :: Text;
{#DM} P-Productions0[#ModuleName, #Names] → {#DM} P-Productions1[HasNames[#Names], #ModuleName, #Names] ;

{$String<!--SortName--> : DeclarationMapEntry} P-Productions1[Boolean, $String<!--ModuleName-->, NameSet] :: Text;
{#DM} P-Productions1[B_TRUE , #ModuleName, #Names] → %n⟪« {#DM} P-Production[#ModuleName, FirstName[#Names]] »« {#DM} P-Productions0[#ModuleName, RemoveFirstName[#Names]] »⟫ ;
{#DM} P-Productions1[B_FALSE, #ModuleName, #Names] → %n⟪⟫ ;

// Emit productions for one declaration.

{$String<!--Name--> : DeclarationMapEntry} P-Production[$String<!--ModuleName-->, $String<!--Name-->] :: Text;
-[Data[#Name]]:
{#DM} P-Production[#ModuleName, #Name]
→
{#DM} P-Production1[#ModuleName, $[{#DM}Get, #Name, DME_NONE]]
;

{$String<!--SortName--> : DeclarationMapEntry} P-Production1[$String<!--ModuleName-->, DeclarationMapEntry] :: Text;

// Dummy.

{#DM} P-Production1[#ModuleName, DME_NONE]
→
%n⟪⟫
;

// Token declaration.

{#DM}
P-Production1[#ModuleName, DME_TOKEN[#SortName]]
→
%n⟪
/* Productions for †«#SortName» token. */

/***USERPG&EMBEDPG:
« P-GenerateNonterminalDeclaration[P-ProductionNameText[#SortName],
  %n⟨/***EMBEDPG:‹ {#DM}P-Embed-Head[B_TRUE, #ModuleName, #SortName, #SortName, B_FALSE, 0]›***/ (‹P-TokenNameText[#SortName]›$)⟩] »
***/
/***EMBEDPG:
« {#DM}P-Embed-Tail[B_TRUE, #SortName, #SortName] »
***/

/***METAPG:
/* <†«#SortName»> covers Hacs terms restricted to †«#SortName» token sort. */
%{
net.sf.crsx.Sink N_†«#SortName»$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) : {}{ sink=N_†«#SortName»(sink, env) <EOF> {return sink;} }
net.sf.crsx.Sink N_†«#SortName»(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{String savedSort;}{
  {savedSort = storedSort; storedSort = "†«#SortName»";}
  ( "†«#SortName»" )?
  ( « JJ-Nonterminal[%n⟨sink⟩, %n⟨PresortedVariable⟩, e.e] »
  | « JJ-Nonterminal[%n⟨sink⟩, %n⟨PresortedMetaApplication⟩, e.e] »
  | « JJ-Nonterminal[%n⟨sink⟩, %n⟨PresortedParsed⟩, e.e] »
  )
  {storedSort = savedSort;}
  {return sink;}
}
%}
***/
⟫
;
/// « P-GenerateNonterminalDeclaration[P-ProductionNameText[#SortName], %n⟨(‹P-TokenNameText[#SortName]›$)⟩] »

P-GenerateNonterminalDeclaration[Text, Text] → Text;
P-GenerateNonterminalDeclaration[#Name, #Alternatives] → %n⟪<«#Name»> ::= ⟦«#Alternatives»⟧ .⟫ ;
//TODO: use for all production declarations.

// Attribute declaration.

{#DM} P-Production1[#ModuleName, DME_ATTRIBUTE[#Kind, #Name, #AttributeForm, #AttributeOptions]]
→
%n⟪
/***METAPG:
/* Productions for †«#Name» attribute. */
%{
« P-MetaJJ-Production-Attribute[#ModuleName, #Kind, #Name, #AttributeForm, #AttributeOptions] »
%}
***/
⟫;

    // Handle an attribute definition.

    P-MetaJJ-Production-Attribute[$String<!--ModuleName-->, HxAttributeKind, $String, HxAttributeForm, $List[HxAttributeOption]] :: Text;
    P-MetaJJ-Production-Attribute[#ModuleName, #Kind, #Name, #AttributeForm, #AttributeOptions]
    →
    %n⟪
/* <Attribute« AttributeKindCategory[#Kind] »_†«#Name»> ::= ... */
net.sf.crsx.Sink N_Attribute« AttributeKindCategory[#Kind] »_†«#Name»(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{Token t;}
{
  LOOKAHEAD( {getToken(1).kind == T_HX_VAR && "†«#Name»".equals(getToken(1).image)} )
  {sink = sink.start(makeTConstructor(sink, null, hx("Attribute"), null));}
  {sink = sink.start(makeTConstructor(sink, null, hx("« AttributeKindIndicator[#Kind] »"), null)).end();}
  t=<T_HX_VAR>
  ⟦« P-MetaJJ-AttributeFormSyntax[#ModuleName, #AttributeForm, #AttributeOptions] »⟧
  {return sink.end();}
}
⟫;

    AttributeKindCategory[HxAttributeKind] :: Text ;
    AttributeKindCategory[%rawHxAttributeKind⟪ ↑ ⟫] → %n⟪Synthesized⟫ ;
    AttributeKindCategory[%rawHxAttributeKind⟪ ↓ ⟫] → %n⟪Inherited⟫ ;

    AttributeKindIndicator[HxAttributeKind] :: Text ;
    AttributeKindIndicator[%rawHxAttributeKind⟪ ↑ ⟫] → %n⟪AttributeKindUp⟫ ;
    AttributeKindIndicator[%rawHxAttributeKind⟪ ↓ ⟫] → %n⟪AttributeKindDown⟫ ;


    P-MetaJJ-AttributeFormSyntax[$String<!--ModuleName-->, HxAttributeForm, $List[HxAttributeOption]] :: Text ;
    P-MetaJJ-AttributeFormSyntax[#ModuleName, %rawHxAttributeForm⟪ ( #HxSort# ) ⟫, #AttributeOptions]
    →
    %n⟪« JJ-Token[%n⟨HX_LPAREN⟩] »« JJ-Construction[%n⟨hx("AttributeValue")⟩, JJ-Nonterminal[%n⟨sink⟩, %n⟨†‹ U-SortName[#HxSort#] ›⟩, e.e]] »« JJ-Token[%n⟨HX_RPAREN⟩] »⟫
    ;
    P-MetaJJ-AttributeFormSyntax[#ModuleName, %rawHxAttributeForm⟪ { #HxSort# } ⟫, #AttributeOptions]
    →
    %n⟪« JJ-Token[%n⟨HX_LBRACE⟩] »« JJ-Construction[%n⟨hx("AttributeKey")⟩, JJ-Nonterminal[%n⟨sink⟩, %n⟨†‹ U-SortName[#HxSort#] ›⟩, e.e]] »« JJ-Token[%n⟨HX_RBRACE⟩] »⟫
    ;
    P-MetaJJ-AttributeFormSyntax[#ModuleName, %rawHxAttributeForm⟪ { #HxSort1# : #HxSort2# } ⟫, #AttributeOptions]
    →
    %n⟪« JJ-Token[%n⟨HX_LBRACE⟩] »«
      JJ-Construction[%n⟨hx("AttributeKeyValue")⟩,
        MapTextConcat[t.t, (
	  JJ-Nonterminal[%n⟨sink⟩, %n⟨†‹ U-SortName[#HxSort1#] ›⟩, e.e];
          JJ-Token[%n⟨HX_COLON⟩];
          JJ-Nonterminal[%n⟨sink⟩, %n⟨†‹ U-SortName[#HxSort2#] ›⟩, e.e];
      )]]
    »« JJ-Token[%n⟨HX_RBRACE⟩] »⟫
    ;

    AttributeKindToken[HxAttributeKind] :: Text ;
    AttributeKindToken[%rawHxAttributeKind⟪ ↑ ⟫] → %n⟪HX_UP⟫ ;
    AttributeKindToken[%rawHxAttributeKind⟪ ↓ ⟫] → %n⟪HX_DOWN⟫ ;

// Sort declaration.

{#DM} P-Production1[#ModuleName, DME_SORT[#Defines, #SortName, #Precs, #Wrapper, #IsMain]]
→
%n⟪« {#DM} P-Production-Defines[#ModuleName, #Defines, #SortName, 0, ()] »
/***METAPG:
%{
« {#DM} P-MetaJJ-Production-Defines[#ModuleName, #Defines, #SortName, P-DefinesHaveHx[#Defines]] »
%}
***/⟫
;

// Helper for ParsedForm and FK.
PFK_SORT ::=( PFK[HxParsedForm, FormKind]; );

// Handle a sort definition.

{$String<!--SortName--> : DeclarationMapEntry} P-Production-Defines[$List[Define], $String, $Numeric, $List[PFK_SORT]] :: Text;

{#DM} P-Production-Defines[#ModuleName, (), #SortName, #Prec, ()]
→
%n⟪⟫
;

{#DM} P-Production-Defines[#ModuleName, (), #SortName, #Prec, (#PFK1;#PFKs)]
→
%n⟪

/* Productions for †«#SortName» sort with (highest) precedence †«$[FormatNumber,#Prec]». */
« {#DM} P-Expand[#ModuleName, (#PFK1;#PFKs), #SortName, #Prec, B_TRUE] »
⟫
;

-[Fresh[dummy::HxSortParam]]:
{#DM} P-Production-Defines[#ModuleName, (D_ABSTRACTION[a.#Define1[a]]; #Defines), #SortName, #Prec, #PrecPFKs]
→
{#DM} P-Production-Defines[#ModuleName, (#Define1[dummy]; #Defines), #SortName, #Prec, #PrecPFKs]
;

{#DM} P-Production-Defines[#ModuleName, (D_RULE[#Rule, #RuleSort, #IsData]; #Defines), #SortName, #Prec, #PrecPFKs]
→
{#DM} P-Production-Defines[#ModuleName, #Defines, #SortName, #Prec, #PrecPFKs]
;

{#DM} P-Production-Defines[#ModuleName, (D_FORM[#Form1, #Kind1]; #Defines), #SortName, #Prec, #PrecPFKs]
→
{#DM} P-Production-Defines2[#ModuleName, #Form1, #Kind1, #Defines, #SortName, #Prec, #PrecPFKs]
;

{#DM} P-Production-Defines[#ModuleName, (D_SYNTHESIZES[#AttributeName1]; #Defines), #SortName, #Prec, #PrecPFKs]
→
{#DM} P-Production-Defines[#ModuleName, #Defines, #SortName, #Prec, #PrecPFKs]
;

{$String<!--SortName--> : DeclarationMapEntry} P-Production-Defines2[HxForm, FormKind, $List[Define], $String, $Numeric, $List[PFK_SORT]] :: Text;

{#DM} P-Production-Defines2[#ModuleName, Hx_FormParsedSorted[#Sort1, #ParsedForm1, #Prec1, #InheritedRefs], #Kind1, #Defines, #SortName, #Prec, #PrecPFKs]
→
{#DM} P-Production-Defines3[#ModuleName, #ParsedForm1, #Prec1, #Kind1, #Defines, #SortName, #Prec, #PrecPFKs]
;

{#DM} P-Production-Defines2[#ModuleName, Hx_FormParsed[#ParsedForm1, #Prec1, #InheritedRefs], #Kind1, #Defines, #SortName, #Prec, #PrecPFKs]
→
{#DM} P-Production-Defines3[#ModuleName, #ParsedForm1, #Prec1, #Kind1, #Defines, #SortName, #Prec, #PrecPFKs]
;

{#DM} P-Production-Defines2[#ModuleName, Hx_FormConstruction[#Constructor, #ScopeSortList, #InheritedRefs], #Kind1, #Defines, #SortName, #Prec, #PrecPFKs]
→
{#DM} P-Production-Defines[#ModuleName, #Defines, #SortName, #Prec, #PrecPFKs]
;

{$String<!--SortName--> : DeclarationMapEntry} P-Production-Defines3[HxParsedForm, $Numeric, FormKind, $List[Define], $String, $Numeric, $List[PFK_SORT]] :: Text;

-[Data[#Prec1,#Prec],Share[#ParsedForm1,#Kind1,#Defines]]:
{#DM} P-Production-Defines3[#ModuleName, #ParsedForm1, #Prec1, #Kind1, #Defines, #SortName, #Prec, ()]
→
$[If, $[NumericEqual,#Prec1,#Prec],
  {#DM} P-Production-Defines[#ModuleName, #Defines, #SortName, #Prec, (PFK[#ParsedForm1, #Kind1];)],
  %n⟪
<«P-ProductionNameWithPrecText[#SortName,#Prec]»> ::= <«P-ProductionNameWithPrecText[#SortName,#Prec1]»> .
« {#DM} P-Production-Defines[#ModuleName, #Defines, #SortName, #Prec1, (PFK[#ParsedForm1, #Kind1];)] »⟫]
;

-[Data[#Prec1,#Prec],Share[#ParsedForm1,#Kind1,#Defines,#PFK,#PFKs]]:
{#DM} P-Production-Defines3[#ModuleName, #ParsedForm1, #Prec1, #Kind1, #Defines, #SortName, #Prec, (#PFK;#PFKs)]
→
$[If, $[NumericEqual,#Prec1,#Prec],
  {#DM} P-Production-Defines[#ModuleName, #Defines, #SortName, #Prec, Append[(#PFK;#PFKs), (PFK[#ParsedForm1, #Kind1];)]],
  %n⟪/***USERPG&EMBEDPG:
/* Productions for †«#SortName» sort with precedence †«$[FormatNumber,#Prec]». */
« {#DM} P-Expand[#ModuleName, (#PFK;#PFKs), #SortName, #Prec, B_FALSE] »
***/
« {#DM} P-Production-Defines[#ModuleName, #Defines, #SortName, #Prec1, (PFK[#ParsedForm1, #Kind1];)] »
⟫]
;

// Test if a sort has user HACS terms.

{#DM} P-then-SortHasHx[OK, #SortName] → {#DM} P-SortHasHx[#SortName] ;

-[Data[#SortName]]: {#DM} P-SortHasHx[#SortName] → {#DM} P-SortHasHx1[$[{#DM}Get, #SortName, DME_NONE]] ;

P-SortHasHx1[DME_SORT[#Defines, #SortName, #Precs, #Wrapper, #IsMain]] → P-DefinesHaveHx[#Defines] ;
P-SortHasHx1[$[NotMatch,DME_SORT[#Defines, #SortName, #Precs, #Wrapper, #IsMain],#_]] → B_FALSE ;

P-DefinesHaveHx[$List[Define]] :: Boolean;

-[Fresh[dummy::HxSortParam]]:
P-DefinesHaveHx[(D_ABSTRACTION[a.#Define1[a]]; #Defines)]
→
P-DefinesHaveHx[(#Define1[dummy]; #Defines)]
;

P-DefinesHaveHx[(D_RULE[#Rule, #RuleSort, #IsData]; #Defines)]
→
P-DefinesHaveHx[#Defines]
;

P-DefinesHaveHx[(D_FORM[Hx_FormConstruction[#1, #2, #3], #Kind1]; #Defines)]
→
B_TRUE
;

P-DefinesHaveHx[(D_FORM[$[NotMatch,Hx_FormConstruction[#1, #2, #3], #_], #Kind1]; #Defines)]
→
P-DefinesHaveHx[#Defines]
;

P-DefinesHaveHx[(D_SYNTHESIZES[#AttributeName1]; #Defines)]
→
P-DefinesHaveHx[#Defines]
;

P-DefinesHaveHx[(D_NONE; #Defines)]
→
P-DefinesHaveHx[#Defines]
;

P-DefinesHaveHx[()]
→
B_FALSE
;

{$String<!--SortName--> : DeclarationMapEntry} P-MetaJJ-Production-Defines[$String<!--<ModuleName-->, $List[Define], $String<!--SortName-->, Boolean<!--HasHxConstructors-->] :: Text;

{#DM}
P-MetaJJ-Production-Defines[#ModuleName, #Defines, #SortName, B_TRUE]
→
%n⟪
/* <†«#SortName»> covers Hacs terms prerestricted to †«#SortName» user sort (including user naked terms). */
net.sf.crsx.Sink N_†«#SortName»$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) : {}{ sink=N_†«#SortName»(sink, env) <EOF> {return sink;} }
net.sf.crsx.Sink N_†«#SortName»(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{String savedSort;}{
  (
    sink=N_†«#SortName»_Construction(sink, env)
  |
    {savedSort = storedSort; storedSort = "†«#SortName»";}
    (  « JJ-Nonterminal[%n⟨sink⟩, %n⟨PresortedVariable⟩, e.e] »
    |  « JJ-Nonterminal[%n⟨sink⟩, %n⟨PresortedMetaApplication⟩, e.e] »
    |  « JJ-Nonterminal[%n⟨sink⟩, %n⟨PresortedParsed⟩, e.e] »
    | "†«#SortName»"
      (  « JJ-Nonterminal[%n⟨sink⟩, %n⟨PresortedVariable⟩, e.e] »
      |  « JJ-Nonterminal[%n⟨sink⟩, %n⟨Construction⟩, e.e] »
      |  « JJ-Nonterminal[%n⟨sink⟩, %n⟨PresortedMetaApplication⟩, e.e] »
      |  « JJ-Nonterminal[%n⟨sink⟩, %n⟨PresortedParsed⟩, e.e] »
    ))
    {storedSort = savedSort;}
  )
  {return sink;}
}

/* <†«#SortName»_Construction> covers just Hacs user terms of †«#SortName» sort. */
net.sf.crsx.Sink N_†«#SortName»_Construction$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) : {}{ sink=N_†«#SortName»_Construction(sink, env) <EOF> {return sink;} }
net.sf.crsx.Sink N_†«#SortName»_Construction(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}{⟦
« {#DM} P-MetaJJ-Production-Defines1[#ModuleName, #Defines, #SortName, "("] »
)
{return sink;}⟧
}
⟫;

{#DM}
P-MetaJJ-Production-Defines[#ModuleName, #Defines, #SortName, B_FALSE]
→
%n⟪
/* <†«#SortName»> covers Hacs terms restricted to †«#SortName» user sort (no naked terms). */
net.sf.crsx.Sink N_†«#SortName»$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) : {}{ sink=N_†«#SortName»(sink, env) <EOF> {return sink;} }
net.sf.crsx.Sink N_†«#SortName»(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{String savedSort;}{
  {savedSort = storedSort; storedSort = "†«#SortName»";}
  ( "†«#SortName»" )?
  ( « JJ-Nonterminal[%n⟨sink⟩, %n⟨PresortedVariable⟩, e.e] »
  | « JJ-Nonterminal[%n⟨sink⟩, %n⟨PresortedMetaApplication⟩, e.e] »
  | « JJ-Nonterminal[%n⟨sink⟩, %n⟨PresortedParsed⟩, e.e] »
  )
  {storedSort = savedSort;}
  {return sink;}
}
⟫;

//

{$String<!--SortName--> : DeclarationMapEntry} P-MetaJJ-Production-Defines1[$String<!--ModuleName-->, $List[Define], $String<!--SortName-->, $String<!--lead-->] :: Text;

-[Fresh[dummy::HxSortParam]]:
{#DM} P-MetaJJ-Production-Defines1[#ModuleName, (D_ABSTRACTION[a.#Define1[a]]; #Defines), #SortName, #lead]
→
{#DM} P-MetaJJ-Production-Defines1[#ModuleName, (#Define1[dummy]; #Defines), #SortName, #lead]
;

{#DM} P-MetaJJ-Production-Defines1[#ModuleName, (D_RULE[#Rule, #RuleSort, #IsData]; #Defines), #SortName, #lead]
→
{#DM} P-MetaJJ-Production-Defines1[#ModuleName, #Defines, #SortName, #lead]
;

{#DM} P-MetaJJ-Production-Defines1[#ModuleName, (D_FORM[#Form1, #Kind1]; #Defines), #SortName, #lead]
→
{#DM} P-MetaJJ-Production-HxForm[#ModuleName, #Form1, #Kind1, #SortName, #lead, lead.{#DM} P-MetaJJ-Production-Defines1[#ModuleName, #Defines, #SortName, lead]]
;

{#DM} P-MetaJJ-Production-Defines1[#ModuleName, (D_SYNTHESIZES[#AttributeName1]; #Defines), #SortName, #lead]
→
{#DM} P-MetaJJ-Production-Defines1[#ModuleName, #Defines, #SortName, #lead]
;

{#DM} P-MetaJJ-Production-Defines1[#ModuleName, (), #SortName, #lead]
→
%n⟪⟫
;

{$String<!--SortName--> : DeclarationMapEntry} P-MetaJJ-Production-HxForm[HxForm, FormKind, $String<!--SortName-->, $String<!--lead-->, l::$String . Text] :: Text;
{#DM} P-MetaJJ-Production-HxForm[#ModuleName, Hx_FormParsedSorted[#Sort1, #ParsedForm1, #Prec1, #InheritedRefs], #Kind1, #SortName, #lead, lead.#[lead]] → #[#lead] ;
{#DM} P-MetaJJ-Production-HxForm[#ModuleName, Hx_FormParsed[#ParsedForm1, #Prec1, #InheritedRefs], #Kind1, #SortName, #lead, lead.#[lead]] → #[#lead] ;
{#DM} P-MetaJJ-Production-HxForm[#ModuleName, Hx_FormConstruction[#Constructor, #ScopeSortList, #InheritedRefs], #Kind1, #SortName, #lead, lead.#[lead]]
→
%n⟪†«#lead» (⟦ « {#DM} P-MetaJJ-Production-HxFormConstruction[#ModuleName, #SortName, #Constructor, #ScopeSortList] » ⟧)
« #["|"] »⟫
;

    {$String<!--SortName--> : DeclarationMapEntry} P-MetaJJ-Production-HxFormConstruction[$String<!--ModuleName-->, $String<!--SortName-->, $String<!--Constructor-->, $List[HxScopeSort]] :: Text ;
    {#DM} P-MetaJJ-Production-HxFormConstruction[#ModuleName, #SortName, #Constructor, #ScopeSortList]
    →
    TextJoin[(%n⟨ "†« #Constructor »" ⟩;
      JJ-Construction[%n⟨hx("ConstructionSorted")⟩, TextJoin[(
        JJ-StringLiteral[%n⟨"†« #SortName »"⟩];
        JJ-Construction[%n⟨hx("RepeatSingle")⟩, %n⟨⟩];
        JJ-StringLiteral[%n⟨"†« #Constructor »"⟩];
        IfEmpty[#ScopeSortList,
          TextConcat[%n⟨(<T_HX_LPAREN> <T_HX_RPAREN>)? ⟩, JJ-Construction[%n⟨"$Nil"⟩, %n⟨⟩]],
          %n⟨<T_HX_LPAREN> ‹ {#DM} P-MetaJJ-Production-HxScopeSortList[#ModuleName, #ScopeSortList, #SortName, B_TRUE] › <T_HX_RPAREN>⟩];
        JJ-Nonterminal[%n⟨sink⟩, %n⟨HxAttributes⟩, e.e];),%n⟨ ⟩]];),
      %n⟨ ⟩]
    ;

    {$String<!--SortName--> : DeclarationMapEntry} P-MetaJJ-Production-HxScopeSortList[$List[HxScopeSort], $String<!--SortName-->, Boolean<!--First-->] :: Text;

    {#DM} P-MetaJJ-Production-HxScopeSortList[#ModuleName, (%rawHxScopeSort⟪ #HxSort# #HxRepeat# [ #HxSubstituteSorts# ] ⟫ ; #ScopeSortList), #SortName, #first]
    →
    TextConcat[If[#first, %n⟨ ⟩, %n⟨ <T_HX_COMMA> ⟩],
      JJ-Construction[%n⟨"$Cons"⟩,
        %n⟨‹ {#DM} P-MetaJJ-Production-HxScopeSort[#ModuleName, #HxSort#, #HxSubstituteSorts#, #SortName]
› ‹ {#DM} P-MetaJJ-Production-HxScopeSortList[#ModuleName, #ScopeSortList, #SortName, B_FALSE] ›⟩]]
    ;  //note: ignores #Repeat because arguments to Hx terms cannot use repeat-forms...or should they?

    -[Free[v::Text]]:
    {#DM} P-MetaJJ-Production-HxScopeSortList[#ModuleName, (%rawHxBindersScopeSort⟪ [#HxSort# binds v] #HxBindersScopeSort# ⟫ ; #ScopeSortList), #SortName, #first]
    →
    {#DM} P-MetaJJ-Production-HxScopeSortList[#ModuleName, (#HxBindersScopeSort# ; #ScopeSortList), #SortName, #first]
    ;

    -[Free[v::Text]]:
    {#DM} P-MetaJJ-Production-HxScopeSortList[#ModuleName, (%rawHxScopeSort⟪ #HxSort# binds v ⟫ ; #ScopeSortList), #SortName, #first]
    →
    $[Error, "There should not be binder subterm sorts."]
    ;

    {#DM} P-MetaJJ-Production-HxScopeSortList[#ModuleName, (), #SortName, #first] → JJ-Construction[%n⟪"$Nil"⟫, %n⟪⟫] ;


    {$String<!--SortName--> : DeclarationMapEntry} P-MetaJJ-Production-HxScopeSort[HxSort, $List[HxSubstituteSort], $String] :: Text;

    {#DM} P-MetaJJ-Production-HxScopeSort[#ModuleName, #HxSort#, #HxSubstituteSorts#, #SortName]
    →
    IfEmpty[#HxSubstituteSorts#,
      JJ-Nonterminal[%n⟪sink⟫, %n⟪†«U-SortName[#HxSort#]»⟫, e.e],
      {#DM}P-MetaJJ-Production-HxScope[#ModuleName, #HxSubstituteSorts#, %n⟨sink=N_†‹U-SortName[#HxSort#]›(sink, env)⟩, %n⟨⟩, %n⟨<T_HX_LBRACKET>⟩, %n⟨[⟩]]
    ;

    {$String<!--SortName--> : DeclarationMapEntry} P-MetaJJ-Production-HxScope[$String<!--ModuleName-->, $List[HxSubstituteSort], Text<!--SortRef-->, Text<!--ScopedVars-->, Text<!--Sep-->, Text<!--ArgSep-->] :: Text;

    -[Fresh[x::Text]]:
    {#DM}P-MetaJJ-Production-HxScope[#ModuleName, (#SubstituteSort ; #SubstituteSorts), #SortRef, #ScopedVars, #sep, #argsep]
    →
    %n⟪MISSING[ «#sep» HX_VARIABLE^«x» « {#DM}P-MetaJJ-Production-HxScope[#ModuleName, #SubstituteSorts, #SortRef, %n⟨‹#ScopedVars›‹#argsep›‹x›⟩, %n⟨<T_HX_COMMA>⟩, %n⟨,⟩] »]MISSING⟫
    ;

    {#DM}P-MetaJJ-Production-HxScope[#ModuleName, (), #SortRef, #ScopedVars, #sep, #argsep] → %n⟪ <HX_RBRACKET> « #SortRef »« #ScopedVars »]⟫ ;

// Meta-definitions for sorts.

{$String<!--SortName--> : DeclarationMapEntry} P-Embed-Head[Boolean<!--Last?-->, $String<!--ModuleName-->, $String, $String, Boolean<!--LeftRecursive?-->, $Numeric<!--Prec-->] :: Text;

P-Embed-Head[B_FALSE, #ModuleName, #SortName, #Name, #isLeftRecursive, #Prec] → %n⟪⟫ ;

-[Data[#SortName],Discard[#Prec]]:
{#DM}
P-Embed-Head[B_TRUE, #ModuleName, #SortName, #Name, B_FALSE, #Prec] →
 %n⟪
meta_« P-TokenNameText[#Name] »$$:unwrap:{†« P-Meta-Prefix[#ModuleName] »SortedTerm} |
⟫ ;

-[Data[#SortName]]:
{#DM}
P-Embed-Head[B_TRUE, #ModuleName, #SortName, #Name, B_TRUE, #Prec] →
 %n⟪
meta_« P-TokenNameText[#Name] »$$:unwrap:{†« P-Meta-Prefix[#ModuleName] »SortedTerm}:#1 <« P-ProductionNameWithPrecText[#SortName, #Prec] »LR #1> |
⟫ ;


P-Embed-Tail[Boolean, $String, $String] :: Text;

P-Embed-Tail[B_FALSE, #SortName, #Name] → %n⟪⟫ ;

-[Data[#SortName]]: P-Embed-Tail[B_TRUE, #SortName, #Name] → %n⟪
%{
/* Meta token for embedded user †«#SortName». */ 
MORE : { < "\u27e8" (" ")* †« Stringify[#SortName] » (" ")* ~["\u27e8","\u27e9"] > { nesting = 0; nestedState = curLexState; } : IN_META_«P-TokenNameText[#Name]» }
<IN_META_«P-TokenNameText[#Name]»> MORE : { "\u27e8" { nesting = 1; } : IN_NESTED_META_«P-TokenNameText[#Name]» }
<IN_NESTED_META_«P-TokenNameText[#Name]»> MORE : { "\u27e8" { nesting++; } }
<IN_NESTED_META_«P-TokenNameText[#Name]»> MORE : { "\u27e9" { if (--nesting <= 0) SwitchTo(IN_META_«P-TokenNameText[#Name]»); } }
<IN_META_«P-TokenNameText[#Name]»> TOKEN : { < T_meta_«P-TokenNameText[#Name]» : "\u27e9" > { SwitchTo(nestedState); } }
<IN_META_«P-TokenNameText[#Name]»,IN_NESTED_META_«P-TokenNameText[#Name]»> MORE : { < ~[] > }
%}
⟫ ;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 6. GENERATE SINGLE SORT/PRECEDENCE COMBINATION.
//
// Text of single sort+precedence production expansion.
//
// Emits the left recursion handler, if any, and the P grammar production
// for the sort+precedence combination, with left factored buffering.

CONSUMPTION_SORT ::=( C_BUFFER[$String<!--SortName-->, $Numeric<!--precedence-->]; C_LEFTRECURSIVE[$String<!--SortName-->, $Numeric<!--precedence-->]; <!--C_INLINE;--> );
/// C_INLINE DISABLED.

{$String<!--SortName--> : DeclarationMapEntry} P-Expand[$List[PFK_SORT], $String, $Numeric, Boolean<!--Last-->] :: Text;
{#DM} P-Expand[#ModuleName, #PrecPFKs, #SortName, #Prec, #Last?]
→
{#DM} P-LeftRecursive[#ModuleName, #PrecPFKs, #SortName, #Prec, #Last?, (), ()]
;

// Generate optional left recursion production helper, normal production, and optional meta-production.

{$String<!--SortName--> : DeclarationMapEntry} P-LeftRecursive[$List[PFK_SORT], $String, $Numeric, Boolean, $List[PFK_SORT], $List[PFK_SORT]] :: Text;
{$String<!--SortName--> : DeclarationMapEntry} P-LeftRecursive2[Boolean, PFK_SORT, $List[PFK_SORT], $String, $Numeric, Boolean, $List[PFK_SORT], $List[PFK_SORT]] :: Text;

{#DM} P-LeftRecursive[#ModuleName, (#PFK1; #PFKs), #SortName, #Prec, #Last?, #LeftRecursivePFKs, #OtherPFKs]
→
{#DM} P-LeftRecursive2[#ModuleName, P-isLeftRecursive[#SortName, #Prec, #PFK1], #PFK1, #PFKs, #SortName, #Prec, #Last?, #LeftRecursivePFKs, #OtherPFKs]
;

    // HAND-CODED HACK to recognize and strip left recursive production (because Hx.pg cannot match parsed forms...).

    P-isLeftRecursive[$String, $Numeric, PFK_SORT] :: Boolean;

    P-isLeftRecursive[#SortName, #Prec, PFK[Hx_ParsedFormSpace[#Space, #ParsedForm1], #Kind]]
    →
    P-isLeftRecursive[#SortName, #Prec, PFK[#ParsedForm1, #Kind]]
    ;

    P-isLeftRecursive[#SortName, #Prec, PFK[Hx_ParsedFormWord[#Word, #ParsedForm1], #Kind]]
    →
    B_FALSE
    ;

    -[Data[#Sort]]:
    P-isLeftRecursive[#SortName, #Prec, PFK[Hx_ParsedFormTerm[Hx_ScopeSortPrecRepeat[#Sort1, #Prec1, #Repeat1], #ParsedForm1], #Kind]]
    →
    $[If, $[NumericEqual,#Prec,#Prec1], P-isLeftRecursive1[#SortName, #Sort1], B_FALSE]
    ;

    P-isLeftRecursive[#SortName, #Prec, PFK[Hx_ParsedFormDone, #Kind]]
    →
    B_FALSE
    ;

    P-isLeftRecursive1[$String, HxScopeSort] :: Boolean;

    P-isLeftRecursive1[#SortName,
      Hx_ScopeSort[
	Hx_Sort[Hx_SortName[#SortName1, #_1], '$Nil'],
	Hx_RepeatSingle,
	'$Nil']]
    →
    SameString[#SortName,#SortName1]
    ;

    -[Data[#Kind]]:
    P-isLeftRecursive1[#SortName, $[NotMatch,
      Hx_ScopeSort[
	Hx_Sort[Hx_SortName[#SortName1, #_1], '$Nil'],
	Hx_RepeatSingle,
	'$Nil'],#_]]
    →
    B_FALSE
    ;

    P-stripLeftRecursion[PFK_SORT] :: PFK_SORT;
    P-stripLeftRecursion[PFK[Hx_ParsedFormSpace[#Space, #ParsedForm1], #Kind]]
    →
    P-stripLeftRecursion[PFK[#ParsedForm1, #Kind]]
    ;
    P-stripLeftRecursion[
      PFK[
	Hx_ParsedFormTerm[
	  Hx_ScopeSortPrecRepeat[
	    Hx_ScopeSort[
	      Hx_Sort[Hx_SortName[#SortName, #_], '$Nil'],
	      Hx_RepeatSingle,
	      '$Nil'],
	    #Prec,
	    #Repeat],
	      #ParsedForm],
	#Kind]]
    →
    PFK[#ParsedForm, #Kind]
    ;

{#DM} P-LeftRecursive2[#ModuleName, B_TRUE, #PFK1, #PFKs, #SortName, #Prec, #Last?, #LeftRecursivePFKs, #OtherPFKs]
→
{#DM} P-LeftRecursive[#ModuleName, #PFKs, #SortName, #Prec, #Last?, Append[#LeftRecursivePFKs, (P-stripLeftRecursion[#PFK1];)], #OtherPFKs]
;

{#DM} P-LeftRecursive2[#ModuleName, B_FALSE, #PFK1, #PFKs, #SortName, #Prec, #Last?, #LeftRecursivePFKs, #OtherPFKs]
→
{#DM} P-LeftRecursive[#ModuleName, #PFKs, #SortName, #Prec, #Last?, #LeftRecursivePFKs, Append[#OtherPFKs, (#PFK1;)]]
;

{#DM} P-LeftRecursive[#ModuleName, (), #SortName, #Prec, #Last?, #LeftRecursivePFKs, #OtherPFKs]
→
IfEmpty[#LeftRecursivePFKs,
  // There is no left recursion -- use the plain expansion.
  {#DM} P-Produce[#ModuleName, #SortName, #Prec, #Last?, #OtherPFKs, C_BUFFER[#SortName, #Prec]],
  // There is left recursion...
  {#DM} P-ProduceBody[#ModuleName, #SortName, #LeftRecursivePFKs, 2, (), (%n⟨#1⟩;), (%n⟨#1⟩;), C_LEFTRECURSIVE[#SortName, #Prec], in funs tags after .
    %n⟪
/***USERPG&EMBEDPG:
/* Handle left recursion. */
<«P-ProductionNameWithPrecText[#SortName, #Prec]»LR #1> ::= ⟦
/***EMBEDPG: « {#DM}P-Embed-Head[#Last?, #ModuleName, #SortName, #SortName, B_FALSE, 0] »***/
«in»
| {{#1}}⟧
. ***/
/***SORTS: †«U-QN[#ModuleName, "NodeSort", #SortName]» ::= ( «tags» ); ***/

«funs»
« TextJoinMap[after, %n⟨
⟩] »
« {#DM} P-Produce[#ModuleName, #SortName, #Prec, #Last?, #OtherPFKs, C_LEFTRECURSIVE[#SortName, #Prec]] »⟫]]
;

// 

{$String<!--SortName--> : DeclarationMapEntry} P-Produce[$String<!--ModuleName-->, $String<!--SortName-->, $Numeric<!--Prec-->, Boolean<!--Last?-->, $List[PFK_SORT], CONSUMPTION_SORT] :: Text;

{#DM} P-Produce[#ModuleName, #SortName, #Prec, #Last?, #PFKs, C_LEFTRECURSIVE[#SortName9, #Prec9]]
→
{#DM} P-ProduceBody[#ModuleName, #SortName, #PFKs, 1, (), (), (), C_LEFTRECURSIVE[#SortName9, #Prec9], in funs tags after .
  %n⟪
/***USERPG&EMBEDPG:
<«P-ProductionNameWithPrecText[#SortName, #Prec]»> ::= ⟦
«in»⟧ .
***/

/***SORTS: †«U-QN[#ModuleName, "NodeSort", #SortName]» ::= ( «tags» ); ***/
«funs»
/***EMBEDPG:
« {#DM}P-Embed-Tail[#Last?, #SortName, #SortName] »« TextJoinMap[after, %n⟨
⟩] »
***/
⟫]
;

-[Data[#consumer]]:
{#DM} P-Produce[#ModuleName, #SortName, #Prec, #Last?, #PFKs, $[NotMatch,C_LEFTRECURSIVE[#_SortName, #_Prec],#consumer]]
→
{#DM} P-ProduceBody[#ModuleName, #SortName, #PFKs, 1, (), (), (), #consumer, in funs tags after .
  %n⟪
/***USERPG&EMBEDPG:
<«P-ProductionNameWithPrecText[#SortName,#Prec]»> ::= ⟦
/***EMBEDPG: « {#DM}P-Embed-Head[#Last?, #ModuleName, #SortName, #SortName, B_FALSE, 0] »***/
«in»⟧ .
***/

« P-TagSortDeclaration[#ModuleName, #SortName, funs, tags] »
/***EMBEDPG:
« {#DM}P-Embed-Tail[#Last?, #SortName, #SortName] »« TextJoinMap[after, %n⟨
⟩] »
***/
⟫]
;


P-TagSortDeclaration[#ModuleName, #SortName, #funs, #tags]
→
%n⟪
/***SORTS: †«U-QN[#ModuleName, "TagSort", #SortName]» ::= ( « #tags » ); ***/
«#funs»⟫
;

{$String<!--SortName--> : DeclarationMapEntry} P-ProduceBody[$String<!--ModuleName-->, $String<!--HostSort-->, $List[PFK_SORT], $Numeric<!--ArgIndex-->, $List[Text]<!--Words-->, $List[Text]<!--Naked-->, $List[Text]<!--Terms-->, CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

-[Data[#PFKs]]:
{#DM} P-ProduceBody[#ModuleName, #SortName, #PFKs, #n, #words, #naked, #terms, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} P-ProduceBody1[#ModuleName, #SortName, #PFKs, #n, #words, #naked, #terms, #consumer, in funs tags after . #[in,funs,tags,after]]
;

// Pick branching kind.

{$String<!--SortName--> : DeclarationMapEntry} P-ProduceBody1[$String<!--ModuleName-->, $String<!--HostSort-->, $List[PFK_SORT], $Numeric<!--ArgIndex-->, $List[Text]<!--Words-->, $List[Text]<!--Naked-->, $List[Text]<!--Terms-->, CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

{#DM} P-ProduceBody1[#ModuleName, #SortName, (), #n, #words, #naked, #terms, #consumer, in funs tags after . #[in,funs,tags,after]]
→
#[%n⟪⟫, %n⟪⟫, %n⟪⟫, EmptyTextMap]
;

{#DM} P-ProduceBody1[#ModuleName, #SortName, (PFK[Hx_ParsedFormWord[#word, #ParsedForm], #Kind]; #Rest), #n, #words, #naked, #terms, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} P-ProduceBodyWord1[#ModuleName, #SortName, #Rest, (), #word, (PFK[#ParsedForm, #Kind];), #n, #words, #naked, #terms, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{#DM} P-ProduceBody1[#ModuleName, #SortName, (PFK[Hx_ParsedFormTerm[Hx_ScopeSortPrecRepeat[#ScopeSort, #Prec, #Repeat], #ParsedForm], #Kind]; #Rest), #n, #words, #naked, #terms, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} P-ProduceBodyTerm1[#ModuleName, #SortName, #Rest, (), #ScopeSort, #Prec, #Repeat, #Kind, (PFK[#ParsedForm, #Kind];), #n, #words, #naked, #terms, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{#DM} P-ProduceBody1[#ModuleName, #SortName, (PFK[Hx_ParsedFormSpace[#space, #ParsedForm], #Kind]; #Rest), #n, #words, #naked, #terms, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} P-ProduceBody1[#ModuleName, #SortName, (PFK[#ParsedForm, #Kind]; #Rest), #n, #words, #naked, #terms, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{#DM} P-ProduceBody1[#ModuleName, #SortName, (PFK[Hx_ParsedFormDone, #Kind]; #Rest), #n, #words, #naked, #terms, C_BUFFER[#SortName, #Prec], in funs tags after . #[in,funs,tags,after]]
→
{#DM} P-ProduceBody2[#ModuleName, #SortName, #Rest, #n, #words, #naked, #terms, C_BUFFER[#SortName, #Prec], in funs tags after . #[in,funs,tags,after],
  P-AttributeCollection[#ModuleName, #Kind, #SortName, #Prec, P-ProductionConstructionText[#ModuleName, #SortName, #Prec, #Kind, #words, #naked, #terms], B_FALSE],
  P-ProductionSortFunsText[#ModuleName, #SortName, #Prec, #Kind, #words, #naked, #terms],
  P-ProductionSortTagsText[#ModuleName, #SortName, #Prec, #Kind, #words, #naked, #terms],
  P-AttributeProduction[#ModuleName, #Kind, #SortName, #Prec, B_FALSE]]
;

{#DM} P-ProduceBody1[#ModuleName, #SortName, (PFK[Hx_ParsedFormDone, #Kind]; #Rest), #n, #words, #naked, #terms, C_LEFTRECURSIVE[#SortName, #Prec], in funs tags after . #[in,funs,tags,after]]
→
{#DM} P-ProduceBody2[#ModuleName, #SortName, #Rest, #n, #words, #naked, #terms, C_LEFTRECURSIVE[#SortName, #Prec], in funs tags after . #[in,funs,tags,after],
  P-AttributeCollection[#ModuleName, #Kind, #SortName, #Prec, P-ProductionConstructionText[#ModuleName, #SortName, #Prec, #Kind, #words, #naked, #terms], B_TRUE],
  P-ProductionSortFunsText[#ModuleName, #SortName, #Prec, #Kind, #words, #naked, #terms],
  P-ProductionSortTagsText[#ModuleName, #SortName, #Prec, #Kind, #words, #naked, #terms],
  P-AttributeProduction[#ModuleName, #Kind, #SortName, #Prec, B_TRUE]]
;

{$String<!--SortName--> : DeclarationMapEntry} P-ProduceBody2[$String<!--ModuleName-->, $String<!--HostSort-->, $List[PFK_SORT], $Numeric, $List[Text], $List[Text], CONSUMPTION_SORT, in::Text after::TextMapSort.Text, Text, TextMapSort] :: Text;
-[Data[#in2,#sort2,#after2]]:
{#DM} P-ProduceBody2[#ModuleName, #SortName, #Rest, #n, #words, #naked, #terms, #consumer, in funs tags after . #[in,funs,tags,after], #in2, #funs2, #tags2, #after2]
→
{#DM} P-ProduceBody1[#ModuleName, #SortName, #Rest, #n, #words, #naked, #terms, #consumer, in funs tags after . #[%n⟪« #in2 »«in»⟫, %n⟪« #funs2 »«funs»⟫, %n⟪« #tags2 »«tags»⟫, JoinTextMaps[#after2, after]]]
;

P-AttributeCollection[FormKind, $String, $Numeric, Text, Boolean] :: Text;

P-AttributeCollection[#ModuleName, #Kind, #SortName, #Prec, #Construct, B_FALSE] → #Construct ;
P-AttributeCollection[#ModuleName, #Kind, #SortName, #Prec, #Construct, B_TRUE] → %n⟪<«P-ProductionNameWithPrecText[#SortName,#Prec]»LR «#Construct»>⟫ ;

P-AttributeProduction[FormKind, $String, $Numeric, Boolean] :: TextMapSort;
P-AttributeProduction[#ModuleName, #dontcare, #SortName, #Prec, #IsLeftRecursive]
→
EmptyTextMap //TODO: eliminate?
;

P-ProductionSortFunsText[$String<!--ModuleName-->, $String, $Numeric, FormKind, $List[Text]<!--Words-->, $List[Text]<!--Naked-->, $List[Text]<!--Terms-->] :: Text;

-[Data[#SortName,#Prec],Data[#words]]:
P-ProductionSortFunsText[#ModuleName, #SortName, #Prec, #scheme, #words, #naked, #terms]
→
%n⟪
/***METAELIM: †«U-QN[#ModuleName, "Node", #SortName]»[†« U-QN[#ModuleName, "Tag", StringJoin[(P-ProductionNameWithPrec[#SortName, #Prec]; IfEmpty[#words, "EMPTY", MapWhen[ok x.TextToStringWhen[ok, x], #words]]), "_"]] »« WrappedTextJoin[#terms, %n⟨, (⟩, %n⟨; ⟩, %n⟨;)⟩] »]; ***/
⟫;

P-ProductionSortTagsText[$String<!--ModuleName-->, $String, $Numeric, FormKind, $List[Text], $List[Text]] :: Text;

-[Data[#SortName,#Prec],Data[#words]]:
P-ProductionSortTagsText[#ModuleName, #SortName, #Prec, #scheme, #words, #naked, #terms]
→
%n⟪ †« U-QN[#ModuleName, #SortName, StringJoin[(P-ProductionNameWithPrec[#SortName, #Prec]; IfEmpty[#words, "EMPTY", MapWhen[ok x.TextToStringWhen[ok, x], #words]]), "_"]] »; ⟫
;

// Generate P instructions to construct a result term.

P-ProductionConstructionText[$String<!--ModuleName-->, $String, $Numeric, FormKind, $List[Text]<!--Words-->, $List[Text]<!--Naked-->, $List[Text]<!--Terms-->] :: Text;

-[Data[#SortName,#Prec],Data[#words]]:
P-ProductionConstructionText[#ModuleName, #SortName, #Prec, FK_SCHEME[#tag, #Inh], #words, #naked, #terms]
→
%n⟪⟦ {{ « P-CRSX-GenerateConstructionTerm[#ModuleName, #SortName, #Prec, #words, #naked, #terms] » }}⟧
⟫
;

-[Data[#SortName,#Prec],Data[#words]]:
P-ProductionConstructionText[#ModuleName, #SortName, #Prec, FK_SUGAR[#Inh], #words, #naked, #terms]
→
%n⟪ {{ « WrappedTextJoin[#terms, %n⟨⟩, %n⟨ ⟩, %n⟨⟩] » }}
⟫
;
//TODO:  FIX COMPOSITE SUGAR!

-[Data[#SortName,#Prec,#Kind],Data[#words]]:
P-ProductionConstructionText[#ModuleName, #SortName, #Prec, $[NotMatch,FK_SCHEME[#tag, #_Inh],$[NotMatch,FK_SUGAR[#_term],#Kind]], #words, #naked, #terms]
→
IfAliasKind[#Kind, WrappedTextJoin[#naked, %n⟨ {{⟩, %n⟨ ⟩, %n⟨}}⟩],
  %n⟪ ⟦ {{ « P-CRSX-GenerateConstructionTerm[#ModuleName, #SortName, #Prec, #words, #naked, #terms] » }}⟧
⟫]
;

    ∀ a . IfAliasKind[FormKind, a, a] :: a;
    IfAliasKind[FK_ALIAS, #1, #2] → #1 ;
    IfAliasKind[FK_SYMBOL[#IsStatic, #t], #1, #2] → #1 ;
    -[Data[#Kind]]: IfAliasKind[$[NotMatch,FK_ALIAS,$[NotMatch,FK_SYMBOL[#IsStatic, #t],#Kind]], #1, #2] → #2 ;

//

P-CRSX-GenerateConstructionTerm[#ModuleName, #SortName, #Prec, #words, #naked, #terms]
→
%n⟪/***USERPG: '†« U-QN[#ModuleName, #SortName, IfEmpty[#words, "EMPTY", MapStringConcatWhen[ok x.TextToStringWhen[ok, x], #words]]] »'« WrappedTextJoin[#terms, %n⟨[⟩, %n⟨, ⟩, %n⟨]⟩] » ***/
/***EMBEDPG: †« P-hx[#ModuleName, "ConstructionSorted"] »["†«#SortName»", "†« P-hx[#ModuleName, "RepeatSingle"] »",
  "†« U-QN[#ModuleName, #SortName, IfEmpty[#words, "EMPTY", MapStringConcatWhen[ok x.TextToStringWhen[ok, x], #words]]] »", «
    WrappedTextJoin[Map[t.%n⟨‹t›;⟩, #terms], %n⟨(⟩, %n⟨⟩, %n⟨)⟩]
  », ()] ***/
⟫
;
// WrappedTextJoin[#terms, %n⟨,⟩, %n⟨, ⟩, %n⟨]⟩]

// (1) Constant Token Case: (a) collect productions starting with the constant token and ...

{$String<!--SortName--> : DeclarationMapEntry} P-ProduceBodyWord1[$String<!--ModuleName-->, $String<!--HostSort-->, $List[PFK_SORT], $List[PFK_SORT], $String, $List[PFK_SORT], $Numeric<!--ArgIndex-->, $List[Text]<!--Words-->, $List[Text]<!--Naked-->, $List[Text]<!--Terms-->, CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

-[Data[#word1,#word],Share[#ParsedForm1,#Kind1,#Rest,#wordPFKs,#n,#terms,#words,#consumer]]:
{#DM} P-ProduceBodyWord1[#ModuleName, #SortName, (PFK[Hx_ParsedFormWord[#word1, #ParsedForm1], #Kind1]; #Rest), #Failed, #word, #wordPFKs, #n, #words, #naked, #terms, #consumer, in funs tags after . #[in,funs,tags,after]]
→
$[If, $[Equal, #word, #word1],
  {#DM} P-ProduceBodyWord1[#ModuleName, #SortName, #Rest, #Failed, #word, Append[#wordPFKs, (PFK[#ParsedForm1, #Kind1];)], #n, #words, #naked, #terms, #consumer, in funs tags after . #[in,funs,tags,after]],
  {#DM} P-ProduceBodyWord1[#ModuleName, #SortName, #Rest, Append[#Failed, (PFK[Hx_ParsedFormWord[#word1, #ParsedForm1], #Kind1];)], #word, #wordPFKs, #n, #words, #naked, #terms, #consumer, in funs tags after . #[in,funs,tags,after]]]
;

{#DM} P-ProduceBodyWord1[#ModuleName, #SortName, (PFK[Hx_ParsedFormTerm[#ScopeSortPrecRepeat1, #ParsedForm1], #Kind]; #Rest), #Failed, #word, #wordPFKs, #n, #words, #naked, #terms, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} P-ProduceBodyWord1[#ModuleName, #SortName, #Rest, Append[#Failed, (PFK[Hx_ParsedFormTerm[#ScopeSortPrecRepeat1, #ParsedForm1], #Kind];)], #word, #wordPFKs, #n, #words, #naked, #terms, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{#DM} P-ProduceBodyWord1[#ModuleName, #SortName, (PFK[Hx_ParsedFormSpace[#space1, #ParsedForm1], #Kind1]; #Rest), #Failed, #word, #wordPFKs, #n, #words, #naked, #terms, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} P-ProduceBodyWord1[#ModuleName, #SortName, (PFK[#ParsedForm1, #Kind1]; #Rest), #Failed, #word, #wordPFKs, #n, #words, #naked, #terms, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{#DM} P-ProduceBodyWord1[#ModuleName, #SortName, (PFK[Hx_ParsedFormDone, #Kind]; #Rest), #Failed, #word, #wordPFKs, #n, #words, #naked, #terms, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} P-ProduceBodyWord1[#ModuleName, #SortName, #Rest, Append[#Failed, (PFK[Hx_ParsedFormDone, #Kind];)], #word, #wordPFKs, #n, #words, #naked, #terms, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{#DM} P-ProduceBodyWord1[#ModuleName, #SortName, (), #Failed, #word, #wordPFKs, #n, #words, #naked, #terms, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} P-ProduceBodyWord2[#ModuleName, #SortName, #Failed, #word, #wordPFKs, #n, #words, #naked, #terms, #consumer, in funs tags after . #[in,funs,tags,after]]
;

// ... (b) emit constant token branch.

{$String<!--SortName--> : DeclarationMapEntry} P-ProduceBodyWord2[$String<!--ModuleName-->, $String<!--HostSort-->, $List[PFK_SORT], $String, $List[PFK_SORT], $Numeric, $List[Text]<!--Words-->, $List[Text]<!--Naked-->, $List[Text]<!--Terms-->, CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

{#DM} P-ProduceBodyWord2[#ModuleName, #SortName, (), #word, #wordPFKs, #n, #words, #naked, #terms, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} P-ProduceBody[#ModuleName, #SortName, #wordPFKs, #n, Append[#words, (%n⟨†‹$[Escape[""],#word]›⟩;)], #naked, #terms, #consumer, in1 funs1 tags1 after1 . #[%n⟪« ProductionWord[#word] »⟦« in1 »⟧⟫, funs1, tags1, after1]]
;

{#DM} P-ProduceBodyWord2[#ModuleName, #SortName, (#PFK1;#PFKs), #word, #wordPFKs, #n, #words, #naked, #terms, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} P-ProduceBody[#ModuleName, #SortName, #wordPFKs, #n, Append[#words, (%n⟨†‹$[Escape[""],#word]›⟩;)], #naked, #terms, #consumer, in1 funs1 tags1 after1 .
  {#DM} P-ProduceBody[#ModuleName, #SortName, (#PFK1;#PFKs), #n, #words, #naked, #terms, #consumer, in2 funs2 tags2 after2 .
    #[%n⟪(« ProductionWord[#word] » « in1 »
| « in2 » ) ⟫, %n⟪«funs1»«funs2»⟫, %n⟪«tags1»«tags2»⟫, JoinTextMaps[after1, after2]]]]
;

    ProductionWord[$String] :: Text;
    ProductionWord[#word] → %n⟪†« Stringify[#word] »⟫ ;

// (2) Common Nonterminal: (a) collect productions starting with the nonterminal and...

{$String : DeclarationMapEntry} P-ProduceBodyTerm1[$String<!--ModuleName-->, $String<!--HostSort-->,
	$List[PFK_SORT], $List[PFK_SORT], HxScopeSort, $Numeric, HxRepeat, FormKind, $List[PFK_SORT], $Numeric, $List[Text]<!--Words-->, $List[Text]<!--Naked-->, $List[Text]<!--Terms-->, CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

{#DM} P-ProduceBodyTerm1[#ModuleName, #SortName, (PFK[Hx_ParsedFormWord[#word1, #ParsedForm1], #Kind1]; #Rest), #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #words, #naked, #terms, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} P-ProduceBodyTerm1[#ModuleName, #SortName, #Rest, Append[#Failed, (PFK[Hx_ParsedFormWord[#word1, #ParsedForm1], #Kind1];)], #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #words, #naked, #terms, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{#DM} P-ProduceBodyTerm1[#ModuleName, #SortName, (PFK[Hx_ParsedFormTerm[Hx_ScopeSortPrecRepeat[#ScopeSort1, #Prec1, #Repeat1], #ParsedForm1], #Kind1]; #Rest), #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #words, #naked, #terms, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} P-ProduceBodyTerm1x[#ModuleName, #SortName, P-SameScopeSort[#ScopeSort1, #Prec1, #Repeat1, #ScopeSort, #Prec, #Repeat], #ScopeSort1, #Prec1, #Repeat1, #ParsedForm1, #Kind1, #Rest, #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #words, #naked, #terms, #consumer, in funs tags after . #[in,funs,tags,after]]
;

    // Local test if two ScopeSorts are the same.

    P-SameScopeSort[HxScopeSort, $Numeric, HxRepeat, HxScopeSort, $Numeric, HxRepeat] :: Boolean;
    P-SameScopeSort[#Sort1, #Prec1, #Repeat1, #Sort2, #Prec2, #Repeat2] → P-SameScopeSort2[#Sort1, #Sort2, #Prec1, #Repeat1, #Prec2, #Repeat2] ;

    P-SameScopeSort2[HxScopeSort, HxScopeSort, $Numeric, HxRepeat, $Numeric, HxRepeat] :: Boolean;

    P-SameScopeSort2[%rawHxScopeSort⟪ #HxSort1# [ #HxSubstituteSorts1# ] ⟫, %rawHxScopeSort⟪ #HxSort2# [ #HxSubstituteSorts2# ] ⟫, #Prec1, #Repeat1, #Prec2, #Repeat2]
    →
    And[P-SameSort[#HxSort1#, #HxSort2#], And[P-SamePrec[#Prec1, #Prec2], P-SubRepeat[#Repeat1, #Repeat2]]]
    ;
    -[Free[v1::Text]]:
    P-SameScopeSort2[%rawHxScopeSort⟪ #HxSort1# binds v1 ⟫                , %rawHxScopeSort⟪ #HxSort2# [ #HxSubstituteSorts2# ] ⟫, #P1, #R1, #P2, #R2] → B_FALSE ;
    -[Free[v2::Text]]:
    P-SameScopeSort2[%rawHxScopeSort⟪ #HxSort1# [ #HxSubstituteSorts1# ] ⟫, %rawHxScopeSort⟪ #HxSort2# binds v2 ⟫, #P1, #R1, #P2, #R2] → B_FALSE ;
    -[Free[v1::Text,v2::Text]]:
    P-SameScopeSort2[%rawHxScopeSort⟪ #HxSort1# binds v1 ⟫                , %rawHxScopeSort⟪ #HxSort2# binds v2 ⟫, #P1, #R1, #P2, #R2] → P-SameSort[#HxSort1#, #HxSort2#] ;

    P-SameSort[HxSort, HxSort] :: Boolean;
    -[Data[#1,#2]]: P-SameSort[#1, #2] → P-SameSort2[#1, #2] ;

    P-SameSort2[HxSort, HxSort] :: Boolean;

    -[Data[#HxSortName1#,#HxSortName2#]]:
    P-SameSort2[%rawHxSort⟪ #HxSortName1# #HxMetaVariables1# #HxSimpleSorts1# ⟫, %rawHxSort⟪ #HxSortName2# #HxMetaVariables2# #HxSimpleSorts2# ⟫]
    →
    $[If, $[Equal, #HxSortName1#, #HxSortName2#], B_TRUE, B_FALSE]
    ;

    P-SameSort2[$[NotMatch,%rawHxSort⟪ #HxSortName1# #HxMetaVariables1# #HxSimpleSorts1# ⟫,#1], #2]
    →
    B_FALSE
    ;

    P-SameSort2[#1,$[NotMatch,%rawHxSort⟪ #HxSortName2# #HxMetaVariables2# #HxSimpleSorts2# ⟫,#2]]
    →
    B_FALSE
    ;

    P-SamePrec[$Numeric, $Numeric] :: Boolean;
    -[Data[#Prec1,#Prec2]]: P-SamePrec[#Prec1, #Prec2] → $[If, $[NumericEqual, #Prec1, #Prec2], B_TRUE, B_FALSE] ;

//

{#DM} P-ProduceBodyTerm1[#ModuleName, #SortName, (PFK[Hx_ParsedFormSpace[#space1, #ParsedForm1], #Kind1]; #Rest), #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #words, #naked, #terms, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} P-ProduceBodyTerm1[#ModuleName, #SortName, (PFK[#ParsedForm1, #Kind1]; #Rest), #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #words, #naked, #terms, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{#DM} P-ProduceBodyTerm1[#ModuleName, #SortName, (PFK[Hx_ParsedFormDone, #Kind1]; #Rest), #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #words, #naked, #terms, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} P-ProduceBodyTerm1[#ModuleName, #SortName, #Rest, Append[#Failed, (PFK[Hx_ParsedFormDone, #Kind1];)], #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #words, #naked, #terms, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{#DM} P-ProduceBodyTerm1[#ModuleName, #SortName, (), #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #words, #naked, #terms, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} P-ProduceBodyTerm2[#ModuleName, #SortName, #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #words, #naked, #terms, #consumer, in funs tags after . #[in,funs,tags,after]]
;

// ... helper to filter identical scope sorts...

{$String : DeclarationMapEntry}
P-ProduceBodyTerm1x[$String<!--ModuleName-->, $String<!--HostSort-->, Boolean, HxScopeSort, $Numeric, HxRepeat, HxParsedForm, FormKind,
	$List[PFK_SORT], $List[PFK_SORT], HxScopeSort, $Numeric, HxRepeat, FormKind, $List[PFK_SORT], $Numeric, $List[Text]<!--Words-->, $List[Text]<!--Naked-->, $List[Text]<!--Terms-->, CONSUMPTION_SORT,
        in::Text after::TextMapSort.Text] :: Text;

{#DM} P-ProduceBodyTerm1x[#ModuleName, #SortName, B_FALSE, #ScopeSort1, #Prec1, #Repeat1, #ParsedForm1, #Kind1, #Rest, #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #words, #naked, #terms, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} P-ProduceBodyTerm1[#ModuleName, #SortName, #Rest, Append[#Failed, (PFK[Hx_ParsedFormTerm[Hx_ScopeSortPrecRepeat[#ScopeSort1, #Prec1, #Repeat1], #ParsedForm1], #Kind1];)], #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #words, #naked, #terms, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{#DM} P-ProduceBodyTerm1x[#ModuleName, #SortName, B_TRUE, #ScopeSort1, #Prec1, #Repeat1, #ParsedForm1, #Kind1, #Rest, #Failed, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #words, #naked, #terms, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} P-ProduceBodyTerm1[#ModuleName, #SortName, #Rest, #Failed, #ScopeSort, #Prec, #Repeat, #Kind, Append[#nonterminalPFKs, (PFK[#ParsedForm1, #Kind1];)], #n, #words, #naked, #terms, #consumer, in funs tags after . #[in,funs,tags,after]]
;

// ... (b) emit branch (with recursive nesting of tail).

{$String : DeclarationMapEntry} P-ProduceBodyTerm2[$String<!--ModuleName-->, $String<!--HostSort-->, $List[PFK_SORT], HxScopeSort, $Numeric, HxRepeat, FormKind, $List[PFK_SORT], $Numeric, $List[Text]<!--Words-->, $List[Text]<!--Naked-->, $List[Text]<!--Terms-->, CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

{#DM} P-ProduceBodyTerm2[#ModuleName, #SortName, (), #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #words, #naked, #terms, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} P-ProduceBodyTerm3[#ModuleName, #SortName, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #words, #naked, #terms, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{#DM} P-ProduceBodyTerm2[#ModuleName, #SortName, (#PFK1;#PFKs), #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #words, #naked, #terms, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} P-ProduceBodyTerm3[#ModuleName, #SortName, #ScopeSort, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #words, #naked, #terms, #consumer, in1 funs1 tags1 after1 .
  {#DM} P-ProduceBody[#ModuleName, #SortName, (#PFK1;#PFKs), #n, #words, #naked, #terms, #consumer, in2 funs2 tags2 after2 .
    #[%n⟪(« in1 »
| « in2 »)⟫, %n⟪«funs1»«funs2»⟫, %n⟪«tags1»«tags2»⟫, JoinTextMaps[after1, after2]]]]
;

{$String : DeclarationMapEntry} P-ProduceBodyTerm3[$String<!--ModuleName-->, $String<!--HostSort-->, HxScopeSort, $Numeric, HxRepeat, FormKind, $List[PFK_SORT], $Numeric, $List[Text]<!--Words-->, $List[Text]<!--Naked-->, $List[Text]<!--Terms-->, CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

-[Free[v::Text]]:
{#DM} P-ProduceBodyTerm3[#ModuleName, #SortName, %rawHxScopeSort⟪ #HxSort# binds v ⟫, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #words, #naked, #terms, #consumer, in funs tags after . #[in,funs,tags,after]]
→
IfSingletonRepeat[#Repeat,
  {#DM} P-ProduceBody[#ModuleName, #SortName, #nonterminalPFKs, #n, Append[#words, (%n⟨†‹SortVar[#HxSort#]›⟩;)], #naked, #terms, #consumer, in funs tags after .
    #[%n⟪⟦ <«P-ProductionNameWithPrecText[{#DM}U-SymbolSortTokenName[U-SortName[#HxSort#]], #Prec]»>^«v» ⟦« in »⟧ ⟧⟫, funs, tags, after]],
  PrepError["Cannot use repeat specification on binder"]]
;

    SortVar[HxSort] :: $String;
    -[Data[#Sort]]: SortVar[#Sort] → SortVar2[#Sort] ;
    SortVar2[HxSort] :: $String;
    -[Data[#SortName]]: SortVar2[           %rawHxSort⟪ #HxSortName# #HxMetaVariables# #HxSimpleSorts# ⟫] → SortVar3[#HxSortName#, #HxMetaVariables#] ;
                        SortVar2[$[NotMatch,%rawHxSort⟪ #HxSortName# #HxMetaVariables# #HxSimpleSorts# ⟫,#]] →  "bad" ;
    SortVar3[$String, $List[$String]] :: $String;
    SortVar3[#SortName, ()] → $[:,"v",#SortName] ;
    SortVar3[#SortName, (#MetaVar;)] → $[:,"v",#SortName,$[Replace,#MetaVar,"#",""]] ;

{#DM} P-ProduceBodyTerm3[#ModuleName, #SortName, %rawHxScopeSort⟪ #HxSort# #HxRepeat# [ #HxSubstituteSorts# ] ⟫, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #words, #naked, #terms, #consumer, in funs tags after . #[in,funs,tags,after]]
→
{#DM} P-ProduceBodyTerm4[#ModuleName, #SortName, #HxSort#, #HxSubstituteSorts#, P-ProductionNameWithPrecRepeatText[U-SortName[#HxSort#], #Prec, NestedRepeat[#HxRepeat#, #Repeat]], #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #words, #naked, #terms, #consumer, in funs tags after . #[in,funs,tags,after]]
;

{$String : DeclarationMapEntry} P-ProduceBodyTerm4[$String<!--ModuleName-->, $String<!--HostSort-->, HxSort, $List[HxSubstituteSort], Text, $Numeric, HxRepeat, FormKind, $List[PFK_SORT], $Numeric, $List[Text]<!--Words-->, $List[Text]<!--Naked-->, $List[Text]<!--Terms-->, CONSUMPTION_SORT, in::Text after::TextMapSort.Text] :: Text;

-[Data[#consumer]]:
{#DM} P-ProduceBodyTerm4[#ModuleName, #SortName, #HxSort#, #HxSubstituteSorts#, #ProductionName, #Prec, #Repeat, #Kind, #nonterminalPFKs, #n, #words, #naked, #terms, <!--$[NotMatch,C_INLINE,-->#consumer<!--]-->, in funs tags after . #[in,funs,tags,after]]
→
{#DM} P-ProduceBody[#ModuleName, #SortName, #nonterminalPFKs, $[Plus,#n,1],
  Append[#words, (%n⟨†‹ U-SortName[#HxSort#] ›⟩;)],
  Append[#naked, (%n⟨†‹ P-SortMetaVar[#HxSort#, #n] ›⟩;)],
  Append[#terms, (%n⟨‹ P-ArgumentWrapper[#HxSubstituteSorts#, P-SortMetaVar[#HxSort#, #n], #Kind] ›⟩;)],
  #consumer,
  in funs tags after .
    #[%n⟪⟦( <« #ProductionName »>«
	WrappedTextJoin[Map[s.P-ExtractSubstitutedSort[s], #HxSubstituteSorts#], %n⟨[⟩, %n⟨,⟩, %n⟨]⟩] »«
	P-VariableMarker[#Kind, %n⟨:†‹ P-SortMetaVar[#HxSort#, #n] ›⟩] » ⟦« in »⟧ )
      ⟧⟫, funs, tags, after]]
;

    P-ArgumentWrapper[#HxSubstituteSorts, #MetaVar, FK_DATA[#tag]] → %n⟪/***EMBEDPG: 'C-UnravelScope_†« Length[#HxSubstituteSorts] »'[***/†«#MetaVar»/***EMBEDPG:]***/⟫ ;
    P-ArgumentWrapper[#HxSubstituteSorts, #MetaVar, $[NotMatch,FK_DATA[#_tag], #_]] → %n⟪†«#MetaVar»⟫ ;

    P-SortMetaVar[HxSort, $Numeric] :: $String;
    -[Data[#Sort]]: P-SortMetaVar[#Sort, #n] → P-SortMetaVar2[#Sort, #n] ;
    P-SortMetaVar2[HxSort, $Numeric] :: $String;
    P-SortMetaVar2[           %rawHxSort⟪ #HxSortName# #HxMetaVariable# #HxSimpleSorts# ⟫,    #n] → #HxMetaVariable# ;
    P-SortMetaVar2[           %rawHxSort⟪ #HxSortName#                #HxSimpleSorts# ⟫,    #n] → $[:,"#_",#HxSortName#,"_",$[FormatNumber,#n]] ;
    P-SortMetaVar2[$[NotMatch,%rawHxSort⟪ #HxSortName# #HxMetaVariables# #HxSimpleSorts# ⟫,#], #n] →  "#bad" ;

    // TODO: Eliminate redundant repeat productions!

    P-ExtractSubstitutedSort[HxSubstituteSort] :: Text;
    -[Free[v1::Text]]:
    P-ExtractSubstitutedSort[%rawHxSubstituteSort⟪ v1 as #HxSort2# ⟫] → %n⟪«v1»⟫ ;

///    P-VariablePrefix[FormKind, $String<!--ModuleName-->, $String<!--SortName-->, Text<!--Other-->] :: Text;
///    -[Data[#Kind,#ModuleName,#SortName]]: P-VariablePrefix[#Kind, #ModuleName, #SortName, #Other] → P-VariablePrefix2[#Kind, #ModuleName, #SortName, #Other] ;
///
///    P-VariablePrefix2[FormKind, $String<!--ModuleName-->, $String<!--SortName-->, Text<!--Other-->] :: Text;
///    P-VariablePrefix2[FK_SYMBOL[#free, #t], #ModuleName, #SortName, #Other] → %n⟪/***EMBEDPG:{†« U-QN[#ModuleName,"Var", #SortName] »_«#Other»}***/⟫ ;
///    P-VariablePrefix2[$[NotMatch,FK_SYMBOL[#IsStatic,#t],#Kind], #ModuleName, #SortName, #Other] → %n⟪⟫ ;

    P-VariableMarker[FormKind, Text] :: Text;
    -[Data[#Kind]]: P-VariableMarker[#Kind, #Other] → P-VariableMarker2[#Kind, #Other] ;

    P-VariableMarker2[FormKind, Text] :: Text;
    P-VariableMarker2[FK_SYMBOL[$False,#t], #Other] → %n⟪!!!« #Other »⟫ ;
    P-VariableMarker2[FK_SYMBOL[$True,#t], #Other] → %n⟪!!« #Other »⟫ ;
    P-VariableMarker2[$[NotMatch,FK_SYMBOL[#IsStatic,#t],#Kind], #Other] → #Other ;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 7. GENERATE TEXT OF ALL LEXICAL DECLARATIONS.

// Instantiate CPS processing.
P-Lexical[$List[HxDeclaration], $String<!--ModuleName-->] :: Text ;
P-Lexical[#Declarations, #ModuleName] → P-Lexical2[#Declarations, #ModuleName, B_FALSE, hasskip.P-Lexical2Tail[hasskip]] ;

// Generate P token instructions per HACS declaration.

P-Lexical2[$List[HxDeclaration], $String, Boolean, ha::Boolean.Text] :: Text ;

Lexical-module:
P-Lexical2[%rawHxDeclarations⟪ module #HxModuleName2# { #HxDeclarations2# } ; #HxDeclarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
P-Lexical2[#HxDeclarations2#, #HxModuleName2#, #hasSkip, hasskip.P-Lexical2[#HxDeclarations#, #ModuleName, hasskip, hasskip2.#[hasskip2]]]
;

Lexical-space:
P-Lexical2[%rawHxDeclarations⟪ space #HxRegExp# ; #HxDeclarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
%n⟪skip ::= ' ' | ⟦« P-InlineRegExp[#HxRegExp#, #ModuleName, "space$"] »⟧ .
« P-DeclareRegExp[#HxRegExp#, #ModuleName, "space$"] »« P-Lexical2[#HxDeclarations#, #ModuleName, B_TRUE, hasskip.#[hasskip]] »⟫
;

Lexical-token:
P-Lexical2[%rawHxDeclarations⟪ token #HxTokenName# | #HxRegExp# ; #HxDeclarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
%n⟪token «P-TokenNameText[#HxTokenName#]» ::= ⟦« P-InlineRegExp[#HxRegExp#, #ModuleName, #HxTokenName#] »⟧ .
« P-DeclareRegExp[#HxRegExp#, #ModuleName, #HxTokenName#] »« P-Lexical2[#HxDeclarations#, #ModuleName, #hasSkip, hasskip.#[hasskip]] »⟫
;

Lexical-fragment:
P-Lexical2[%rawHxDeclarations⟪ fragment #HxTokenName# | #HxRegExp# ; #HxDeclarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
%n⟪token fragment «P-TokenNameText[#HxTokenName#]» ::= ⟦« P-InlineRegExp[#HxRegExp#, #ModuleName, #HxTokenName#] »⟧ .
« P-DeclareRegExp[#HxRegExp#, #ModuleName, #HxTokenName#] »« P-Lexical2[#HxDeclarations#, #ModuleName, #hasSkip, hasskip.#[hasskip]] »⟫
;

Lexical-attribute:
P-Lexical2[%rawHxDeclarations⟪ attribute #HxAttributeKind# #HxAttributeName# #HxAttributeForm# ; #HxDeclarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
P-Lexical2[#HxDeclarations#, #ModuleName, #hasSkip, hasskip.#[hasskip]]
;

Lexical-sort:
P-Lexical2[%rawHxDeclarations⟪ sort #HxSortName# #HxRepeat# #HxSortAbstraction# ; #HxDeclarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
P-Lexical2[#HxDeclarations#, #ModuleName, #hasSkip, hasskip.#[hasskip]]
;

Lexical-main-sort:
P-Lexical2[%rawHxDeclarations⟪ main sort #HxSortName# #HxRepeat# #HxSortAbstraction# ; #HxDeclarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
P-Lexical2[#HxDeclarations#, #ModuleName, #hasSkip, hasskip.#[hasskip]]
;

Lexical-alternatives:
P-Lexical2[%rawHxDeclarations⟪ #HxSortAlternatives# ; #HxDeclarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
P-Lexical2[#HxDeclarations#, #ModuleName, #hasSkip, hasskip.#[hasskip]]
;

Lexical-rule:
P-Lexical2[%rawHxDeclarations⟪ rule #HxRule# ; #HxDeclarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
P-Lexical2[#HxDeclarations#, #ModuleName, #hasSkip, hasskip.#[hasskip]]
;

Lexical-nest:
P-Lexical2[%rawHxDeclarations⟪ { #HxDeclarations2# } #HxDeclarations# ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
P-Lexical2[#HxDeclarations2#, #ModuleName, #hasSkip, hasskip.P-Lexical2[#HxDeclarations#, #ModuleName, hasskip, hasskip2.#[hasskip2]]]
;

Lexical-done:
P-Lexical2[%rawHxDeclarations⟪ ⟫, #ModuleName, #hasSkip, hasskip.#[hasskip]]
→
#[#hasSkip]
;

// The final continuation.
P-Lexical2Tail[Boolean] :: Text;
P-Lexical2Tail[B_TRUE] → %n⟪⟫ ;
P-Lexical2Tail[B_FALSE] → %n⟪skip ::= " " .
⟫ ;

// b. Inline Text of Regular Expression.

//

P-InlineRegExp[$List[HxRegExpChoice], $String<!--ModuleName-->, $String<!--identifier-->] :: Text ;
P-InlineRegExp[(#RegExpChoice; #RegExp), #ModuleName, #id]
→
%n⟪⟦« P-InlineRegExpChoice[#RegExpChoice, #ModuleName, #id] »⟧ « P-InlineRegExp2[#RegExp, #ModuleName, #id] »⟫
;

P-InlineRegExp2[$List[HxRegExpChoice], $String<!--ModuleName-->, $String<!--identifier-->] :: Text ;
P-InlineRegExp2[(#RegExpChoice; #RegExp), #ModuleName, #id]
→
%n⟪| ⟦« P-InlineRegExpChoice[#RegExpChoice, #ModuleName, #id] »⟧ « P-InlineRegExp2[#RegExp, #ModuleName, #id] »⟫
;
P-InlineRegExp2[(), #ModuleName, #id]
→
%n⟪⟫
;

//

P-InlineRegExpChoice[HxRegExpChoice, $String<!--ModuleName-->, $String] :: Text;

P-InlineRegExpChoice[%rawHxRegExpChoice⟪ nested #HxRegExpSimple1# #HxRegExpSimple2# ⟫, #ModuleName, #id]
→
%n⟪NESTED_«P-TokenNameText[#id]»⟫
;
P-InlineRegExpChoice[%rawHxRegExpChoice⟪ #HxRegExpUnits# ⟫, #ModuleName, #id]
→
P-InlineRegExpUnits[#HxRegExpUnits#, #ModuleName, #id]
;

//

P-InlineRegExpUnits[$List[HxRegExpUnit], $String<!--ModuleName-->, $String] :: Text;

P-InlineRegExpUnits[%rawHxRegExpUnits⟪ #HxRegExpUnit# #HxRegExpUnits# ⟫, #ModuleName, #id]
→
%n⟪« P-InlineRegExpUnit[#HxRegExpUnit#, #ModuleName, #id] » « P-InlineRegExpUnits[#HxRegExpUnits#, #ModuleName, #id] »⟫
;
P-InlineRegExpUnits[%rawHxRegExpUnits⟪ ⟫, #ModuleName, #id]
→
%n⟪⟫
;

//

P-InlineRegExpUnit[HxRegExpUnit, $String<!--ModuleName-->, $String] :: Text;

P-InlineRegExpUnit[%rawHxRegExpUnit⟪ #HxRegExpSimple# ⟫, #ModuleName, #id]
→
P-InlineRegExpSimple[#HxRegExpSimple#, #ModuleName, #id]
;

P-InlineRegExpUnit[%rawHxRegExpUnit⟪ #HxRegExpSimple# ? ⟫, #ModuleName, #id]
→
%n⟪( « P-InlineRegExpSimple[#HxRegExpSimple#, #ModuleName, #id] » )?⟫
;

P-InlineRegExpUnit[%rawHxRegExpUnit⟪ #HxRegExpSimple# * ⟫, #ModuleName, #id]
→
%n⟪( « P-InlineRegExpSimple[#HxRegExpSimple#, #ModuleName, #id] » )*⟫
;

P-InlineRegExpUnit[%rawHxRegExpUnit⟪ #HxRegExpSimple# + ⟫, #ModuleName, #id]
→
%n⟪( « P-InlineRegExpSimple[#HxRegExpSimple#, #ModuleName, #id] » )+⟫
;

P-InlineRegExpUnit[%rawHxRegExpUnit⟪ #HxRegExpSimple# + _ #HxRegExpSub# ⟫, #ModuleName, #id]
→
%n⟪( « P-InlineRegExpSimple[#HxRegExpSimple#, #ModuleName, #id] » ( « P-InlineRegExpSimple[#HxRegExpSub#, #ModuleName, #id] » « P-InlineRegExpSimple[#HxRegExpSimple#, #ModuleName, #id] » )* )⟫
;

//

P-InlineRegExpSimple[HxRegExpSimple, $String<!--ModuleName-->, $String] :: Text;

P-InlineRegExpSimple[%rawHxRegExpSimple⟪ #HxString# ⟫, #ModuleName, #id]
→
%n⟪†«#HxString#»⟫ // TODO: manually decode HACS and recode P escapes (or at least check)!
;

P-InlineRegExpSimple[%rawHxRegExpSimple⟪ #HxRegExpWord# ⟫, #ModuleName, #id]
→
%n⟪†« Stringify[#HxRegExpWord#] »⟫
;

P-InlineRegExpSimple[%rawHxRegExpSimple⟪ #HxFragmentRef# ⟫, #ModuleName, #id]
→
%n⟪«P-TokenNameText[#HxFragmentRef#]»⟫
;

P-InlineRegExpSimple[%rawHxRegExpSimple⟪ . ⟫, #ModuleName, #id]
→
P-InlineRegExpSimple[%rawHxRegExpSimple⟪ [^\n\r\f] ⟫, #ModuleName, #id]
;

P-InlineRegExpSimple[%rawHxRegExpSimple⟪ #HxRegExpClass# ⟫, #ModuleName, #id]
→
P-InlineRegExpClass1[#HxRegExpClass#, #ModuleName, #id]
;

P-InlineRegExpSimple[%rawHxRegExpSimple⟪ ( #HxRegExp# ) ⟫, #ModuleName, #id]
→
%n⟪( « P-InlineRegExp[#HxRegExp#, #ModuleName, #id] » )⟫
;

//

P-InlineRegExpClass1[HxRegExpClass, $String<!--ModuleName-->, $String] :: Text;

P-InlineRegExpClass1[Hx_RegExpClassNot[#RegExpClass], #ModuleName, #id]
→
%n⟪~[« P-InlineRegExpClass2[#RegExpClass, #ModuleName, #id, %n⟨⟩] »]⟫
;

P-InlineRegExpClass1[$[NotMatch,Hx_RegExpClassNot[#_],#RegExpClass], #ModuleName, #id]
→
%n⟪[« P-InlineRegExpClass2[#RegExpClass, #ModuleName, #id, %n⟨⟩] »]⟫
;

P-InlineRegExpClass2[HxRegExpClass, $String<!--ModuleName-->, $String, Text] :: Text;

P-InlineRegExpClass2[Hx_RegExpClassChar[#Char, #RegExpClass], #ModuleName, #id, #sep]
→
%n⟪«#sep»« P-InlineRegExpRangeChar[#Char, #ModuleName, #id] »« P-InlineRegExpClass2[#RegExpClass, #ModuleName, #id, %n⟨,⟩] »⟫
;

P-InlineRegExpClass2[Hx_RegExpClassRange[#lo, #hi, #RegExpClass], #ModuleName, #id, #sep]
→
%n⟪«#sep»« P-InlineRegExpRangeChar[#lo, #ModuleName, #id] »-« P-InlineRegExpRangeChar[#hi, #ModuleName, #id] »« P-InlineRegExpClass2[#RegExpClass, #ModuleName, #id, %n⟨,⟩] »⟫
;

P-InlineRegExpClass2[Hx_RegExpClassDone, #ModuleName, #id, #sep]
→
%n⟪⟫
;
P-InlineRegExpRangeChar[$String, $String<!--ModuleName-->, $String] :: Text;
-[Data[#HxRegExpRangeStartChar#]]:
P-InlineRegExpRangeChar[#HxRegExpRangeStartChar#, #ModuleName, #id]
→
$[If, $[Equal,#HxRegExpRangeStartChar#,"'"], %n⟪"'"⟫, %n⟪'†« #HxRegExpRangeStartChar# »'⟫]
;

//

P-DeclareRegExp[$List[HxRegExpChoice], $String<!--ModuleName-->, $String<!--identifier-->] :: Text ;
P-DeclareRegExp[(#RegExpChoice; #RegExp), #ModuleName, #id]
→
%n⟪« P-DeclareRegExpChoice[#RegExpChoice, #ModuleName, #id] »« P-DeclareRegExp[#RegExp, #ModuleName, #id] »⟫
;
P-DeclareRegExp[(), #ModuleName, #id]
→
%n⟪⟫
;

P-DeclareRegExpChoice[HxRegExpChoice, $String<!--ModuleName-->, $String] :: Text;
P-DeclareRegExpChoice[%rawHxRegExpChoice⟪ nested #HxRegExpSimple1# #HxRegExpSimple2# ⟫, #ModuleName, #id]
→
%n⟪
%{
/* token †«#id». */
MORE : { < « P-InlineRegExpSimple[#HxRegExpSimple1#, #ModuleName, #id] » > { nesting = 0; nestedState = curLexState; } : IN_«P-TokenNameText[#id]» }
<IN_«P-TokenNameText[#id]»> MORE : { < « P-InlineRegExpSimple[#HxRegExpSimple1#, #ModuleName, #id] » > { nesting = 1; } : IN_NESTED_«P-TokenNameText[#id]» }
<IN_NESTED_«P-TokenNameText[#id]»> MORE : { < « P-InlineRegExpSimple[#HxRegExpSimple1#, #ModuleName, #id] » > { nesting++; } }
<IN_NESTED_«P-TokenNameText[#id]»> MORE : { < « P-InlineRegExpSimple[#HxRegExpSimple2#, #ModuleName, #id] » > { if (--nesting <= 0) SwitchTo(IN_«P-TokenNameText[#id]»); } }
<IN_«P-TokenNameText[#id]»> †« $[If,$[Equal,#id,"space$"],"SKIP","TOKEN"] » : { < T_NESTED_«P-TokenNameText[#id]» : « P-InlineRegExpSimple[#HxRegExpSimple2#, #ModuleName, #id] » > { SwitchTo(nestedState); } }
<IN_«P-TokenNameText[#id]»,IN_NESTED_«P-TokenNameText[#id]»> MORE : { < ~[] > }
%}
⟫
;
P-DeclareRegExpChoice[%rawHxRegExpChoice⟪ #HxRegExpUnits# ⟫, #ModuleName, #id]
→
P-DeclareRegExpUnits[#HxRegExpUnits#, #ModuleName, #id]
;

P-DeclareRegExpUnits[$List[HxRegExpUnit], $String<!--ModuleName-->, $String] :: Text;
P-DeclareRegExpUnits[%rawHxRegExpUnits⟪ #HxRegExpUnit# #HxRegExpUnits# ⟫, #ModuleName, #id]
→
%n⟪« P-DeclareRegExpUnit[#HxRegExpUnit#, #ModuleName, #id] »« P-DeclareRegExpUnits[#HxRegExpUnits#, #ModuleName, #id] »⟫
;
P-DeclareRegExpUnits[%rawHxRegExpUnits⟪ ⟫, #ModuleName, #id]
→
%n⟪⟫
;

P-DeclareRegExpUnit[HxRegExpUnit, $String<!--ModuleName-->, $String] :: Text;
P-DeclareRegExpUnit[%rawHxRegExpUnit⟪ #HxRegExpSimple# ⟫, #ModuleName, #id] → P-DeclareRegExpSimple[#HxRegExpSimple#, #ModuleName, #id] ;
P-DeclareRegExpUnit[%rawHxRegExpUnit⟪ #HxRegExpSimple# ? ⟫, #ModuleName, #id] → P-DeclareRegExpSimple[#HxRegExpSimple#, #ModuleName, #id] ;
P-DeclareRegExpUnit[%rawHxRegExpUnit⟪ #HxRegExpSimple# * ⟫, #ModuleName, #id] → P-DeclareRegExpSimple[#HxRegExpSimple#, #ModuleName, #id] ;
P-DeclareRegExpUnit[%rawHxRegExpUnit⟪ #HxRegExpSimple# + ⟫, #ModuleName, #id] → P-DeclareRegExpSimple[#HxRegExpSimple#, #ModuleName, #id] ;
P-DeclareRegExpUnit[%rawHxRegExpUnit⟪ #HxRegExpSimple# + _ #HxRegExpSub# ⟫, #ModuleName, #id] → %n⟪« P-DeclareRegExpSimple[#HxRegExpSimple#, #ModuleName, #id] »« P-DeclareRegExpSimple[#HxRegExpSub#, #ModuleName, #id] »⟫ ;

P-DeclareRegExpSimple[HxRegExpSimple, $String<!--ModuleName-->, $String] :: Text;
P-DeclareRegExpSimple[%rawHxRegExpSimple⟪ #HxString# ⟫, #ModuleName, #id] → %n⟪⟫ ;
P-DeclareRegExpSimple[%rawHxRegExpSimple⟪ #HxFragmentRef# ⟫, #ModuleName, #id] → %n⟪⟫ ;
P-DeclareRegExpSimple[%rawHxRegExpSimple⟪ . ⟫, #ModuleName, #id] → %n⟪⟫ ;
P-DeclareRegExpSimple[%rawHxRegExpSimple⟪ #HxRegExpClass# ⟫, #ModuleName, #id] → %n⟪⟫ ;
P-DeclareRegExpSimple[%rawHxRegExpSimple⟪ ( #HxRegExp# ) ⟫, #ModuleName, #id] → P-DeclareRegExp[#HxRegExp#, #ModuleName, #id] ;
P-DeclareRegExpSimple[%rawHxRegExpSimple⟪ #HxRegExpWord# ⟫, #ModuleName, #id] → %n⟪⟫ ;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 8. HELPERS FOR MANAGING REPEATS.

U-RegExpSubSuffix[HxRegExpSimple, $String] :: $String;
-[Data[#HxString#]]: U-RegExpSubSuffix[%rawHxRegExpSub⟪ #HxString# ⟫, #prefix] → $[:,#prefix,#HxString#] ;
-[Data[#HxSeparator#]]:   U-RegExpSubSuffix[%rawHxRegExpSub⟪ #HxSeparator# ⟫,   #prefix] → $[:,#prefix,#HxSeparator#] ;
//
P-RegExpSubWord[HxRegExpSimple] :: $String;
-[Data[#HxString#]]: P-RegExpSubWord[%rawHxRegExpSub⟪ #HxString# ⟫] → $[Rescape, #HxString#] ;
-[Data[#HxSeparator#]]:   P-RegExpSubWord[%rawHxRegExpSub⟪ #HxSeparator# ⟫] → #HxSeparator# ;

∀ a . IfSingletonRepeat[HxRepeat, a, a] :: a;
IfSingletonRepeat[%rawHxRepeat⟪ ⟫, #1, #2] → #1 ;
IfSingletonRepeat[%rawHxRepeat⟪ ? ⟫, #1, #2] → #2 ;
IfSingletonRepeat[%rawHxRepeat⟪ * ⟫, #1, #2] → #2 ;
IfSingletonRepeat[%rawHxRepeat⟪ + ⟫, #1, #2] → #2 ;
IfSingletonRepeat[%rawHxRepeat⟪ + _ #HxRegExpSub# ⟫, #1, #2] → #2 ;

NestedRepeat[HxRepeat, HxRepeat] :: HxRepeat;
NestedRepeat-single-single:   NestedRepeat[%rawHxRepeat⟪ ⟫, %rawHxRepeat⟪ ⟫]                                     → %rawHxRepeat⟪ ⟫ ;
NestedRepeat-single-maybe :   NestedRepeat[%rawHxRepeat⟪ ⟫, %rawHxRepeat⟪ ? ⟫]                                   → %rawHxRepeat⟪ ? ⟫ ;
NestedRepeat-single-many:     NestedRepeat[%rawHxRepeat⟪ ⟫, %rawHxRepeat⟪ * ⟫]                                   → %rawHxRepeat⟪ * ⟫ ;
NestedRepeat-single-some:     NestedRepeat[%rawHxRepeat⟪ ⟫, %rawHxRepeat⟪ + ⟫]                                   → %rawHxRepeat⟪ + ⟫ ;
NestedRepeat-single-somesep:  NestedRepeat[%rawHxRepeat⟪ ⟫, %rawHxRepeat⟪ + _ #HxRegExpSub2# ⟫]                   → %rawHxRepeat⟪ + _ #HxRegExpSub2# ⟫ ;
NestedRepeat-maybe-single:    NestedRepeat[%rawHxRepeat⟪ ? ⟫, %rawHxRepeat⟪ ⟫]                                   → %rawHxRepeat⟪ ? ⟫ ;
NestedRepeat-maybe-maybe :    NestedRepeat[%rawHxRepeat⟪ ? ⟫, %rawHxRepeat⟪ ? ⟫]                                 → %rawHxRepeat⟪ ? ⟫ ;
NestedRepeat-maybe-many:      NestedRepeat[%rawHxRepeat⟪ ? ⟫, %rawHxRepeat⟪ * ⟫]                                 → %rawHxRepeat⟪ * ⟫ ;
NestedRepeat-maybe-some:      NestedRepeat[%rawHxRepeat⟪ ? ⟫, %rawHxRepeat⟪ + ⟫]                                 → %rawHxRepeat⟪ * ⟫ ;
NestedRepeat-maybe-somesep:   NestedRepeat[%rawHxRepeat⟪ ? ⟫, %rawHxRepeat⟪ + _ #HxRegExpSub2# ⟫]                 → $[Error,"Cannot nest ? in +_'...' repeater."] ;
NestedRepeat-many-single:     NestedRepeat[%rawHxRepeat⟪ * ⟫, %rawHxRepeat⟪ ⟫]                                   → %rawHxRepeat⟪ * ⟫ ;
NestedRepeat-many-maybe :     NestedRepeat[%rawHxRepeat⟪ * ⟫, %rawHxRepeat⟪ ? ⟫]                                 → %rawHxRepeat⟪ * ⟫ ;
NestedRepeat-many-many:       NestedRepeat[%rawHxRepeat⟪ * ⟫, %rawHxRepeat⟪ * ⟫]                                 → %rawHxRepeat⟪ * ⟫ ;
NestedRepeat-many-some:       NestedRepeat[%rawHxRepeat⟪ * ⟫, %rawHxRepeat⟪ + ⟫]                                 → %rawHxRepeat⟪ * ⟫ ;
NestedRepeat-many-somesep:    NestedRepeat[%rawHxRepeat⟪ * ⟫, %rawHxRepeat⟪ + _ #HxRegExpSub2# ⟫]                 → $[Error,"Cannot nest * in +_'...' repeater."] ;
NestedRepeat-some-single:     NestedRepeat[%rawHxRepeat⟪ + ⟫, %rawHxRepeat⟪ ⟫]                                   → %rawHxRepeat⟪ + ⟫ ;
NestedRepeat-some-maybe :     NestedRepeat[%rawHxRepeat⟪ + ⟫, %rawHxRepeat⟪ ? ⟫]                                 → %rawHxRepeat⟪ * ⟫ ;
NestedRepeat-some-many:       NestedRepeat[%rawHxRepeat⟪ + ⟫, %rawHxRepeat⟪ * ⟫]                                 → %rawHxRepeat⟪ * ⟫ ;
NestedRepeat-some-some:       NestedRepeat[%rawHxRepeat⟪ + ⟫, %rawHxRepeat⟪ + ⟫]                                 → %rawHxRepeat⟪ + ⟫ ;
NestedRepeat-some-somesep:    NestedRepeat[%rawHxRepeat⟪ + ⟫, %rawHxRepeat⟪ + _ #HxRegExpSub2# ⟫]                 → %rawHxRepeat⟪ + _ #HxRegExpSub2# ⟫ ;
NestedRepeat-somesep-single:  NestedRepeat[%rawHxRepeat⟪ + _ #HxRegExpSub1# ⟫, %rawHxRepeat⟪ ⟫]                   → %rawHxRepeat⟪ + _ #HxRegExpSub1# ⟫ ;
NestedRepeat-somesep-maybe :  NestedRepeat[%rawHxRepeat⟪ + _ #HxRegExpSub1# ⟫, %rawHxRepeat⟪ ? ⟫]                 → $[Error,"Cannot nest +_'...' in ? repeater."] ;
NestedRepeat-somesep-many:    NestedRepeat[%rawHxRepeat⟪ + _ #HxRegExpSub1# ⟫, %rawHxRepeat⟪ * ⟫]                 → $[Error,"Cannot nest +_'...' in * repeater."] ;
NestedRepeat-somesep-some:    NestedRepeat[%rawHxRepeat⟪ + _ #HxRegExpSub1# ⟫, %rawHxRepeat⟪ + ⟫]                 → $[Error,"Cannot nest +_'...' in + repeater."] ;
NestedRepeat-somesep-somesep: NestedRepeat[%rawHxRepeat⟪ + _ #HxRegExpSub1# ⟫, %rawHxRepeat⟪ + _ #HxRegExpSub2# ⟫] → $[Error,"Cannot nest +_'...' in another +_'...' repeater."] ;

P-SubRepeat[HxRepeat, HxRepeat] :: Boolean;

P-SubRepeat-single: P-SubRepeat[%rawHxRepeat⟪ ⟫, #Repeat2] → B_TRUE ;

P-SubRepeat-maybe-single: P-SubRepeat[%rawHxRepeat⟪ ? ⟫, %rawHxRepeat⟪ ⟫] → B_FALSE;
P-SubRepeat-maybe-maybe: P-SubRepeat[%rawHxRepeat⟪ ? ⟫, %rawHxRepeat⟪ ? ⟫] → B_TRUE;
P-SubRepeat-maybe-many: P-SubRepeat[%rawHxRepeat⟪ ? ⟫, %rawHxRepeat⟪ * ⟫] → B_TRUE;
P-SubRepeat-maybe-some: P-SubRepeat[%rawHxRepeat⟪ ? ⟫, %rawHxRepeat⟪ + ⟫] → B_FALSE;
P-SubRepeat-maybe-somesep: P-SubRepeat[%rawHxRepeat⟪ ? ⟫, %rawHxRepeat⟪ + _ #HxRegExpSub2# ⟫] → B_FALSE;

P-SubRepeat-some-single: P-SubRepeat[%rawHxRepeat⟪ + ⟫, %rawHxRepeat⟪ ⟫] → B_FALSE;
P-SubRepeat-some-maybe: P-SubRepeat[%rawHxRepeat⟪ + ⟫, %rawHxRepeat⟪ ? ⟫] → B_FALSE;
P-SubRepeat-some-many: P-SubRepeat[%rawHxRepeat⟪ + ⟫, %rawHxRepeat⟪ * ⟫] → B_TRUE;
P-SubRepeat-some-some: P-SubRepeat[%rawHxRepeat⟪ + ⟫, %rawHxRepeat⟪ + ⟫] → B_TRUE;
P-SubRepeat-some-somesep: P-SubRepeat[%rawHxRepeat⟪ + ⟫, %rawHxRepeat⟪ + _ #HxRegExpSub2# ⟫] → B_FALSE;

P-SubRepeat-many-many: P-SubRepeat[%rawHxRepeat⟪ * ⟫, %rawHxRepeat⟪ * ⟫] → B_TRUE ;
P-SubRepeat-many-other[Data[#_]]: P-SubRepeat[%rawHxRepeat⟪ * ⟫, $[NotMatch,%rawHxRepeat⟪ * ⟫,#_]] → B_FALSE;

P-SubRepeat-somesep-single: P-SubRepeat[%rawHxRepeat⟪ + _ #HxRegExpSub1# ⟫, %rawHxRepeat⟪ ⟫] → B_FALSE;
P-SubRepeat-somesep-maybe: P-SubRepeat[%rawHxRepeat⟪ + _ #HxRegExpSub1# ⟫, %rawHxRepeat⟪ ? ⟫] → B_FALSE;
P-SubRepeat-somesep-many: P-SubRepeat[%rawHxRepeat⟪ + _ #HxRegExpSub1# ⟫, %rawHxRepeat⟪ * ⟫] → B_FALSE;
P-SubRepeat-somesep-some: P-SubRepeat[%rawHxRepeat⟪ + _ #HxRegExpSub1# ⟫, %rawHxRepeat⟪ + ⟫] → B_FALSE;

P-SubRepeat-somesep-string-string: P-SubRepeat[%rawHxRepeat⟪ + _ #HxString1# ⟫, %rawHxRepeat⟪ + _ #HxString2# ⟫] → SameString[UnString[#HxString1#], UnString[#HxString2#]] ;
P-SubRepeat-somesep-string-word: P-SubRepeat[%rawHxRepeat⟪ + _ #HxString1# ⟫, %rawHxRepeat⟪ + _ #HxSeparator2# ⟫] → SameString[UnString[#HxString1#], #HxSeparator2#] ;
P-SubRepeat-somesep-word-string: P-SubRepeat[%rawHxRepeat⟪ + _ #HxSeparator1# ⟫, %rawHxRepeat⟪ + _ #HxString2# ⟫] → SameString[#HxSeparator1#, UnString[#HxString2#]] ;
P-SubRepeat-somesep-word-word: P-SubRepeat[%rawHxRepeat⟪ + _ #HxSeparator1# ⟫, %rawHxRepeat⟪ + _ #HxSeparator2# ⟫] → SameString[#HxSeparator1#, #HxSeparator2#] ;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 9. TEXT NAMING CONVENTIONS.

// P token name and constructor.

P-TokenNameText[$String] :: Text;
-[Data[#Name]]: P-TokenNameText[#Name] → %n⟪†«#Name»⟫ ;

P-TokenConstructorText[$String<!--ModuleName-->, $String] :: Text;
P-TokenConstructorText[#ModuleName, #Name] → %n⟪†« U-QN[#ModuleName, "Token", #Name] »⟫ ;

// P production (= non-terminal = sort) name and constructor.

P-ProductionNameText[$String] :: Text;
-[Data[#Name]]: P-ProductionNameText[#Name] → %n⟪†« #Name »⟫ ;

// P special production name for non-terminals with precedence.

P-ProductionNameWithPrecText[$String, $Numeric] :: Text;
-[Data[#Name,#Prec],Copy[#Name,#Prec]]: P-ProductionNameWithPrecText[#Name, #Prec] → P-ProductionNameText[$[If, $[NumericEqual,#Prec,0], #Name, $[:,#Name,$[FormatNumber,#Prec]]]] ;

P-ProductionNameWithPrec[$String, $Numeric] :: $String;
-[Data[#Name,#Prec],Copy[#Name,#Prec]]: P-ProductionNameWithPrec[#Name, #Prec] → $[If, $[NumericEqual,#Prec,0], #Name, $[:,#Name,$[FormatNumber,#Prec]]] ;

// P special production name for non-terminals with precedence and repeat...

P-ProductionNameWithPrecRepeatText[$String, $Numeric, HxRepeat] :: Text;
P-ProductionNameWithPrecRepeatText[#Name, #Prec, %rawHxRepeat⟪ ⟫] → P-ProductionNameWithPrecText[#Name, #Prec] ;
P-ProductionNameWithPrecRepeatText[#Name, #Prec, %rawHxRepeat⟪ ? ⟫]→ %n⟪« P-ProductionNameWithPrecText[#Name, #Prec] »_Maybe⟫ ;
P-ProductionNameWithPrecRepeatText[#Name, #Prec, %rawHxRepeat⟪ * ⟫]→ %n⟪« P-ProductionNameWithPrecText[#Name, #Prec] »_MaybeSome⟫ ;
-[Data[#HxRegExpSimple#]]:
P-ProductionNameWithPrecRepeatText[#Name, #Prec, %rawHxRepeat⟪ + ⟫]→ %n⟪« P-ProductionNameWithPrecText[#Name, #Prec] »_Some⟫ ;
-[Data[#HxRegExpSub#]]:
P-ProductionNameWithPrecRepeatText[#Name, #Prec, %rawHxRepeat⟪ + _ #HxRegExpSub# ⟫]→ %n⟪« P-ProductionNameWithPrecText[#Name, #Prec] »« P-RegExpSubNameText["", #HxRegExpSub#] »⟫ ;

    // Convert regular expression to name fragment...
    P-RegExpSubNameText[$String, HxRegExpSimple] :: Text;
    -[Data[#Name,#HxString#]]:      P-RegExpSubNameText[#Name, %rawHxRegExpSub⟪ #HxString# ⟫] → %n⟪†«#Name»_SomeS†« $[Mangle,#HxString#] »⟫ ;
    -[Data[#Name,#HxSeparator#]]:        P-RegExpSubNameText[#Name, %rawHxRegExpSub⟪ #HxSeparator# ⟫] → %n⟪†«#Name»_SomeW†« $[Mangle,#HxSeparator#] »⟫ ;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 10. JJ HELPERS.

JJ-Construction[#Constructor, #Content]
→
%n⟪{sink = sink.start(makeTConstructor(sink, null, «#Constructor», null));}
«#Content»{sink = sink.end();}
⟫;

JJ-StringLiteral[#Literal]
→
%n⟪{sink = sink.start(makeTConstructor(sink, null, «#Literal», net.sf.crsx.CRS.STRING_SORT)).end();}
⟫;

JJ-Token[#TokenName]
→
%n⟪<T_« #TokenName »>
⟫
;

JJ-Nonterminal[Text, Text, e::Text.Text] :: Text;
JJ-Nonterminal[#sink, #nonterminal, env.#[env]]
→
%n⟪«#sink»=N_«#nonterminal»(«#sink», « #[%n⟨env⟩] »)
⟫
;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 11. OTHER HELPERS.

// Convert hx module name string to Java style class name.

P-ClassName[$String] :: $String;
-[Data[#Name]]: P-ClassName[#Name] → $[Replace, $[Replace, #Name, "/","."], "\"", ""] ;

// Convert hx module name to lower case prefix.

P-Prefix[$String] :: $String;
-[Data[#Name]]: P-Prefix[#Name] → $[If, $[Contains,#Name,"."], P-Prefix[$[AfterFirst,#Name,"."]], $[Replace,$[DownCase,#Name],"\"",""]] ;

P-Embed-Prefix[$String] :: $String;
P-Embed-Prefix[#ModuleName] → StringConcat[P-Prefix[#ModuleName], "Embed_"] ;

P-Meta-Prefix[$String] :: $String;
P-Meta-Prefix[#ModuleName] → StringConcat[P-Prefix[#ModuleName], "Meta_"] ;

P-User-Prefix[$String] :: $String;
P-User-Prefix[#ModuleName] → StringConcat[P-Prefix[#ModuleName], "_"] ;

P-user[#ModuleName, #Name] → StringConcat3[U-LastName[#ModuleName], "_", #Name] ;
P-hx[#ModuleName, #Name] → StringConcat["Hx_", #Name] ;

// Extract last component of module name.

U-LastName[$String] :: $String;
-[Data[#Name]]: U-LastName[#Name]  → $[If, $[Contains,#Name,"."], U-LastName[$[AfterFirst,#Name,"."]], $[Replace,#Name,"\"",""]] ;
// TODO: Sanity check that it is a capitalized word!

// Extract sort name from sort.

U-SortName[HxSort] :: $String;
-[Data[#Sort]]: U-SortName[#Sort] → U-SortName2[#Sort] ;

U-SortName2[HxSort] :: $String;
U-SortName2[           %rawHxSort⟪ #HxSortName# #HxMetaVariables# #HxSimpleSorts# ⟫] → #HxSortName# ;
U-SortName2[$[NotMatch,%rawHxSort⟪ #HxSortName# #HxMetaVariables# #HxSimpleSorts# ⟫,#]] →  $[Show,#] ;

P-BaseSortName[HxSort] :: $String;
-[Data[#Sort]]: P-BaseSortName[#Sort] → P-BaseSortName2[#Sort] ;
P-BaseSortName2[HxSort] :: $String;
P-BaseSortName2[           %rawHxSort⟪ #HxSortName# #HxMetaVariables# #HxSimpleSorts# ⟫] → #HxSortName# ;
P-BaseSortName2[$[NotMatch,%rawHxSort⟪ #HxSortName# #HxMetaVariables# #HxSimpleSorts# ⟫,#]] →  "BAD" ;

// Extract inherited map attribute names (from all schemes).

{$String : DeclarationMapEntry} U-MakeInheritedNames :: NameSet ;
{#DM} U-MakeInheritedNames → FoldWhen[ok k ns.{#DM} KeepInheritedEntry[ok, k, ns], $[{#DM}Keys[$String]], NoNames] ;

    {$String : DeclarationMapEntry} KeepInheritedEntry[Ok, $String, NameSet] :: NameSet;
    {#DM} KeepInheritedEntry[OK, #name, #synthesized] → KeepInheritedEntry1[$[{#DM}Get[DeclarationMapEntry], #name, DME_NONE], #synthesized] ;

    KeepInheritedEntry1[DeclarationMapEntry, NameSet] :: NameSet;
    -[Data[#entry]]:
    KeepInheritedEntry1[#entry, #synthesized] → KeepInheritedEntry2[#entry, #synthesized] ;

    KeepInheritedEntry2[DeclarationMapEntry, NameSet] :: NameSet;
    KeepInheritedEntry2[DME_ATTRIBUTE[%rawHxAttributeKind⟪ ↓ ⟫, #name, #form, #options], #synthesized] → AddName[#synthesized, #name] ;
    KeepInheritedEntry2[$[NotMatch,DME_ATTRIBUTE[%rawHxAttributeKind⟪ ↓ ⟫, #name, #form, #options], #_], #synthesized] → #synthesized ;

{$String : DeclarationMapEntry} U-MakeInheritedMapNames :: NameSet ;
{#DM} U-MakeInheritedMapNames → FoldWhen[ok k ns.{#DM} KeepInheritedMapEntry[ok, k, ns], $[{#DM}Keys[$String]], NoNames] ;

    {$String : DeclarationMapEntry} KeepInheritedMapEntry[Ok, $String, NameSet] :: NameSet;
    {#DM} KeepInheritedMapEntry[OK, #name, #inheritedmaps] → KeepInheritedMapEntry1[$[{#DM}Get[DeclarationMapEntry], #name, DME_NONE], #inheritedmaps] ;

    KeepInheritedMapEntry1[DeclarationMapEntry, NameSet] :: NameSet;
    -[Data[#entry]]:
    KeepInheritedMapEntry1[#entry, #inheritedmaps] → KeepInheritedMapEntry2[#entry, #inheritedmaps] ;

    KeepInheritedMapEntry2[DeclarationMapEntry, NameSet] :: NameSet;
    KeepInheritedMapEntry2[DME_ATTRIBUTE[%rawHxAttributeKind⟪ ↓ ⟫, #name, %rawHxAttributeForm⟪ { #HxSort1# : #HxSort2# } ⟫, #options], #inheritedmaps] → AddName[#inheritedmaps, #name] ;
    KeepInheritedMapEntry2[$[NotMatch,DME_ATTRIBUTE[%rawHxAttributeKind⟪ ↓ ⟫, #name, %rawHxAttributeForm⟪ { #HxSort1# : #HxSort2# } ⟫, #options], #_], #inheritedmaps] → #inheritedmaps ;

{$String : DeclarationMapEntry} U-MakeSynthesizedNames :: NameSet ;
{#DM} U-MakeSynthesizedNames → FoldWhen[ok k ns.{#DM} KeepSynthesizedEntry[ok, k, ns], $[{#DM}Keys[$String]], NoNames] ;

    {$String : DeclarationMapEntry} KeepSynthesizedEntry[Ok, $String, NameSet] :: NameSet;
    {#DM} KeepSynthesizedEntry[OK, #name, #synthesized] → KeepSynthesizedEntry1[$[{#DM}Get[DeclarationMapEntry], #name, DME_NONE], #synthesized] ;

    KeepSynthesizedEntry1[DeclarationMapEntry, NameSet] :: NameSet;
    -[Data[#entry]]:
    KeepSynthesizedEntry1[#entry, #synthesized] → KeepSynthesizedEntry2[#entry, #synthesized] ;

    KeepSynthesizedEntry2[DeclarationMapEntry, NameSet] :: NameSet;
    KeepSynthesizedEntry2[DME_ATTRIBUTE[%rawHxAttributeKind⟪ ↑ ⟫, #name, #form, #options], #synthesized] → AddName[#synthesized, #name] ;
    KeepSynthesizedEntry2[$[NotMatch,DME_ATTRIBUTE[%rawHxAttributeKind⟪ ↑ ⟫, #name, #form, #options], #_], #synthesized] → #synthesized ;

{$String : DeclarationMapEntry} U-MakeSynthesizedMapNames :: NameSet ;
{#DM} U-MakeSynthesizedMapNames → FoldWhen[ok k ns.{#DM} KeepSynthesizedMapEntry[ok, k, ns], $[{#DM}Keys], NoNames] ;

    {$String : DeclarationMapEntry} KeepSynthesizedMapEntry[Ok, $String, NameSet] :: NameSet;
    {#DM} KeepSynthesizedMapEntry[OK, #name, #synthesizedmaps] → KeepSynthesizedMapEntry1[$[{#DM}Get[DeclarationMapEntry], #name, DME_NONE], #synthesizedmaps] ;

    KeepSynthesizedMapEntry1[DeclarationMapEntry, NameSet] :: NameSet;
    -[Data[#entry]]:
    KeepSynthesizedMapEntry1[#entry, #synthesizedmaps] → KeepSynthesizedMapEntry2[#entry, #synthesizedmaps] ;

    KeepSynthesizedMapEntry2[DeclarationMapEntry, NameSet] :: NameSet;
    KeepSynthesizedMapEntry2[DME_ATTRIBUTE[%rawHxAttributeKind⟪ ↑ ⟫, #name, %rawHxAttributeForm⟪ { #HxSort1# : #HxSort2# } ⟫, #options], #synthesizedmaps] → AddName[#synthesizedmaps, #name] ;
    KeepSynthesizedMapEntry2[$[NotMatch,DME_ATTRIBUTE[%rawHxAttributeKind⟪ ↑ ⟫, #name, %rawHxAttributeForm⟪ { #HxSort1# : #HxSort2# } ⟫, #options], #_], #synthesizedmaps] → #synthesizedmaps ;

// Errors.

∀ a . PrepError[$String] :: a;
-[Data[#message]]: PrepError[#message] → $[Error, #message] ;

)] //Prep




/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// // P-ProductionNames: Extract top level productions.
/// //
/// // Only include productions for tokens and sorts that have syntax.
///
/// {$String<!--SortName--> : DeclarationMapEntry} P-ProductionNames[$List[$String]] :: $List[$String];
/// {#DM}P-ProductionNames[()] → () ;
/// {#DM}P-ProductionNames[(#1;#s)] → {#DM}P-ProductionNames2[$[{#DM}Get[DeclarationMapEntry],#1,DME_NONE], #1, #s] ;
///
/// {$String<!--SortName--> : DeclarationMapEntry} P-ProductionNames2[DeclarationMapEntry, $String, $List[$String]] :: $List[$String];
/// {#DM}P-ProductionNames2[DME_NONE, #1, #s] → {#DM}P-ProductionNames[#s] ;
/// {#DM}P-ProductionNames2[DME_TOKEN[#SortName], #1, #s] → (#1 ; {#DM}P-ProductionNames[#s]) ;
/// {#DM}P-ProductionNames2[DME_ATTRIBUTE[#Kind, #Name, #AttributeForm, #AttributeOptions], #1, #s] → {#DM}P-ProductionNames[#s] ;
/// {#DM}P-ProductionNames2[DME_SORT[#Defines, #SortName, #Precs, #Wrapper], #1, #s] → {#DM}P-ProductionNames3[#Defines, #1, #s] ;
///
/// {$String<!--SortName--> : DeclarationMapEntry} P-ProductionNames3[$List[Define], $String, $List[$String]] :: $List[$String];
/// -[Fresh[dummy::HxSortParam]]:
/// {#DM} P-ProductionNames3[(D_ABSTRACTION[a.#Define1[a]]; #Defines), #1, #s] → {#DM} P-ProductionNames3[(#Define1[dummy]; #Defines), #1, #s] ;
/// {#DM} P-ProductionNames3[(D_RULE[#Rule, #RuleSort, #IsData]; #Defines), #1, #s] → {#DM} P-ProductionNames3[#Defines, #1, #s] ;
/// {#DM} P-ProductionNames3[(D_FORM[#Form1, #Kind1]; #Defines), #1, #s] → {#DM} P-ProductionNames4[#Form1, #Defines, #1, #s] ;
/// {#DM} P-ProductionNames3[(D_NONE; #Defines), #1, #s] → {#DM} P-ProductionNames3[#Defines, #1, #s] ;
/// {#DM} P-ProductionNames3[(), #1, #s] → {#DM}P-ProductionNames[#s] ;
///
/// {$String<!--SortName--> : DeclarationMapEntry} P-ProductionNames4[HxForm, $List[Define], $String, $List[$String]] :: $List[$String];
/// {#DM} P-ProductionNames4[Hx_FormParsedSorted[#Sort1, #ParsedForm1, #Prec1, #InheritedRefs], #Defines, #1, #s] → (#1; {#DM}P-ProductionNames[#s]) ;
/// {#DM} P-ProductionNames4[Hx_FormParsed[#ParsedForm1, #Prec1, #InheritedRefs], #Defines, #1, #s] → (#1; {#DM}P-ProductionNames[#s]) ;
/// {#DM} P-ProductionNames4[Hx_FormConstruction[#Constructor, #ScopeSortList, #InheritedRefs], #Defines, #1, #s] → {#DM} P-ProductionNames3[#Defines, #1, #s] ;
///
///
///
///
///
///
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// // TEXT LIST OF REPEAT-DERIVED DECLARATIONS.
///
/// P-ProduceDerived[DERIVED_SORT] :: TextMapSort;
/// P-ProduceDerived[DERIVED[#SortName, #Prec, #Repeat]] → P-ProduceRepeat[#Repeat, #SortName, #Prec, P-ProductionNameWithPrecRepeatText[#SortName, #Prec, #Repeat]] ;
///
/// P-ProduceRepeat[HxRepeat, $String, $Numeric, Text] :: TextMapSort;
///
/// P-ProduceRepeat[%rawHxRepeat⟪ ⟫, #s, #p, #name] → EmptyTextMap ;
///
/// -[Data[#s]]:
/// P-ProduceRepeat[%rawHxRepeat⟪ ? ⟫, #s, #p, #name]
/// →
/// SingletonTextMap[TextToString[#name], %n⟪
/// <«#name»> ::= «
///   P-Head[B_TRUE, #ModuleName, $[:,#s,"?"], TextToString[#name], B_FALSE, 0]
/// »( <«P-ProductionNameWithPrecText[#s, #p]»>:#1 {{ $Cons[#1,$Nil] }} | {{ $Nil }} ).
/// « P-Embed-Tail[B_TRUE, $[:,#s,"?"], TextToString[#name]] »⟫]
/// ;
///
/// -[Data[#s]]:
/// P-ProduceRepeat[%rawHxRepeat⟪ * ⟫, #s, #p, #name]
/// →
/// SingletonTextMap[TextToString[#name], %n⟪
/// <«#name»> ::= «
///   P-Head[B_TRUE, #ModuleName, $[:,#s,"*"], TextToString[#name], B_FALSE, 0]
/// »( <«P-ProductionNameWithPrecText[#s, #p]»>:#1 <«#name»>:#2 {{ $Cons[#1,#2] }} | {{ $Nil }} ).
/// « P-Embed-Tail[B_TRUE, $[:,#s,"*"], TextToString[#name]] »⟫]
/// ;
///
/// -[Data[#s]]:
/// P-ProduceRepeat[%rawHxRepeat⟪ + ⟫, #s, #p, #name]
/// →
/// SingletonTextMap[TextToString[#name], %n⟪
/// <«#name»> ::= «
///   P-Head[B_TRUE, #ModuleName, $[:,#s,"+"], TextToString[#name], B_FALSE, 0]
/// » <«P-ProductionNameWithPrecText[#s, #p]»>:#1 ( <«#name»>:#2 {{ $Cons[#1,#2] }} | {{ $Cons[#1,$Nil] }} ) .
/// « P-Embed-Tail[B_TRUE, $[:,#s,"+"], TextToString[#name]] »⟫]
/// ;
///
/// -[Data[#s]]:
/// P-ProduceRepeat[%rawHxRepeat⟪ + _ #HxRegExpSub# ⟫, #s, #p, #name]
/// →
/// SingletonTextMap[TextToString[#name], %n⟪
/// <«#name»> ::= «
///   P-Head[B_TRUE, #ModuleName, RegExpSubSuffix[#HxRegExpSub#, $[:,#s,"+_"]], TextToString[#name], B_FALSE, 0]
/// » <«P-ProductionNameWithPrecText[#s, #p]»>:#1 ( « P-InlineRegExpSimple[#HxRegExpSub#, ""] » <«#name»>:#2 {{ $Cons[#1,#2] }} | {{ $Cons[#1,$Nil] }} ) .
/// « P-Embed-Tail[B_TRUE, RegExpSubSuffix[#HxRegExpSub#, $[:,#s,"+_"]], TextToString[#name]] »⟫]
/// ;
///
///
///
///
///
///
///
///
///
///
///
///
///
///
///
///
///
///
///
///
///
///
///
///
///
///
///
///
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///
/// // PrepBase.crs: CRSX3 SUPPORT LIBRARY FOR HACS PREPROCESSOR OPERATIONS.
/// //
/// // Declarations here depend only on the Prelude and the Hx syntax.
/// //
/// PrepBase[(
///
/// $Use["org/crsx/hacs/Prelude.crs"];
///
/// // Syntax and sorts of hx terms (%rawHx...⟪...⟫).
/// $Use["org/crsx/hacs/Hx.crs"];
///
/// // Syntax and sorts of text (%n⟪...⟫).
/// $CheckGrammar["net.sf.crsx.text.Text"];
/// $Use["net/sf/crsx/text/Text.crs"];
///
/// $Lax;
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// // LOCATION EXTRACTION.
///
/// $StringEntrySort ::=( STRING[$String]; );
///
/// {$String : $StringEntrySort}MakeLocation :: $String;
/// {#L}MakeLocation → MakeLocation2[$[{#L}Get[$StringEntrySort],"$FileLocation",STRING[""]], $[{#L}Get[$StringEntrySort],"$LineLocation",STRING[""]], $[{#L}Get[$StringEntrySort],"$ColumnLocation",STRING[""]]] ;
/// MakeLocation2[$StringEntrySort, $StringEntrySort, $StringEntrySort] :: $String;
/// MakeLocation2[STRING[#file], STRING[#line], STRING[#column]] → $[:,#file," ",#line,":",#column] ;
///
///
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// // SORT EXTRACTION.
///
/// ScopeU-SortName[HxScopeSort] :: $String;
/// ScopeU-SortName[%rawHxScopeSort⟪ #HxSort# #HxRepeat# [ #HxSubstituteSorts# ] ⟫] → SortNameWithRepeat[#HxSort#, #HxRepeat#] ;
/// -[Free[v::Text]]:
/// ScopeU-SortName[%rawHxScopeSort⟪ [ v : #HxSort# ] ⟫                  ] → U-SortName[#HxSort#] ;
/// -[Free[v::Text]]:
/// ScopeU-SortName[%rawHxBindersScopeSort⟪ [ v : #HxSort# ] #HxBindersScopeSort# ⟫] → ScopeU-SortName[#HxBindersScopeSort#] ;
///
/// ScopeSortMetaVar[HxScopeSort, $Numeric] :: $String;
/// -[Discard[#HxSubstituteSorts#]]: ScopeSortMetaVar[%rawHxScopeSort⟪ #HxSort# [ #HxSubstituteSorts# ] ⟫, #n] → SortMetaVar[#HxSort#, #n] ;
/// -[Free[v::Text]]: ScopeSortMetaVar[%rawHxScopeSort⟪ [ v : #HxSort# ] ⟫                  , #n] → SortMetaVar[#HxSort#, #n] ;
///

///
///
///
///
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// // PRODUCTION NAMES.
///
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// // ERRORS.
///
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///
///
///
///
///
///
///
///
///


///
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// // COMPARISON OF FORMS.
///
///
///
///
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// // Extract all repeat-derived sort forms from DM structure.
///
/// DERIVED_SORT ::=( DERIVED[$String, $Numeric<!--Precedence-->, HxRepeat]; );
///
/// {$String<!--SortName--> : DeclarationMapEntry} DerivedSorts[NameSet] :: $List[DERIVED_SORT];
/// {#DM} DerivedSorts[#Names] → FoldNamesWhen[ok x y.{#DM} Then-DerivedSorts2[ok, x, y], #Names, ()] ;
///
/// {$String<!--SortName--> : DeclarationMapEntry} Then-DerivedSorts2[Ok, $String, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// {#DM} Then-DerivedSorts2[OK, #name, #derived] → DerivedSorts2[$[{#DM}Get[DeclarationMapEntry], #name, DME_NONE], #derived];
///
/// DerivedSorts2[DeclarationMapEntry, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
///
/// DerivedSorts2[DME_NONE, #derived] → #derived ;
/// DerivedSorts2[DME_TOKEN[#name], #derived] → #derived ;
/// DerivedSorts2[DME_ATTRIBUTE[#kind, #name, #form, #options], #derived] → #derived ;
///
/// DerivedSorts2[DME_SORT[#Defines, #Name, #Precs, #Wrapper], #derived]
/// →
/// FoldWhen[ok defined derived.Then-DerivedSorts-Defines[ok, defined, derived], #Defines, #derived]
/// ;
///
/// Then-DerivedSorts-Defines[Ok, Define, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// -[Fresh[dummy::HxSortParam]]: Then-DerivedSorts-Defines[OK, D_ABSTRACTION[a . #Define[a]], #derived] → Then-DerivedSorts-Defines[OK, #Define[dummy], #derived] ;
/// Then-DerivedSorts-Defines[OK, D_FORM[#Form, #Kind], #derived] → DerivedSorts-Form[#Form, #derived] ;
/// Then-DerivedSorts-Defines[OK, D_RULE[#Rule, #SortName, #IsDataEquivalence], #derived] → DerivedSorts-Rule[#Rule, #derived] ;
/// Then-DerivedSorts-Defines[OK, D_SYNTHESIZES[#AttributeName], #derived] → #derived ;
/// Then-DerivedSorts-Defines[OK, D_NONE, #derived] → #derived ;
///
/// DerivedSorts-Form[HxForm, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-Form[Hx_FormParsedSorted[#HxSort#, #HxParsedForm#, #HxPrec#, #InheritedRefs], #derived] → DerivedSorts-ParsedForm[#HxParsedForm#, #derived] ;
/// DerivedSorts-Form[Hx_FormParsed[#HxParsedForm#, #HxPrec#, #InheritedRefs], #derived] → DerivedSorts-ParsedForm[#HxParsedForm#, #derived] ;
/// DerivedSorts-Form[Hx_FormConstruction[#HxConstructor#, #HxScopeSorts#, #InheritedRefs], #derived] → #derived ;
///
/// DerivedSorts-ParsedForm[HxParsedForm, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-ParsedForm[Hx_ParsedFormWord[#Word, #ParsedForm], #derived] → DerivedSorts-ParsedForm[#ParsedForm, #derived] ;
/// DerivedSorts-ParsedForm[Hx_ParsedFormSpace[#Space, #ParsedForm], #derived] → DerivedSorts-ParsedForm[#ParsedForm, #derived] ;
/// DerivedSorts-ParsedForm[Hx_ParsedFormDone, #derived] → #derived ;
/// DerivedSorts-ParsedForm[Hx_ParsedFormTerm[Hx_ScopeSortPrecRepeat[#ScopeSort, #Precedence, #Repeat], #ParsedForm], #derived]
/// →
/// DerivedSorts-ScopeSort[#ScopeSort, #Precedence, #Repeat, DerivedSorts-ParsedForm[#ParsedForm, #derived]]
/// ;
///
/// DerivedSorts-ScopeSort[HxScopeSort, $Numeric, HxRepeat, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-ScopeSort[%rawHxScopeSort⟪ #HxSort# #HxRepeat# [ #HxSubstituteSorts1# ] ⟫, #Precedence, #Repeat, #derived] → DerivedSorts-Sort[#HxSort#, #Precedence, NestedRepeat[#HxRepeat#, #Repeat], #derived] ;
/// -[Free[v::Text]]:
/// DerivedSorts-ScopeSort[%rawHxScopeSort⟪ [ v : #HxSort# ] ⟫, #Precedence, #Repeat, #derived] → #derived ;
///
/// DerivedSorts-Sort[HxSort, $Numeric, HxRepeat, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// -[Data[#Repeat]]:
/// DerivedSorts-Sort[#Sort, #Precedence, #Repeat, #derived] → DerivedSorts-Sort2[#Repeat, #Precedence, P-BaseSortName[#Sort], #derived] ;
///
/// DerivedSorts-Sort2[HxRepeat, $Numeric, $String, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-Sort2[%rawHxRepeat⟪ ⟫, #Precedence, #Name, #derived] → #derived ;
/// -[Data[#Repeat,#Name]]:
/// DerivedSorts-Sort2[$[NotMatch,%rawHxRepeat⟪ ⟫,#Repeat], #Precedence, #Name, #derived]
/// →
/// $[IfEmpty, #Name, #derived, (DERIVED[#Name, #Precedence, #Repeat] ; #derived)]
/// ;
///
/// DerivedSorts-Rule[HxRule, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-Rule[%rawHxRule⟪ #HxPriority# #HxConstruction# : #HxConstruction_Pattern# → #HxTerm_Contraction# ⟫, #derived]
/// →
/// DerivedSorts-Term[#HxConstruction_Pattern#, DerivedSorts-Term[#HxTerm_Contraction#, #derived]]
/// ;
///
/// DerivedSorts-Term[HxTerm, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
///
/// DerivedSorts-Term[Hx_OMITTED, #derived] → #derived ;
///
/// -[Free[v::Text]]:
/// DerivedSorts-Term[%rawHxTerm⟪ v #HxAttributes# ⟫, #derived] → DerivedSorts-Attributes[#HxAttributes#, #derived] ;
///
/// -[Free[v::Text]]:
/// DerivedSorts-Term[%rawHxTerm⟪ #HxConstructor# #HxRepeat# v #HxAttributes# ⟫, #derived]
/// →
/// DerivedSorts-Repeat[#HxConstructor#, #HxRepeat#, DerivedSorts-Attributes[#HxAttributes#, #derived]] ;
///
/// DerivedSorts-Term[%rawHxTerm⟪ #HxLiteral# #HxAttributes# ⟫, #derived] → DerivedSorts-Attributes[#HxAttributes#, #derived] ;
///
/// DerivedSorts-Term[Hx_Unparsed[#Unparsed, #Attributes], #derived] → #derived ;
/// DerivedSorts-Term[Hx_UnparsedSorted[#Name, #Repeat, #Unparsed, #Attributes], #derived] → #derived ;
///
/// DerivedSorts-Term[%rawHxTerm⟪ #HxConstructor# (#HxScopes#) #HxAttributes# ⟫, #derived] → DerivedSorts-Scopes[#HxScopes#, DerivedSorts-Attributes[#HxAttributes#, #derived]] ;
///
/// DerivedSorts-Term[%rawHxTerm⟪ #HxConstructor1# #HxRepeat# #HxConstructor# (#HxScopes#) #HxAttributes# ⟫, #derived]
/// →
/// DerivedSorts-Repeat[#HxConstructor1#, #HxRepeat#, DerivedSorts-Scopes[#HxScopes#, DerivedSorts-Attributes[#HxAttributes#, #derived]]]
/// ;
///
/// DerivedSorts-Term[%rawHxTerm⟪ #HxMetaVariable# [#HxTerms#] #HxAttributes# ⟫, #derived]
/// →
/// DerivedSorts-Terms[#HxTerms#, DerivedSorts-Attributes[#HxAttributes#, #derived]]
/// ;
///
/// DerivedSorts-Term[%rawHxTerm⟪ #HxConstructor_Sort# #HxRepeat# #HxMetaVariable# [#HxTerms#] #HxAttributes# ⟫, #derived]
/// →
/// DerivedSorts-Repeat[#HxConstructor_Sort#, #HxRepeat#, DerivedSorts-Terms[#HxTerms#, #derived]]
/// ;
///
/// DerivedSorts-Term[Hx_Special[#v, #Concrete], #derived] → #derived ;
///
/// DerivedSorts-Repeat[$String, HxRepeat, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-Repeat[#Name, %rawHxRepeat⟪ ⟫, #derived] → #derived ;
/// -[Data[#Name,#Repeat]]: DerivedSorts-Repeat[#Name, $[NotMatch,%rawHxRepeat⟪ ⟫,#Repeat], #derived]
/// →
/// $[IfEmpty, #Name, #derived, (DERIVED[#Name, 0, #Repeat] ; #derived)]
/// ;
///
/// DerivedSorts-Scopes[$List[HxScope], $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-Scopes[#Scopes, #derived] → FoldWhen[ok scope derived.Then-DerivedSorts-Scope[ok, scope, derived], #Scopes, #derived] ;
///
/// Then-DerivedSorts-Scope[Ok, HxScope, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// Then-DerivedSorts-Scope[OK, Hx_Scope[#vs, #Term], #derived] → DerivedSorts-Term[#Term, #derived] ;
///
/// DerivedSorts-Terms[$List[HxTerm], $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-Terms[#Terms, #derived] → FoldWhen[ok term derived.Then-DerivedSorts-Term[ok, term, derived], #Terms, #derived] ;
///
/// Then-DerivedSorts-Term[Ok, HxTerm, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// Then-DerivedSorts-Term[OK, #Term, #derived] → DerivedSorts-Term[#Term, #derived] ;
///
/// DerivedSorts-Attributes[$List[HxAttribute], $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-Attributes[(), #derived] → #derived ;
/// DerivedSorts-Attributes[(#a1;#as), #derived] → DerivedSorts-Attribute[#a1, DerivedSorts-Attributes[#as, #derived]] ;
///
/// DerivedSorts-Attribute[HxAttribute, $List[DERIVED_SORT]] :: $List[DERIVED_SORT];
/// DerivedSorts-Attribute[%rawHxAttribute⟪ #HxAttributeKind# #HxAttributeName# ( #HxTerm# ) ⟫, #derived] → DerivedSorts-Term[#HxTerm#, #derived] ;
/// DerivedSorts-Attribute[%rawHxAttribute⟪ #HxAttributeKind# #HxAttributeName# { #HxTerm# } ⟫, #derived] → DerivedSorts-Term[#HxTerm#, #derived] ;
/// DerivedSorts-Attribute[%rawHxAttribute⟪ #HxAttributeKind# #HxAttributeName# { #HxTerm1# : #HxTerm2# } ⟫, #derived] → DerivedSorts-Term[#HxTerm1#, DerivedSorts-Term[#HxTerm2#, #derived]] ;
/// DerivedSorts-Attribute[%rawHxAttribute⟪ #HxAttributeKind# #HxAttributeName# { ¬ #HxTerm# } ⟫, #derived] → DerivedSorts-Term[#HxTerm#, #derived] ;
///
/// // Name.
/// ProductionNameDerived[DERIVED_SORT] :: Text;
/// ProductionNameDerived[DERIVED[#Name, #Prec, #Repeat]] → P-ProductionNameWithPrecRepeatText[#Name, #Prec, #Repeat] ;
///
/// Un$Hx[HxTerm] :: HxTerm ;
/// Un$Hx[#] → # ;
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// // Extract scope sorts for unparsed constructor.
///
/// {$String : DeclarationMapEntry}
/// ConstructorScopeSorts[$String<!--SortName-->, $String<!--Constructor-->] :: Lifted[$List[HxScopeSort]] ;
///
/// -[Data[#TopSortName]]:
/// {#DM}ConstructorScopeSorts[#TopSortName, #Constructor]
/// →
/// ConstructorScopeSorts0[$[{#DM}Get[DeclarationMapEntry], #TopSortName, DME_NONE], #Constructor]
/// ;
///
/// ConstructorScopeSorts0[DeclarationMapEntry, $String<!--Constructor-->] :: Lifted[$List[HxScopeSort]] ;
/// -[Data[#Entry, #Constructor]]:
/// ConstructorScopeSorts0[#Entry, #Constructor]
/// →
/// ConstructorScopeSorts1[#Entry, #Constructor]
/// ;
///
/// ConstructorScopeSorts1[DeclarationMapEntry, $String<!--Constructor-->] :: Lifted[$List[HxScopeSort]] ;
///
/// ConstructorScopeSorts1[DME_SORT[#Defines, #Name, #Precs, #Wrapper], #Constructor]
/// →
/// ConstructorScopeSorts2[#Defines, #Constructor]
/// ;
/// ConstructorScopeSorts1[$[NotMatch,DME_SORT[#Defines, #Name, #Precs, #Wrapper],#_], #Constructor] → BOTTOM ;
///
/// ConstructorScopeSorts2[$List[Define], $String<!--Constructor-->] :: Lifted[$List[HxScopeSort]] ;
///
/// ConstructorScopeSorts2[(), #Constructor] → BOTTOM ;
///
/// -[Fresh[param::HxSortParam]]:
/// ConstructorScopeSorts2[(D_ABSTRACTION[a.#Define[a]]; #Defines), #Constructor] → ConstructorScopeSorts2[(#Define[param]; #Defines), #Constructor] ;
///
/// ConstructorScopeSorts2[(D_RULE[#Rule, #sort, #IsDataEquivalence?]; #Defines), #Constructor] → ConstructorScopeSorts2[#Defines, #Constructor] ;
///
/// ConstructorScopeSorts2[(D_FORM[#Form, #Kind]; #Defines), #Constructor]
/// →
/// ConstructorScopeSorts3[#Form, #Defines, #Constructor]
/// ;
///
/// ConstructorScopeSorts2[(D_SYNTHESIZES[#AttributeName]; #Defines), #Constructor] → ConstructorScopeSorts2[#Defines, #Constructor] ;
///
/// ConstructorScopeSorts3[HxForm, $List[Define], $String<!--Constructor-->] :: Lifted[$List[HxScopeSort]] ;
/// -[Data[#Constructor1,#Constructor2]]:
/// ConstructorScopeSorts3[Hx_FormConstruction[#Constructor1, #ScopeSorts, #InheritedRefs], #Defines, #Constructor2]
/// →
/// $[If, $[Equal,#Constructor1,#Constructor2], LIFTED[#ScopeSorts], ConstructorScopeSorts2[#Defines, #Constructor2]]
/// ;
/// -[Data[#_]]:
/// ConstructorScopeSorts3[$[NotMatch,Hx_FormConstruction[#Constructor, #ScopeSorts, #InheritedRefs],#_], #Defines, #Constructor2] → ConstructorScopeSorts2[#Defines, #Constructor2] ;
///
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// // Extract sort names.
///
/// {$String : DeclarationMapEntry} SortNameList :: $List[$String] ;
/// {#DM} SortNameList → {#DM} SortNameList2[$[{#DM}Keys[$String]]] ;
///
/// {$String : DeclarationMapEntry} SortNameList2[$List[$String]] :: $List[$String] ;
/// {#DM} SortNameList2[()] → () ;
/// {#DM} SortNameList2[(#Name; #Names)] → {#DM} SortNameList3[$[{#DM}Get[DeclarationMapEntry], #Name], #Names] ;
///
/// {$String : DeclarationMapEntry} SortNameList3[DeclarationMapEntry, $List[$String]] :: $List[$String] ;
/// {#DM} SortNameList3[DME_SORT[#Defines1, #Name1, #Precs1, #Wrapper1], #Names]
/// →
/// (#Name1 ; {#DM} SortNameList2[#Names])
/// ;
///
/// {#DM} SortNameList3[$[NotMatch, DME_SORT[#Defines1, #Name1, #Precs1, #Wrapper1], #_], #Names]
/// →
/// {#DM} SortNameList2[#Names]
/// ;
///
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// // Extract token names.
///
/// {$String : DeclarationMapEntry} TokenNameList :: $List[$String] ;
/// {#DM} TokenNameList → {#DM} TokenNameList2[$[{#DM}Keys[$String]]] ;
///
/// {$String : DeclarationMapEntry} TokenNameList2[$List[$String]] :: $List[$String] ;
/// {#DM} TokenNameList2[()] → () ;
/// {#DM} TokenNameList2[(#Name; #Names)] → {#DM} TokenNameList3[$[{#DM}Get[DeclarationMapEntry], #Name], #Name, #Names] ;
///
/// {$String : DeclarationMapEntry} TokenNameList3[DeclarationMapEntry, $String, $List[$String]] :: $List[$String] ;
/// {#DM} TokenNameList3[DME_TOKEN[#String1], #Name, #Names]
/// →
/// (#Name ; {#DM} TokenNameList2[#Names])
/// ;
///
/// {#DM} TokenNameList3[$[NotMatch, DME_TOKEN[#String1], #_], #Name, #Names]
/// →
/// {#DM} TokenNameList2[#Names]
/// ;
///
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// // Extract attribute names.
///
/// {$String : DeclarationMapEntry} AttributeNameList :: $List[$String] ;
/// {#DM} AttributeNameList → {#DM} AttributeNameList2[$[{#DM}Keys[$String]]] ;
///
/// {$String : DeclarationMapEntry} AttributeNameList2[$List[$String]] :: $List[$String] ;
/// {#DM} AttributeNameList2[()] → () ;
/// {#DM} AttributeNameList2[(#Name; #Names)] → {#DM} AttributeNameList3[$[{#DM}Get[DeclarationMapEntry], #Name], #Names] ;
///
/// {$String : DeclarationMapEntry} AttributeNameList3[DeclarationMapEntry, $List[$String]] :: $List[$String] ;
/// {#DM} AttributeNameList3[DME_ATTRIBUTE[#HxAttributeKind#, #HxAttributeName#, #HxAttributeForm#, #HxAttributeOptions#], #Names]
/// →
/// (#HxAttributeName# ; {#DM} AttributeNameList2[#Names])
/// ;
///
/// {#DM} AttributeNameList3[$[NotMatch, DME_ATTRIBUTE[#HxAttributeKind#, #HxAttributeName#, #HxAttributeForm#, #HxAttributeOptions#], #_], #Names]
/// →
/// {#DM} AttributeNameList2[#Names]
/// ;
///
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// // Sort name for attribute value.
///
/// {$String : DeclarationMapEntry} AttributeValueU-SortName[$String] :: $String;
/// {#DM}AttributeValueU-SortName[#AttributeName] → {#DM}AttributeValueSortName1[$[{#DM}Get[DeclarationMapEntry], #AttributeName, DME_NONE], #AttributeName] ;
///
/// {$String : DeclarationMapEntry} AttributeValueSortName1[DeclarationMapEntry, $String] :: $String;
/// -[Data[#Entry]]:
/// {#DM}AttributeValueSortName1[#Entry, #AttributeName] → {#DM}AttributeValueSortName2[#Entry, #AttributeName] ;
///
/// {$String : DeclarationMapEntry} AttributeValueSortName2[DeclarationMapEntry, $String] :: $String;
/// {#DM}AttributeValueSortName2[DME_ATTRIBUTE[#AttributeKind, #AttributeName, %rawHxAttributeForm⟪ ( #HxSort# ) ⟫, #AttributeOptions], #SortName] → U-SortName[#HxSort#];
/// {#DM}AttributeValueSortName2[DME_ATTRIBUTE[#AttributeKind, #AttributeName, %rawHxAttributeForm⟪ { #HxSort# } ⟫, #AttributeOptions], #SortName] → "";
/// {#DM}AttributeValueSortName2[DME_ATTRIBUTE[#AttributeKind, #AttributeName, %rawHxAttributeForm⟪ { #HxSort1# : #HxSort2# } ⟫, #AttributeOptions], #SortName] → U-SortName[#HxSort2#];
/// -[Data[#_]]: {#DM}AttributeValueSortName2[$[NotMatch,DME_ATTRIBUTE[#AttributeKind, #AttributeName, #AttributeForm, #AttributeOptions],#_], #SortName] → $[Error,"No declaration of attribute"] ;
///
/// {$String : DeclarationMapEntry} AttributeKeyU-SortName[$String] :: $String;
/// {#DM}AttributeKeyU-SortName[#SortName] → {#DM}AttributeKeySortName1[$[{#DM}Get[DeclarationMapEntry], #SortName, DME_NONE], #SortName] ;
///
/// {$String : DeclarationMapEntry} AttributeKeySortName1[DeclarationMapEntry, $String] :: $String;
/// -[Data[#Entry]]:
/// {#DM}AttributeKeySortName1[#Entry, #SortName] → {#DM}AttributeKeySortName2[#Entry, #SortName] ;
///
/// {$String : DeclarationMapEntry} AttributeKeySortName2[DeclarationMapEntry, $String] :: $String;
/// {#DM}AttributeKeySortName2[DME_ATTRIBUTE[#AttributeKind, #AttributeName, %rawHxAttributeForm⟪ ( #HxSort# ) ⟫, #AttributeOptions], #SortName] → "" ;
/// {#DM}AttributeKeySortName2[DME_ATTRIBUTE[#AttributeKind, #AttributeName, %rawHxAttributeForm⟪ { #HxSort# } ⟫, #AttributeOptions], #SortName] → U-SortName[#HxSort#];
/// {#DM}AttributeKeySortName2[DME_ATTRIBUTE[#AttributeKind, #AttributeName, %rawHxAttributeForm⟪ { #HxSort1# : #HxSort2# } ⟫, #AttributeOptions], #SortName] → U-SortName[#HxSort1#];
/// {#DM}AttributeKeySortName2[$[NotMatch,DME_ATTRIBUTE[#AttributeKind, #AttributeName, #AttributeForm, #AttributeOptions],#_], #SortName] → "" ;
///
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// // Initialize otherwise unused maps.
///
/// {$String : DeclarationMapEntry} P-InitOtherMaps[$List[HxAttribute], $String] :: Text;
///
/// {#DM; "$AllInheritedMapNames" : NAMES[#InheritedMapNames]}
/// P-InitOtherMaps[#Attributes, #sep] → P-InitOtherMaps1[FoldWhen[ok a ns.ThenRemoveAttributeName[ok, a, ns], #Attributes, #InheritedMapNames], #sep, $False] ;
///
/// {$String : DeclarationMapEntry} P-CaptureOtherMaps[$List[HxAttribute]] :: Text;
/// {#DM; "$AllInheritedMapNames" : NAMES[#InheritedMapNames]}
/// P-CaptureOtherMaps[#Attributes] → P-InitOtherMaps1[FoldWhen[ok a ns.ThenRemoveAttributeName[ok, a, ns], #Attributes, #InheritedMapNames], "; ", $True] ;
///
/// ThenRemoveAttributeName[Ok, HxAttribute, NameSet] :: NameSet;
/// ThenRemoveAttributeName[OK, %rawHxAttribute⟪ #HxAttributeKind# #HxAttributeName# #HxAttributeValue# ⟫, #MapNames] → RemoveName[#MapNames, #HxAttributeName#] ;
///
/// P-InitOtherMaps1[NameSet, $String, $Boolean] :: Text;
/// P-InitOtherMaps1[#MapNames, #sep, #capture] → P-InitOtherMaps2[NameSetList[#MapNames], #sep, #capture] ;
///
/// P-InitOtherMaps2[$List[$String], $String, $Boolean] :: Text;
/// P-InitOtherMaps2[(), #sep, #capture] → %n⟪⟫ ;
/// P-InitOtherMaps2[(#a;#as), #sep, #capture] → %n⟪†«#sep»"†«#a»" : {« $[If, #capture, %n⟨#InheritedMap_†‹#a›⟩, %n⟨⟩] »}Inherited_†«#a»« P-InitOtherMaps2[#as, "; ", #capture] »⟫ ;
///
/// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
