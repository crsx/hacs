//// Hx.pgpre: HX PARSER PRE TERM PRODUCTIONS.
//// Copyright Â© 2012,2014 Kristoffer H. Rose <krisrose@rcsx.org>


//// STRUCTURE.

<Module> ::= {top-module}:hacspre <EmbeddedModule> .

<EmbeddedModule> ::= MODULE:hacspre <ModuleName> LBRACE <Storing_Declarations> RBRACE .

<Declarations> ::= ( {$Cons} <Declaration> <Declarations> | {$Nil} ).

<Declaration> ::=
  {embedded-module}:hacspre <EmbeddedModule> SEMI
| IMPORT:hacspre <ModuleName> ( LPAREN (<SortNames> | {$Nil}) RPAREN | {$Nil} ) SEMI

| SPACE:hacspre <RegExp> SEMI
| TOKEN ( {'token'}:hacspre <Store_SortName> BAR <RegExp> SEMI | FRAGMENT:hacspre <FragmentName> BAR <RegExp> SEMI )
| FRAGMENT:hacspre <FragmentName> BAR <RegExp> SEMI

| ATTRIBUTE:hacspre <AttributeKind> <AttributeName> <AttributeForm> <AttributeOptions> SEMI

| {sort}:hacspre (MAIN:hacspre|{no-main}:hacspre) SORT <Store_SortName> <Repeat> <SortAbstraction> SEMI
| {anonymous}:hacspre <SortAlternatives> SEMI
| (RULE)? {rule}:hacspre <Rule> SEMI
| {nestedDeclarations}:hacspre LBRACE <Declarations> RBRACE
.

<AttributeKind> ::= ( {AttributeKindUp}:hacspre UP | {AttributeKindDown}:hacspre DOWN ).


//// TOKEN DECLARATIONS.

<RegExp> (RE) ::= {$Cons} <RegExpChoice> ( BAR <RegExp> | {$Nil} ) .

<RegExpChoice> (RE) ::=
  NESTED:hacspre <RegExpSimple> <RegExpSimple>
| {RegExpConcat}:hacspre <RegExpUnits>
.

<RegExpUnits> (RE) ::= {$Cons} <RegExpUnit> <RegExpUnits> | {$Nil} .

<RegExpUnit> (RE) ::= {RegExpUnit}:hacspre <RegExpSimple> <Repeat> .

<Repeat> (DEFAULT,RE) ::=
  PLUS ( {RepeatSomeSep}:hacspre SUB (<RegExpLeaf> | {RegExpWord}:hacspre <Separator>) | {RepeatSome}:hacspre )
| {RepeatMaybeSome}:hacspre STAR
| {RepeatMaybe}:hacspre QUEST
| {RepeatSingle}:hacspre
.

<RegExpLeaf> (DEFAULT,RE) ::=
  {RegExpString}:hacspre <String>
| {RegExpWord}:hacspre <Word>
.

<RegExpSimple> (RE) ::=
  <RegExpLeaf>
| {RegExpRef}:hacspre <FragmentRef>
| {RegExpClass}:hacspre <RegExpClass>
| {RegExpAny}:hacspre DOT
| {RegExpClass}:hacspre {RegExpClassChar}:hacspre (ESCAPEDCHAR$) {RegExpClassDone}:hacspre
| {RegExpNest}:hacspre LPAREN <RegExp> RPAREN
.


//// ATTRIBUTE DECLARATIONS

<AttributeForm> ::=
  {AttributeFormSimple}:hacspre LPAREN <Sort> RPAREN
| LBRACE <Sort>:# ( {AttributeFormMap}:hacspre {{#}} COLON <Sort> RBRACE
                  | {AttributeFormSet}:hacspre {{#}} RBRACE )
.

<AttributeOptions> ::= {$Cons} <AttributeOption> <AttributeOptions> | {$Nil} .
<AttributeOption> ::= {AttributeOption}:hacspre <Variable> <Constructor> .


//// SORT PRODUCTION DECLARATIONS 

<SortNames> ::= {$Cons} <SortName> (COMMA <SortNames> | {$Nil}) . 

<SortAbstraction> ::=
  {SortAbstractionParam}:hacspre <Variable>^a <SortAbstraction>[a]
| {SortAbstractionBody}:hacspre <SortAlternatives>
.

<SortAlternatives> ::= {$Cons} <SortAlternative> <SortAlternatives> | {$Nil} .

<SortAlternative> ::= BAR (
  SCHEME:hacspre <Form>
| {SynthesizedRef}:hacspre UP <AttributeName> 
| SUGAR:hacspre <Form> ARROW <Term>
| SYMBOL:hacspre <Form>
| STATIC:hacspre (SYMBOL)? <Form>
| {data}:hacspre (DATA)? <Form> <Tagging>
).

<Form> ::=
  <Constructor>:#C
    ( {FormParsedSorted}:hacspre {{#C}} <ParsedForm> <FormPrec> <InheritedRefs>
    | {FormConstruction}:hacspre {{#C}} ( LPAREN (<BindersScopeSorts> | {$Nil}) RPAREN | {$Nil} ) <InheritedRefs>
    )
| {FormParsed}:hacspre <ParsedForm> <FormPrec> <InheritedRefs>
.

<BindersScopeSorts> ::= {$Cons} <BindersScopeSort> (COMMA <BindersScopeSorts> | {$Nil}) .

<BindersScopeSort> ::=
  <Sort>:#Sort
   ( {BinderScopeSort}:hacspre BINDS <Variable>!!! {{#Sort}} <BindersScopeSort>
   | {ScopeSort}:hacspre {{#Sort}} <Repeat> (LBRACKET <SubstituteSorts> RBRACKET | {$Nil})
   )
| {BinderScopeSort}:hacspre LBRACKET <Variable>!!! COLON <Sort> <BindersScopeSortTail>
.

<BindersScopeSortTail> ::=
  RBRACKET <BindersScopeSort>
| {BinderScopeSort}:hacspre COMMA <Variable>!!! COLON <Sort> <BindersScopeSortTail>
.

<SubstituteSorts> ::= {$Cons} <SubstituteSort> ( COMMA <SubstituteSorts> | {$Nil} ) | {$Nil}  . 
<SubstituteSort> ::= <Variable>!!!:#v ( {SubstituteSort}:hacspre {{#v}} (COLON|AS) <Sort> |
  {SubstituteNoSort}:hacspre {{#v}} ) .

<Sort> ::= {Sort}:hacspre <SimpleSort> <SimpleSorts> .

<SimpleSorts> ::= LPAREN ( {$Cons} <SimpleSort> <SimpleSortTail> | {$Nil} ) RPAREN | {$Nil} .
<SimpleSortTail> ::= COMMA {$Cons} <SimpleSort> <SimpleSortTail> | {$Nil} .

<SimpleSort> ::=
  {SortName}:hacspre <SortName> <MetaVariables>
| {SortParam}:hacspre <SortParam>
.
<MetaVariables> ::= {$Cons} <MetaVariable> {$Nil} | {$Nil} .
<SortParam> ::= <Variable>! .

<ScopeSortPrecRepeat> ::= {ScopeSortPrecRepeat}:hacspre <ScopeSort> <FormPrec> <Repeat> .
<ScopeSort> ::=
  <Sort>:#Sort
   ( {ScopeSortBinder}:hacspre BINDS <Variable>!!! {{#Sort}}
   | {ScopeSort}:hacspre {{#Sort}} <Repeat> (LBRACKET <SubstituteSorts> RBRACKET | {$Nil})
   )
| {ScopeSortBinder}:hacspre LBRACKET <Variable>!!! COLON <Sort> RBRACKET
.

<FormPrec> ::= ( AT <Natural> | {"0"} ) .

<Tagging> ::= ( {$Cons} TAG <Constructor> ({$Nil}) | {$Nil} ).

<InheritedRefs> ::=( {$Cons} <InheritedRef> <InheritedRefs> | {$Nil} ).
<InheritedRef> ::= {InheritedRef}:hacspre DOWN <AttributeName> . 

//// RULES.

<Rule> ::= {Rule}:hacspre <RulePrefix> <NotVariableTerm> ( ARROW <Term> | {OMITTED}:hacspre ) .

<RulePrefix> ::= {RuleOptions}:hacspre <Priority> ( LBRACKET (<Options> | {$Nil}) RBRACKET | {$Nil} ) .

<Priority> ::=( DEFAULT:hacspre | PRIORITY:hacspre | {Normal}:hacspre ).

<Options> ::= {$Cons} <Option> ( COMMA <Options> | {$Nil} ) .

<Option> ::=
  {OptionConstruction}:hacspre <Constructor> ( LBRACKET (<Options> | {$Nil}) RBRACKET | {$Nil} ) <Attributes>
| {OptionLiteral}:hacspre <Literal> <Attributes>
.
