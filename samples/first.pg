/* PG Grammar for HACS module net.sf.crsx.samples.gentle.First. */

/* INTERFACE. */

class net.sf.crsx.samples.gentle.FirstParser : <Term>,
  <Construction>

prefix first

////METAPG: declarations
////METAPG: %{
////METAPG: String unconcrete(String s) {return s.substring(1, s.length()-1).trim();}
////METAPG: String unmeta(String s, int skip) {return s.substring(1+skip, s.length()-1).trim();}
////METAPG: %}

%{
TOKEN_MGR_DECLS : { int nesting; int nestedState;} /* Used by all nesting constructs. */
%}


////METASORTS: /* META-TERM SORTS. */
////METASORTS:
////METASORTS: Sort_M_First_sTerm ::= (
  ////METASORTS: Node_M_First_sInt[TagSort_M_First_sInt, $List[Sort_M_First_sScope]];
  ////METASORTS: Node_M_First_sFloat[TagSort_M_First_sFloat, $List[Sort_M_First_sScope]];
  ////METASORTS: Node_M_First_sId[TagSort_M_First_sId, $List[Sort_M_First_sScope]];
  ////METASORTS: Node_M_First_sExp[TagSort_M_First_sExp, $List[Sort_M_First_sScope]];
  ////METASORTS: Node_M_First_sName[TagSort_M_First_sName, $List[Sort_M_First_sScope]];
  ////METASORTS: Node_M_First_sStat[TagSort_M_First_sStat, $List[Sort_M_First_sScope]];
  ////METASORTS: Node_M_First_sType[TagSort_M_First_sType, $List[Sort_M_First_sScope]];
  ////METASORTS: Node_M_First_st[TagSort_M_First_st, $List[Sort_M_First_sScope]];
  ////METASORTS: Node_M_First_se[TagSort_M_First_se, $List[Sort_M_First_sScope]];
  ////METASORTS: Node_M_First_sT[TagSort_M_First_sT, $List[Sort_M_First_sScope]];
  ////METASORTS: Node_M_First_sI_xProgr[TagSort_M_First_sI_xProgr, $List[Sort_M_First_sScope]];
  ////METASORTS: Node_M_First_sI_xInstr[TagSort_M_First_sI_xInstr, $List[Sort_M_First_sScope]];
  ////METASORTS: Node_M_First_sI_xArg[TagSort_M_First_sI_xArg, $List[Sort_M_First_sScope]];
  ////METASORTS: Node_M_First_sTmp[TagSort_M_First_sTmp, $List[Sort_M_First_sScope]];
  ////METASORTS: Node_M_First_sTmpType[TagSort_M_First_sTmpType, $List[Sort_M_First_sScope]];
  ////METASORTS: Node_M_First_sA_xProgr[TagSort_M_First_sA_xProgr, $List[Sort_M_First_sScope]];
  ////METASORTS: Node_M_First_sA_xInstr[TagSort_M_First_sA_xInstr, $List[Sort_M_First_sScope]];
  ////METASORTS: Node_M_First_sA_xArg[TagSort_M_First_sA_xArg, $List[Sort_M_First_sScope]];
  ////METASORTS: );
////METASORTS:
////METASORTS: Sort_M_First_sScope ::= (
  ////METASORTS: Tag_M_First_sBinder[binder :: Sort_M_First_sTerm . Sort_M_First_sScope];
  ////METASORTS: Tag_M_First_sSubterm[Sort_M_First_sTerm]; 
////METASORTS: );


/* GRAMMAR. */


/* Productions for Int token. */

<Int> ::= 
  ////METAPG: meta1_Int:unconcrete |
  ////METAPG: meta2_Int$$:[[unmeta(#,3)]]:{ [[ hxornaked("firstHxPresorted_Int") ]] } |
  {TOKEN_M_First_sInt} Int$ .
////SORT: Sort_M_First_sInt ::= ( TOKEN_M_First_sInt[$String]; );

////METAPG: %{
////METAPG: /* Meta token for Int. */ 
////METAPG: TOKEN : { < T_meta1_Int : ("\u27e8" (" ")* "Int" (" ")* "\u27e9") > }
////METAPG: MORE : { < "\u27e8" (" ")* "Int" (" ")* ~["\u27e8","\u27e9"] > { nesting = 0; nestedState = curLexState; } : IN_META_Int }
////METAPG: <IN_META_Int> MORE : { "\u27e8" { nesting = 1; } : IN_NESTED_META_Int }
////METAPG: <IN_NESTED_META_Int> MORE : { "\u27e8" { nesting++; } }
////METAPG: <IN_NESTED_META_Int> MORE : { "\u27e9" { if (--nesting <= 0) SwitchTo(IN_META_Int); } }
////METAPG: <IN_META_Int> TOKEN : { < T_meta2_Int : "\u27e9" > { SwitchTo(nestedState); } }
////METAPG: <IN_META_Int,IN_NESTED_META_Int> MORE : { < ~[] > }
////METAPG: %}

////METAPG: /* Hx terms of Int token sort. */
////METAPG: <Hx_Int> (HX) ::= (HX_TOKEN_Int)?  <HxPresorted_Int> .
////METAPG: <HxSorted_Int> (HX) ::= HX_TOKEN_Int <HxPresorted_Int> .
////METAPG: <HxPresorted_Int> (HX) ::=
////METAPG:   {HX_M_VariableUseSorted} ({Int}) ({HX_M_RepeatSingle}) (HX_VARIABLE!!!) <HxAttributes>
////METAPG: | {HX_M_MetaApplicationSorted} ({Int}) ({HX_M_RepeatSingle}) (HX_META_VARIABLE$) ( HX_LBRACKET <HxTerms>  HX_RBRACKET | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_UnparsedSorted} ({Int}) ({HX_M_RepeatSingle}) (HX_CONCRETE$:unconcrete) <HxAttributes>
////METAPG: .
////METAPG: token HX_TOKEN_Int (HX) ::= "Int" .


/* Productions for Float token. */

<Float> ::= 
  ////METAPG: meta1_Float:unconcrete |
  ////METAPG: meta2_Float$$:[[unmeta(#,5)]]:{ [[ hxornaked("firstHxPresorted_Float") ]] } |
  {TOKEN_M_First_sFloat} Float$ .
////SORT: Sort_M_First_sFloat ::= ( TOKEN_M_First_sFloat[$String]; );

////METAPG: %{
////METAPG: /* Meta token for Float. */ 
////METAPG: TOKEN : { < T_meta1_Float : ("\u27e8" (" ")* "Float" (" ")* "\u27e9") > }
////METAPG: MORE : { < "\u27e8" (" ")* "Float" (" ")* ~["\u27e8","\u27e9"] > { nesting = 0; nestedState = curLexState; } : IN_META_Float }
////METAPG: <IN_META_Float> MORE : { "\u27e8" { nesting = 1; } : IN_NESTED_META_Float }
////METAPG: <IN_NESTED_META_Float> MORE : { "\u27e8" { nesting++; } }
////METAPG: <IN_NESTED_META_Float> MORE : { "\u27e9" { if (--nesting <= 0) SwitchTo(IN_META_Float); } }
////METAPG: <IN_META_Float> TOKEN : { < T_meta2_Float : "\u27e9" > { SwitchTo(nestedState); } }
////METAPG: <IN_META_Float,IN_NESTED_META_Float> MORE : { < ~[] > }
////METAPG: %}

////METAPG: /* Hx terms of Float token sort. */
////METAPG: <Hx_Float> (HX) ::= (HX_TOKEN_Float)?  <HxPresorted_Float> .
////METAPG: <HxSorted_Float> (HX) ::= HX_TOKEN_Float <HxPresorted_Float> .
////METAPG: <HxPresorted_Float> (HX) ::=
////METAPG:   {HX_M_VariableUseSorted} ({Float}) ({HX_M_RepeatSingle}) (HX_VARIABLE!!!) <HxAttributes>
////METAPG: | {HX_M_MetaApplicationSorted} ({Float}) ({HX_M_RepeatSingle}) (HX_META_VARIABLE$) ( HX_LBRACKET <HxTerms>  HX_RBRACKET | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_UnparsedSorted} ({Float}) ({HX_M_RepeatSingle}) (HX_CONCRETE$:unconcrete) <HxAttributes>
////METAPG: .
////METAPG: token HX_TOKEN_Float (HX) ::= "Float" .


/* Productions for Id token. */

<Id> ::= 
  ////METAPG: meta1_Id:unconcrete |
  ////METAPG: meta2_Id$$:[[unmeta(#,2)]]:{ [[ hxornaked("firstHxPresorted_Id") ]] } |
  {TOKEN_M_First_sId} Id$ .
////SORT: Sort_M_First_sId ::= ( TOKEN_M_First_sId[$String]; );

////METAPG: %{
////METAPG: /* Meta token for Id. */ 
////METAPG: TOKEN : { < T_meta1_Id : ("\u27e8" (" ")* "Id" (" ")* "\u27e9") > }
////METAPG: MORE : { < "\u27e8" (" ")* "Id" (" ")* ~["\u27e8","\u27e9"] > { nesting = 0; nestedState = curLexState; } : IN_META_Id }
////METAPG: <IN_META_Id> MORE : { "\u27e8" { nesting = 1; } : IN_NESTED_META_Id }
////METAPG: <IN_NESTED_META_Id> MORE : { "\u27e8" { nesting++; } }
////METAPG: <IN_NESTED_META_Id> MORE : { "\u27e9" { if (--nesting <= 0) SwitchTo(IN_META_Id); } }
////METAPG: <IN_META_Id> TOKEN : { < T_meta2_Id : "\u27e9" > { SwitchTo(nestedState); } }
////METAPG: <IN_META_Id,IN_NESTED_META_Id> MORE : { < ~[] > }
////METAPG: %}

////METAPG: /* Hx terms of Id token sort. */
////METAPG: <Hx_Id> (HX) ::= (HX_TOKEN_Id)?  <HxPresorted_Id> .
////METAPG: <HxSorted_Id> (HX) ::= HX_TOKEN_Id <HxPresorted_Id> .
////METAPG: <HxPresorted_Id> (HX) ::=
////METAPG:   {HX_M_VariableUseSorted} ({Id}) ({HX_M_RepeatSingle}) (HX_VARIABLE!!!) <HxAttributes>
////METAPG: | {HX_M_MetaApplicationSorted} ({Id}) ({HX_M_RepeatSingle}) (HX_META_VARIABLE$) ( HX_LBRACKET <HxTerms>  HX_RBRACKET | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_UnparsedSorted} ({Id}) ({HX_M_RepeatSingle}) (HX_CONCRETE$:unconcrete) <HxAttributes>
////METAPG: .
////METAPG: token HX_TOKEN_Id (HX) ::= "Id" .
/* Productions for Exp sort with precedence 0. */

<Exp> ::= ("TA" <Exp>:#_Exp_1  {{ Node_M_First_sExp[Tag_M_First_sExp_x_xM_xTA, (#_Exp_1;)]}} 
  |  <Exp1>:#_Exp_1  {{#_Exp_1}} ) . 


////SORT: TagSort_M_First_sExp ::= ( Tag_M_First_sExp_x_xM_xTA; Tag_M_First_sExp_xExp;  );

////METAELIM: Node_M_First_sExp[Tag_M_First_sExp_x_xM_xTA, (#_Exp_1;)];
 ////METAELIM: Node_M_First_sExp[Tag_M_First_sExp_xExp, (#_Exp_1;)]; 

/* Productions for Exp sort with precedence 1. */

<Exp1> ::= ( <Exp1>:#_Exp_1 "+" <Exp2>:#_Exp_2  {{ Node_M_First_sExp[Tag_M_First_sExp1_xExp, (#_Exp_1; #_Exp_2;)]}}  
  |  <Exp2>:#_Exp_1  {{#_Exp_1}} ) . 


////SORT: TagSort_M_First_sExp ::= ( Tag_M_First_sExp1_xExp; Tag_M_First_sExp1_xExp;  );

////METAELIM: Node_M_First_sExp[Tag_M_First_sExp1_xExp, (#_Exp_1; #_Exp_2;)];
 ////METAELIM: Node_M_First_sExp[Tag_M_First_sExp1_xExp, (#_Exp_1;)]; 

/* Productions for Exp sort with precedence 2. */

<Exp2> ::= ( <Exp2>:#_Exp_1 "*" <Exp3>:#_Exp_2  {{ Node_M_First_sExp[Tag_M_First_sExp2_xExp, (#_Exp_1; #_Exp_2;)]}}  
  |  <Exp3>:#_Exp_1  {{#_Exp_1}} ) . 


////SORT: TagSort_M_First_sExp ::= ( Tag_M_First_sExp2_xExp; Tag_M_First_sExp2_xExp;  );

////METAELIM: Node_M_First_sExp[Tag_M_First_sExp2_xExp, (#_Exp_1; #_Exp_2;)];
 ////METAELIM: Node_M_First_sExp[Tag_M_First_sExp2_xExp, (#_Exp_1;)]; 



/* Productions for Exp sort with (highest) precedence 3. */

<Exp3> ::= 
  ////METAPG: meta1_Exp:unconcrete |
  ////METAPG: meta2_Exp$$:[[unmeta(#,3)]]:{ [[ hxornaked("firstHxPresorted_Exp") ]] } |
  ("(" <Exp>:# ")" {{ Node_M_First_sExp[Tag_M_First_sExp3_x_xM_x_x28, (#;)]}} 
  | ( <Int>:#_Int_1  {{ Node_M_First_sExp[Tag_M_First_sExp3_xInt, (#_Int_1;)]}} 
  | ( <Float>:#_Float_1  {{ Node_M_First_sExp[Tag_M_First_sExp3_xFloat, (#_Float_1;)]}} 
  |  <Name>:#_Name_1  {{ Node_M_First_sExp[Tag_M_First_sExp3_xName, (#_Name_1;)]}} ))) . 


////SORT: TagSort_M_First_sExp ::= ( Tag_M_First_sExp3_x_xM_x_x28; Tag_M_First_sExp3_xInt; Tag_M_First_sExp3_xFloat; Tag_M_First_sExp3_xName;  );
 ////METAELIM: Node_M_First_sExp[Tag_M_First_sExp3_x_xM_x_x28, (#;)];  ////METAELIM: Node_M_First_sExp[Tag_M_First_sExp3_xInt, (#_Int_1;)]; 
////METAELIM: Node_M_First_sExp[Tag_M_First_sExp3_xFloat, (#_Float_1;)];

////METAELIM: Node_M_First_sExp[Tag_M_First_sExp3_xName, (#_Name_1;)];


////METAPG: %{
////METAPG: /* Meta token for Exp. */ 
////METAPG: TOKEN : { < T_meta1_Exp : ("\u27e8" (" ")* "Exp" (" ")* "\u27e9") > }
////METAPG: MORE : { < "\u27e8" (" ")* "Exp" (" ")* ~["\u27e8","\u27e9"] > { nesting = 0; nestedState = curLexState; } : IN_META_Exp }
////METAPG: <IN_META_Exp> MORE : { "\u27e8" { nesting = 1; } : IN_NESTED_META_Exp }
////METAPG: <IN_NESTED_META_Exp> MORE : { "\u27e8" { nesting++; } }
////METAPG: <IN_NESTED_META_Exp> MORE : { "\u27e9" { if (--nesting <= 0) SwitchTo(IN_META_Exp); } }
////METAPG: <IN_META_Exp> TOKEN : { < T_meta2_Exp : "\u27e9" > { SwitchTo(nestedState); } }
////METAPG: <IN_META_Exp,IN_NESTED_META_Exp> MORE : { < ~[] > }
////METAPG: %}




////METAPG: /* Hx terms of Exp production sort. */
////METAPG: <Hx_Exp> (HX) ::= (HX_TOKEN_Exp)?  <HxPresorted_Exp> .
////METAPG: <HxSorted_Exp> (HX) ::= HX_TOKEN_Exp <HxPresorted_Exp> .
////METAPG: <HxPresorted_Exp> (HX) ::=
////METAPG:   {HX_M_VariableUseSorted} ({Exp}) ({HX_M_RepeatSingle}) (HX_VARIABLE!!!) <HxAttributes>
////METAPG: | {HX_M_MetaApplicationSorted} ({Exp}) ({HX_M_RepeatSingle}) (HX_META_VARIABLE$) ( HX_LBRACKET <HxTerms> HX_RBRACKET | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_ConstructionSorted} ({Exp}) ({HX_M_RepeatSingle}) (HX_CONSTRUCTOR$) ( HX_LBRACKET <HxScopes> HX_RBRACKET | HX_LPAREN <HxTerms> HX_RPAREN | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_UnparsedSorted} ({Exp}) ({HX_M_RepeatSingle}) (HX_CONCRETE$:unconcrete) <HxAttributes>
////METAPG: 
////METAPG: .
////METAPG: token HX_TOKEN_Exp (HX) ::= "Exp" .
////METAPG: 



/* Productions for Name sort with (highest) precedence 0. */

<Name> ::= 
  ////METAPG: meta1_Name:unconcrete |
  ////METAPG: meta2_Name$$:[[unmeta(#,4)]]:{ [[ hxornaked("firstHxPresorted_Name") ]] } |
   <Id>!!!:#_Id_1  {{#_Id_1}}  . 


////SORT: TagSort_M_First_sName ::= ( Tag_M_First_sName_xId;  );
////METAELIM: Node_M_First_sName[Tag_M_First_sName_xId, (#_Id_1;)]; 

////METAPG: %{
////METAPG: /* Meta token for Name. */ 
////METAPG: TOKEN : { < T_meta1_Name : ("\u27e8" (" ")* "Name" (" ")* "\u27e9") > }
////METAPG: MORE : { < "\u27e8" (" ")* "Name" (" ")* ~["\u27e8","\u27e9"] > { nesting = 0; nestedState = curLexState; } : IN_META_Name }
////METAPG: <IN_META_Name> MORE : { "\u27e8" { nesting = 1; } : IN_NESTED_META_Name }
////METAPG: <IN_NESTED_META_Name> MORE : { "\u27e8" { nesting++; } }
////METAPG: <IN_NESTED_META_Name> MORE : { "\u27e9" { if (--nesting <= 0) SwitchTo(IN_META_Name); } }
////METAPG: <IN_META_Name> TOKEN : { < T_meta2_Name : "\u27e9" > { SwitchTo(nestedState); } }
////METAPG: <IN_META_Name,IN_NESTED_META_Name> MORE : { < ~[] > }
////METAPG: %}

////METAPG: /* Hx terms of Name production sort. */
////METAPG: <Hx_Name> (HX) ::= (HX_TOKEN_Name)?  <HxPresorted_Name> .
////METAPG: <HxSorted_Name> (HX) ::= HX_TOKEN_Name <HxPresorted_Name> .
////METAPG: <HxPresorted_Name> (HX) ::=
////METAPG:   {HX_M_VariableUseSorted} ({Name}) ({HX_M_RepeatSingle}) (HX_VARIABLE!!!) <HxAttributes>
////METAPG: | {HX_M_MetaApplicationSorted} ({Name}) ({HX_M_RepeatSingle}) (HX_META_VARIABLE$) ( HX_LBRACKET <HxTerms> HX_RBRACKET | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_ConstructionSorted} ({Name}) ({HX_M_RepeatSingle}) (HX_CONSTRUCTOR$) ( HX_LBRACKET <HxScopes> HX_RBRACKET | HX_LPAREN <HxTerms> HX_RPAREN | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_UnparsedSorted} ({Name}) ({HX_M_RepeatSingle}) (HX_CONCRETE$:unconcrete) <HxAttributes>
////METAPG: 
////METAPG: .
////METAPG: token HX_TOKEN_Name (HX) ::= "Name" .
////METAPG: 



/* Productions for Stat sort with (highest) precedence 0. */

<Stat> ::= 
  ////METAPG: meta1_Stat:unconcrete |
  ////METAPG: meta2_Stat$$:[[unmeta(#,4)]]:{ [[ hxornaked("firstHxPresorted_Stat") ]] } |
  ("TA" <Stat>:#_Stat_1  {{ Node_M_First_sStat[Tag_M_First_sStat_x_xM_xTA, (#_Stat_1;)]}} 
  | ("TA2" <Stat>:#_Stat_1  {{ Node_M_First_sStat[Tag_M_First_sStat_x_xM_xTA2, (#_Stat_1;)]}} 
  | ("{" <Stat_MaybeSome>:#_Stat_1 "}" {{ Node_M_First_sStat[Tag_M_First_sStat_x_xM_x_x7b, (#_Stat_1;)]}} 
  |  <Name>:#_Name_1 ":=" <Exp>:#_Exp_2 ";" {{ Node_M_First_sStat[Tag_M_First_sStat_xName, (#_Name_1; #_Exp_2;)]}}  ))) . 


////SORT: TagSort_M_First_sStat ::= ( Tag_M_First_sStat_x_xM_xTA; Tag_M_First_sStat_x_xM_xTA2; Tag_M_First_sStat_x_xM_x_x7b; Tag_M_First_sStat_xName;  );

////METAELIM: Node_M_First_sStat[Tag_M_First_sStat_x_xM_xTA, (#_Stat_1;)];

////METAELIM: Node_M_First_sStat[Tag_M_First_sStat_x_xM_xTA2, (#_Stat_1;)];

////METAELIM: Node_M_First_sStat[Tag_M_First_sStat_x_xM_x_x7b, (#_Stat_1;)];

////METAELIM: Node_M_First_sStat[Tag_M_First_sStat_xName, (#_Name_1; #_Exp_2;)];


////METAPG: %{
////METAPG: /* Meta token for Stat. */ 
////METAPG: TOKEN : { < T_meta1_Stat : ("\u27e8" (" ")* "Stat" (" ")* "\u27e9") > }
////METAPG: MORE : { < "\u27e8" (" ")* "Stat" (" ")* ~["\u27e8","\u27e9"] > { nesting = 0; nestedState = curLexState; } : IN_META_Stat }
////METAPG: <IN_META_Stat> MORE : { "\u27e8" { nesting = 1; } : IN_NESTED_META_Stat }
////METAPG: <IN_NESTED_META_Stat> MORE : { "\u27e8" { nesting++; } }
////METAPG: <IN_NESTED_META_Stat> MORE : { "\u27e9" { if (--nesting <= 0) SwitchTo(IN_META_Stat); } }
////METAPG: <IN_META_Stat> TOKEN : { < T_meta2_Stat : "\u27e9" > { SwitchTo(nestedState); } }
////METAPG: <IN_META_Stat,IN_NESTED_META_Stat> MORE : { < ~[] > }
////METAPG: %}

////METAPG: /* Hx terms of Stat production sort. */
////METAPG: <Hx_Stat> (HX) ::= (HX_TOKEN_Stat)?  <HxPresorted_Stat> .
////METAPG: <HxSorted_Stat> (HX) ::= HX_TOKEN_Stat <HxPresorted_Stat> .
////METAPG: <HxPresorted_Stat> (HX) ::=
////METAPG:   {HX_M_VariableUseSorted} ({Stat}) ({HX_M_RepeatSingle}) (HX_VARIABLE!!!) <HxAttributes>
////METAPG: | {HX_M_MetaApplicationSorted} ({Stat}) ({HX_M_RepeatSingle}) (HX_META_VARIABLE$) ( HX_LBRACKET <HxTerms> HX_RBRACKET | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_ConstructionSorted} ({Stat}) ({HX_M_RepeatSingle}) (HX_CONSTRUCTOR$) ( HX_LBRACKET <HxScopes> HX_RBRACKET | HX_LPAREN <HxTerms> HX_RPAREN | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_UnparsedSorted} ({Stat}) ({HX_M_RepeatSingle}) (HX_CONCRETE$:unconcrete) <HxAttributes>
////METAPG: 
////METAPG: .
////METAPG: token HX_TOKEN_Stat (HX) ::= "Stat" .
////METAPG: 


////METAPG: /* Hx terms of Type production sort. */
////METAPG: <Hx_Type> (HX) ::= (HX_TOKEN_Type)?  <HxPresorted_Type> .
////METAPG: <HxSorted_Type> (HX) ::= HX_TOKEN_Type <HxPresorted_Type> .
////METAPG: <HxPresorted_Type> (HX) ::=
////METAPG:   {HX_M_VariableUseSorted} ({Type}) ({HX_M_RepeatSingle}) (HX_VARIABLE!!!) <HxAttributes>
////METAPG: | {HX_M_MetaApplicationSorted} ({Type}) ({HX_M_RepeatSingle}) (HX_META_VARIABLE$) ( HX_LBRACKET <HxTerms> HX_RBRACKET | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_ConstructionSorted} ({Type}) ({HX_M_RepeatSingle}) (HX_CONSTRUCTOR$) ( HX_LBRACKET <HxScopes> HX_RBRACKET | HX_LPAREN <HxTerms> HX_RPAREN | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_UnparsedSorted} ({Type}) ({HX_M_RepeatSingle}) (HX_CONCRETE$:unconcrete) <HxAttributes>
////METAPG: | HX_TOKEN_Int$ ( HX_LPAREN HX_RPAREN )?  | HX_TOKEN_Float$ ( HX_LPAREN HX_RPAREN )?  | HX_TOKEN_Unif$  HX_LPAREN <Hx_Type> HX_COMMA <Hx_Type> HX_RPAREN  
////METAPG: .
////METAPG: token HX_TOKEN_Type (HX) ::= "Type" .
////METAPG: token HX_TOKEN_Int (HX) ::= "Int" . token HX_TOKEN_Float (HX) ::= "Float" . token HX_TOKEN_Unif (HX) ::= "Unif" . 


////METAPG: <HxAttributeSynthesized_t> (HX) ::= {HX_M_Attribute} ({HX_M_AttributeKindUp}) (HX_TOKEN_t$) HX_LPAREN {HX_M_AttributeValue} <Hx_Type> HX_RPAREN .
////METAPG: token HX_TOKEN_t (HX) ::= "t" . 

////METAPG: <HxAttributeInherited_e> (HX) ::= {HX_M_Attribute} ({HX_M_AttributeKindDown}) (HX_TOKEN_e$) HX_LBRACE {HX_M_AttributeKeyValue} <Hx_Name> HX_COLON <Hx_Type> HX_RBRACE .
    ////METAPG: token HX_TOKEN_e (HX) ::= "e" . 
    

/* Productions for T token. */

<T> ::= 
  ////METAPG: meta1_T:unconcrete |
  ////METAPG: meta2_T$$:[[unmeta(#,1)]]:{ [[ hxornaked("firstHxPresorted_T") ]] } |
  {TOKEN_M_First_sT} T$ .
////SORT: Sort_M_First_sT ::= ( TOKEN_M_First_sT[$String]; );

////METAPG: %{
////METAPG: /* Meta token for T. */ 
////METAPG: TOKEN : { < T_meta1_T : ("\u27e8" (" ")* "T" (" ")* "\u27e9") > }
////METAPG: MORE : { < "\u27e8" (" ")* "T" (" ")* ~["\u27e8","\u27e9"] > { nesting = 0; nestedState = curLexState; } : IN_META_T }
////METAPG: <IN_META_T> MORE : { "\u27e8" { nesting = 1; } : IN_NESTED_META_T }
////METAPG: <IN_NESTED_META_T> MORE : { "\u27e8" { nesting++; } }
////METAPG: <IN_NESTED_META_T> MORE : { "\u27e9" { if (--nesting <= 0) SwitchTo(IN_META_T); } }
////METAPG: <IN_META_T> TOKEN : { < T_meta2_T : "\u27e9" > { SwitchTo(nestedState); } }
////METAPG: <IN_META_T,IN_NESTED_META_T> MORE : { < ~[] > }
////METAPG: %}

////METAPG: /* Hx terms of T token sort. */
////METAPG: <Hx_T> (HX) ::= (HX_TOKEN_T)?  <HxPresorted_T> .
////METAPG: <HxSorted_T> (HX) ::= HX_TOKEN_T <HxPresorted_T> .
////METAPG: <HxPresorted_T> (HX) ::=
////METAPG:   {HX_M_VariableUseSorted} ({T}) ({HX_M_RepeatSingle}) (HX_VARIABLE!!!) <HxAttributes>
////METAPG: | {HX_M_MetaApplicationSorted} ({T}) ({HX_M_RepeatSingle}) (HX_META_VARIABLE$) ( HX_LBRACKET <HxTerms>  HX_RBRACKET | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_UnparsedSorted} ({T}) ({HX_M_RepeatSingle}) (HX_CONCRETE$:unconcrete) <HxAttributes>
////METAPG: .
////METAPG: token HX_TOKEN_T (HX) ::= "T" .


/* Productions for I_Progr sort with (highest) precedence 0. */

<I_Progr> ::= 
  ////METAPG: meta1_I_Progr:unconcrete |
  ////METAPG: meta2_I_Progr$$:[[unmeta(#,7)]]:{ [[ hxornaked("firstHxPresorted_I_Progr") ]] } |
  ("ICG" <Stat>:#_Stat_1  {{ Node_M_First_sI_xProgr[Tag_M_First_sI_xProgr_x_xM_xICG, (#_Stat_1;)]}} 
  | ("ICGExp" <Tmp>:#_Tmp_1  <Exp>:#_Exp_2  {{ Node_M_First_sI_xProgr[Tag_M_First_sI_xProgr_x_xM_xICGExp, (#_Tmp_1; #_Exp_2;)]}}  
  | ("{" <I_Progr>:#_I_Progr_1 "}" <I_Progr>:#_I_Progr_2  {{ Node_M_First_sI_xProgr[Tag_M_First_sI_xProgr_x_xM_x_x7b, (#_I_Progr_1; #_I_Progr_2;)]}}  
  | ( <I_Instr>:#_I_Instr_1  <I_Progr>:#_I_Progr_2  {{ Node_M_First_sI_xProgr[Tag_M_First_sI_xProgr_xI_xInstr, (#_I_Instr_1; #_I_Progr_2;)]}}  
  |  {{ Node_M_First_sI_xProgr[Tag†« $TextChars[
     $[
      Mangle,
      $[
       Trim,
       $[
        If,
        $[
         StartsWith,
         StringJoin2[
          "EMPTY",
          "_",
          {
            $LineLocation : STRING[91];
            $FileLocation : STRING["../samples/first.hx"];
            $ColumnLocation : STRING[6]}
           "I_Progr"],
         $],
        StringJoin2[
         "EMPTY",
         "_",
         {
           $LineLocation : STRING[91];
           $FileLocation : STRING["../samples/first.hx"];
           $ColumnLocation : STRING[6]}
          "I_Progr"],
        $[
         :,
         "First",
         $,
         StringJoin2[
          "EMPTY",
          "_",
          {
            $LineLocation : STRING[91];
            $FileLocation : STRING["../samples/first.hx"];
            $ColumnLocation : STRING[6]}
           "I_Progr"]]]]]] »]}})))) . 


////SORT: TagSort_M_First_sI_xProgr ::= ( Tag_M_First_sI_xProgr_x_xM_xICG; Tag_M_First_sI_xProgr_x_xM_xICGExp; Tag_M_First_sI_xProgr_x_xM_x_x7b; Tag_M_First_sI_xProgr_xI_xInstr; Tag†« $TextChars[
 $[
  Mangle,
  $[
   Trim,
   $[
    If,
    $[
     StartsWith,
     StringJoin2[
      "EMPTY",
      "_",
      {
        $LineLocation : STRING[91];
        $FileLocation : STRING["../samples/first.hx"];
        $ColumnLocation : STRING[6]}
       "I_Progr"],
     $],
    StringJoin2[
     "EMPTY",
     "_",
     {
       $LineLocation : STRING[91];
       $FileLocation : STRING["../samples/first.hx"];
       $ColumnLocation : STRING[6]}
      "I_Progr"],
    $[
     :,
     "First",
     $,
     StringJoin2[
      "EMPTY",
      "_",
      {
        $LineLocation : STRING[91];
        $FileLocation : STRING["../samples/first.hx"];
        $ColumnLocation : STRING[6]}
       "I_Progr"]]]]]] »;  );

////METAELIM: Node_M_First_sI_xProgr[Tag_M_First_sI_xProgr_x_xM_xICG, (#_Stat_1;)];

////METAELIM: Node_M_First_sI_xProgr[Tag_M_First_sI_xProgr_x_xM_xICGExp, (#_Tmp_1; #_Exp_2;)];

////METAELIM: Node_M_First_sI_xProgr[Tag_M_First_sI_xProgr_x_xM_x_x7b, (#_I_Progr_1; #_I_Progr_2;)];

////METAELIM: Node_M_First_sI_xProgr[Tag_M_First_sI_xProgr_xI_xInstr, (#_I_Instr_1; #_I_Progr_2;)];

////METAELIM: Node_M_First_sI_xProgr[Tag†« $TextChars[
 $[
  Mangle,
  $[
   Trim,
   $[
    If,
    $[
     StartsWith,
     StringJoin2[
      "EMPTY",
      "_",
      {
        $LineLocation : STRING[91];
        $FileLocation : STRING["../samples/first.hx"];
        $ColumnLocation : STRING[6]}
       "I_Progr"],
     $],
    StringJoin2[
     "EMPTY",
     "_",
     {
       $LineLocation : STRING[91];
       $FileLocation : STRING["../samples/first.hx"];
       $ColumnLocation : STRING[6]}
      "I_Progr"],
    $[
     :,
     "First",
     $,
     StringJoin2[
      "EMPTY",
      "_",
      {
        $LineLocation : STRING[91];
        $FileLocation : STRING["../samples/first.hx"];
        $ColumnLocation : STRING[6]}
       "I_Progr"]]]]]] »];


////METAPG: %{
////METAPG: /* Meta token for I_Progr. */ 
////METAPG: TOKEN : { < T_meta1_I_Progr : ("\u27e8" (" ")* "I_Progr" (" ")* "\u27e9") > }
////METAPG: MORE : { < "\u27e8" (" ")* "I_Progr" (" ")* ~["\u27e8","\u27e9"] > { nesting = 0; nestedState = curLexState; } : IN_META_I_Progr }
////METAPG: <IN_META_I_Progr> MORE : { "\u27e8" { nesting = 1; } : IN_NESTED_META_I_Progr }
////METAPG: <IN_NESTED_META_I_Progr> MORE : { "\u27e8" { nesting++; } }
////METAPG: <IN_NESTED_META_I_Progr> MORE : { "\u27e9" { if (--nesting <= 0) SwitchTo(IN_META_I_Progr); } }
////METAPG: <IN_META_I_Progr> TOKEN : { < T_meta2_I_Progr : "\u27e9" > { SwitchTo(nestedState); } }
////METAPG: <IN_META_I_Progr,IN_NESTED_META_I_Progr> MORE : { < ~[] > }
////METAPG: %}

////METAPG: /* Hx terms of I_Progr production sort. */
////METAPG: <Hx_I_Progr> (HX) ::= (HX_TOKEN_I_Progr)?  <HxPresorted_I_Progr> .
////METAPG: <HxSorted_I_Progr> (HX) ::= HX_TOKEN_I_Progr <HxPresorted_I_Progr> .
////METAPG: <HxPresorted_I_Progr> (HX) ::=
////METAPG:   {HX_M_VariableUseSorted} ({I_Progr}) ({HX_M_RepeatSingle}) (HX_VARIABLE!!!) <HxAttributes>
////METAPG: | {HX_M_MetaApplicationSorted} ({I_Progr}) ({HX_M_RepeatSingle}) (HX_META_VARIABLE$) ( HX_LBRACKET <HxTerms> HX_RBRACKET | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_ConstructionSorted} ({I_Progr}) ({HX_M_RepeatSingle}) (HX_CONSTRUCTOR$) ( HX_LBRACKET <HxScopes> HX_RBRACKET | HX_LPAREN <HxTerms> HX_RPAREN | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_UnparsedSorted} ({I_Progr}) ({HX_M_RepeatSingle}) (HX_CONCRETE$:unconcrete) <HxAttributes>
////METAPG: 
////METAPG: .
////METAPG: token HX_TOKEN_I_Progr (HX) ::= "I_Progr" .
////METAPG: 



/* Productions for I_Instr sort with (highest) precedence 0. */

<I_Instr> ::= 
  ////METAPG: meta1_I_Instr:unconcrete |
  ////METAPG: meta2_I_Instr$$:[[unmeta(#,7)]]:{ [[ hxornaked("firstHxPresorted_I_Instr") ]] } |
  ( <Tmp>:#_Tmp_1 "=" <I_Arg>:#_I_Arg_2 ("*" <I_Arg>:#_I_Arg_3 ";" {{ Node_M_First_sI_xInstr[Tag_M_First_sI_xInstr_xTmp, (#_Tmp_1; #_I_Arg_2; #_I_Arg_3;)]}} 
            | ("+" <I_Arg>:#_I_Arg_3 ";" {{ Node_M_First_sI_xInstr[Tag_M_First_sI_xInstr_xTmp, (#_Tmp_1; #_I_Arg_2; #_I_Arg_3;)]}} 
            | ";" {{ Node_M_First_sI_xInstr[Tag_M_First_sI_xInstr_xTmp, (#_Tmp_1; #_I_Arg_2;)]}}))  
  |  <Name>:#_Name_1 "=" <Tmp>:#_Tmp_2 ";" {{ Node_M_First_sI_xInstr[Tag_M_First_sI_xInstr_xName, (#_Name_1; #_Tmp_2;)]}}  ) . 


////SORT: TagSort_M_First_sI_xInstr ::= ( Tag_M_First_sI_xInstr_xTmp; Tag_M_First_sI_xInstr_xTmp; Tag_M_First_sI_xInstr_xTmp; Tag_M_First_sI_xInstr_xName;  );

////METAELIM: Node_M_First_sI_xInstr[Tag_M_First_sI_xInstr_xTmp, (#_Tmp_1; #_I_Arg_2; #_I_Arg_3;)];

////METAELIM: Node_M_First_sI_xInstr[Tag_M_First_sI_xInstr_xTmp, (#_Tmp_1; #_I_Arg_2; #_I_Arg_3;)];

////METAELIM: Node_M_First_sI_xInstr[Tag_M_First_sI_xInstr_xTmp, (#_Tmp_1; #_I_Arg_2;)];

////METAELIM: Node_M_First_sI_xInstr[Tag_M_First_sI_xInstr_xName, (#_Name_1; #_Tmp_2;)];


////METAPG: %{
////METAPG: /* Meta token for I_Instr. */ 
////METAPG: TOKEN : { < T_meta1_I_Instr : ("\u27e8" (" ")* "I_Instr" (" ")* "\u27e9") > }
////METAPG: MORE : { < "\u27e8" (" ")* "I_Instr" (" ")* ~["\u27e8","\u27e9"] > { nesting = 0; nestedState = curLexState; } : IN_META_I_Instr }
////METAPG: <IN_META_I_Instr> MORE : { "\u27e8" { nesting = 1; } : IN_NESTED_META_I_Instr }
////METAPG: <IN_NESTED_META_I_Instr> MORE : { "\u27e8" { nesting++; } }
////METAPG: <IN_NESTED_META_I_Instr> MORE : { "\u27e9" { if (--nesting <= 0) SwitchTo(IN_META_I_Instr); } }
////METAPG: <IN_META_I_Instr> TOKEN : { < T_meta2_I_Instr : "\u27e9" > { SwitchTo(nestedState); } }
////METAPG: <IN_META_I_Instr,IN_NESTED_META_I_Instr> MORE : { < ~[] > }
////METAPG: %}

////METAPG: /* Hx terms of I_Instr production sort. */
////METAPG: <Hx_I_Instr> (HX) ::= (HX_TOKEN_I_Instr)?  <HxPresorted_I_Instr> .
////METAPG: <HxSorted_I_Instr> (HX) ::= HX_TOKEN_I_Instr <HxPresorted_I_Instr> .
////METAPG: <HxPresorted_I_Instr> (HX) ::=
////METAPG:   {HX_M_VariableUseSorted} ({I_Instr}) ({HX_M_RepeatSingle}) (HX_VARIABLE!!!) <HxAttributes>
////METAPG: | {HX_M_MetaApplicationSorted} ({I_Instr}) ({HX_M_RepeatSingle}) (HX_META_VARIABLE$) ( HX_LBRACKET <HxTerms> HX_RBRACKET | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_ConstructionSorted} ({I_Instr}) ({HX_M_RepeatSingle}) (HX_CONSTRUCTOR$) ( HX_LBRACKET <HxScopes> HX_RBRACKET | HX_LPAREN <HxTerms> HX_RPAREN | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_UnparsedSorted} ({I_Instr}) ({HX_M_RepeatSingle}) (HX_CONCRETE$:unconcrete) <HxAttributes>
////METAPG: 
////METAPG: .
////METAPG: token HX_TOKEN_I_Instr (HX) ::= "I_Instr" .
////METAPG: 



/* Productions for I_Arg sort with (highest) precedence 0. */

<I_Arg> ::= 
  ////METAPG: meta1_I_Arg:unconcrete |
  ////METAPG: meta2_I_Arg$$:[[unmeta(#,5)]]:{ [[ hxornaked("firstHxPresorted_I_Arg") ]] } |
  ( <Name>:#_Name_1  {{ Node_M_First_sI_xArg[Tag_M_First_sI_xArg_xName, (#_Name_1;)]}} 
  | ( <Float>:#_Float_1  {{ Node_M_First_sI_xArg[Tag_M_First_sI_xArg_xFloat, (#_Float_1;)]}} 
  | ( <Int>:#_Int_1  {{ Node_M_First_sI_xArg[Tag_M_First_sI_xArg_xInt, (#_Int_1;)]}} 
  |  <Tmp>:#_Tmp_1  {{ Node_M_First_sI_xArg[Tag_M_First_sI_xArg_xTmp, (#_Tmp_1;)]}} ))) . 


////SORT: TagSort_M_First_sI_xArg ::= ( Tag_M_First_sI_xArg_xName; Tag_M_First_sI_xArg_xFloat; Tag_M_First_sI_xArg_xInt; Tag_M_First_sI_xArg_xTmp;  );

////METAELIM: Node_M_First_sI_xArg[Tag_M_First_sI_xArg_xName, (#_Name_1;)];

////METAELIM: Node_M_First_sI_xArg[Tag_M_First_sI_xArg_xFloat, (#_Float_1;)];

////METAELIM: Node_M_First_sI_xArg[Tag_M_First_sI_xArg_xInt, (#_Int_1;)];

////METAELIM: Node_M_First_sI_xArg[Tag_M_First_sI_xArg_xTmp, (#_Tmp_1;)];


////METAPG: %{
////METAPG: /* Meta token for I_Arg. */ 
////METAPG: TOKEN : { < T_meta1_I_Arg : ("\u27e8" (" ")* "I_Arg" (" ")* "\u27e9") > }
////METAPG: MORE : { < "\u27e8" (" ")* "I_Arg" (" ")* ~["\u27e8","\u27e9"] > { nesting = 0; nestedState = curLexState; } : IN_META_I_Arg }
////METAPG: <IN_META_I_Arg> MORE : { "\u27e8" { nesting = 1; } : IN_NESTED_META_I_Arg }
////METAPG: <IN_NESTED_META_I_Arg> MORE : { "\u27e8" { nesting++; } }
////METAPG: <IN_NESTED_META_I_Arg> MORE : { "\u27e9" { if (--nesting <= 0) SwitchTo(IN_META_I_Arg); } }
////METAPG: <IN_META_I_Arg> TOKEN : { < T_meta2_I_Arg : "\u27e9" > { SwitchTo(nestedState); } }
////METAPG: <IN_META_I_Arg,IN_NESTED_META_I_Arg> MORE : { < ~[] > }
////METAPG: %}

////METAPG: /* Hx terms of I_Arg production sort. */
////METAPG: <Hx_I_Arg> (HX) ::= (HX_TOKEN_I_Arg)?  <HxPresorted_I_Arg> .
////METAPG: <HxSorted_I_Arg> (HX) ::= HX_TOKEN_I_Arg <HxPresorted_I_Arg> .
////METAPG: <HxPresorted_I_Arg> (HX) ::=
////METAPG:   {HX_M_VariableUseSorted} ({I_Arg}) ({HX_M_RepeatSingle}) (HX_VARIABLE!!!) <HxAttributes>
////METAPG: | {HX_M_MetaApplicationSorted} ({I_Arg}) ({HX_M_RepeatSingle}) (HX_META_VARIABLE$) ( HX_LBRACKET <HxTerms> HX_RBRACKET | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_ConstructionSorted} ({I_Arg}) ({HX_M_RepeatSingle}) (HX_CONSTRUCTOR$) ( HX_LBRACKET <HxScopes> HX_RBRACKET | HX_LPAREN <HxTerms> HX_RPAREN | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_UnparsedSorted} ({I_Arg}) ({HX_M_RepeatSingle}) (HX_CONCRETE$:unconcrete) <HxAttributes>
////METAPG: 
////METAPG: .
////METAPG: token HX_TOKEN_I_Arg (HX) ::= "I_Arg" .
////METAPG: 



/* Productions for Tmp sort with (highest) precedence 0. */

<Tmp> ::= 
  ////METAPG: meta1_Tmp:unconcrete |
  ////METAPG: meta2_Tmp$$:[[unmeta(#,3)]]:{ [[ hxornaked("firstHxPresorted_Tmp") ]] } |
   <T>!!!:#_T_1  {{#_T_1}}  . 


////SORT: TagSort_M_First_sTmp ::= ( Tag_M_First_sTmp_xT;  );
////METAELIM: Node_M_First_sTmp[Tag_M_First_sTmp_xT, (#_T_1;)]; 

////METAPG: %{
////METAPG: /* Meta token for Tmp. */ 
////METAPG: TOKEN : { < T_meta1_Tmp : ("\u27e8" (" ")* "Tmp" (" ")* "\u27e9") > }
////METAPG: MORE : { < "\u27e8" (" ")* "Tmp" (" ")* ~["\u27e8","\u27e9"] > { nesting = 0; nestedState = curLexState; } : IN_META_Tmp }
////METAPG: <IN_META_Tmp> MORE : { "\u27e8" { nesting = 1; } : IN_NESTED_META_Tmp }
////METAPG: <IN_NESTED_META_Tmp> MORE : { "\u27e8" { nesting++; } }
////METAPG: <IN_NESTED_META_Tmp> MORE : { "\u27e9" { if (--nesting <= 0) SwitchTo(IN_META_Tmp); } }
////METAPG: <IN_META_Tmp> TOKEN : { < T_meta2_Tmp : "\u27e9" > { SwitchTo(nestedState); } }
////METAPG: <IN_META_Tmp,IN_NESTED_META_Tmp> MORE : { < ~[] > }
////METAPG: %}

////METAPG: /* Hx terms of Tmp production sort. */
////METAPG: <Hx_Tmp> (HX) ::= (HX_TOKEN_Tmp)?  <HxPresorted_Tmp> .
////METAPG: <HxSorted_Tmp> (HX) ::= HX_TOKEN_Tmp <HxPresorted_Tmp> .
////METAPG: <HxPresorted_Tmp> (HX) ::=
////METAPG:   {HX_M_VariableUseSorted} ({Tmp}) ({HX_M_RepeatSingle}) (HX_VARIABLE!!!) <HxAttributes>
////METAPG: | {HX_M_MetaApplicationSorted} ({Tmp}) ({HX_M_RepeatSingle}) (HX_META_VARIABLE$) ( HX_LBRACKET <HxTerms> HX_RBRACKET | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_ConstructionSorted} ({Tmp}) ({HX_M_RepeatSingle}) (HX_CONSTRUCTOR$) ( HX_LBRACKET <HxScopes> HX_RBRACKET | HX_LPAREN <HxTerms> HX_RPAREN | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_UnparsedSorted} ({Tmp}) ({HX_M_RepeatSingle}) (HX_CONCRETE$:unconcrete) <HxAttributes>
////METAPG: 
////METAPG: .
////METAPG: token HX_TOKEN_Tmp (HX) ::= "Tmp" .
////METAPG: 


////METAPG: <HxAttributeInherited_TmpType> (HX) ::= {HX_M_Attribute} ({HX_M_AttributeKindDown}) (HX_TOKEN_TmpType$) HX_LBRACE {HX_M_AttributeKeyValue} <Hx_Tmp> HX_COLON <Hx_Type> HX_RBRACE .
    ////METAPG: token HX_TOKEN_TmpType (HX) ::= "TmpType" . 
    

/* Productions for A_Progr sort with (highest) precedence 0. */

<A_Progr> ::= 
  ////METAPG: meta1_A_Progr:unconcrete |
  ////METAPG: meta2_A_Progr$$:[[unmeta(#,7)]]:{ [[ hxornaked("firstHxPresorted_A_Progr") ]] } |
  ("CG" <I_Progr>:#_I_Progr_1  {{ Node_M_First_sA_xProgr[Tag_M_First_sA_xProgr_x_xM_xCG, (#_I_Progr_1;)]}} 
  | ("Compile" <Stat>:#_Stat_1  {{ Node_M_First_sA_xProgr[Tag_M_First_sA_xProgr_x_xM_xCompile, (#_Stat_1;)]}} 
  | ( <A_Instr>:#_A_Instr_1  <A_Progr>:#_A_Progr_2  {{ Node_M_First_sA_xProgr[Tag_M_First_sA_xProgr_xA_xInstr, (#_A_Instr_1; #_A_Progr_2;)]}}  
  |  {{ Node_M_First_sA_xProgr[Tag†« $TextChars[
     $[
      Mangle,
      $[
       Trim,
       $[
        If,
        $[
         StartsWith,
         StringJoin2[
          "EMPTY",
          "_",
          {
            $LineLocation : STRING[140];
            $FileLocation : STRING["../samples/first.hx"];
            $ColumnLocation : STRING[6]}
           "A_Progr"],
         $],
        StringJoin2[
         "EMPTY",
         "_",
         {
           $LineLocation : STRING[140];
           $FileLocation : STRING["../samples/first.hx"];
           $ColumnLocation : STRING[6]}
          "A_Progr"],
        $[
         :,
         "First",
         $,
         StringJoin2[
          "EMPTY",
          "_",
          {
            $LineLocation : STRING[140];
            $FileLocation : STRING["../samples/first.hx"];
            $ColumnLocation : STRING[6]}
           "A_Progr"]]]]]] »]}}))) . 


////SORT: TagSort_M_First_sA_xProgr ::= ( Tag_M_First_sA_xProgr_x_xM_xCG; Tag_M_First_sA_xProgr_x_xM_xCompile; Tag_M_First_sA_xProgr_xA_xInstr; Tag†« $TextChars[
 $[
  Mangle,
  $[
   Trim,
   $[
    If,
    $[
     StartsWith,
     StringJoin2[
      "EMPTY",
      "_",
      {
        $LineLocation : STRING[140];
        $FileLocation : STRING["../samples/first.hx"];
        $ColumnLocation : STRING[6]}
       "A_Progr"],
     $],
    StringJoin2[
     "EMPTY",
     "_",
     {
       $LineLocation : STRING[140];
       $FileLocation : STRING["../samples/first.hx"];
       $ColumnLocation : STRING[6]}
      "A_Progr"],
    $[
     :,
     "First",
     $,
     StringJoin2[
      "EMPTY",
      "_",
      {
        $LineLocation : STRING[140];
        $FileLocation : STRING["../samples/first.hx"];
        $ColumnLocation : STRING[6]}
       "A_Progr"]]]]]] »;  );

////METAELIM: Node_M_First_sA_xProgr[Tag_M_First_sA_xProgr_x_xM_xCG, (#_I_Progr_1;)];

////METAELIM: Node_M_First_sA_xProgr[Tag_M_First_sA_xProgr_x_xM_xCompile, (#_Stat_1;)];

////METAELIM: Node_M_First_sA_xProgr[Tag_M_First_sA_xProgr_xA_xInstr, (#_A_Instr_1; #_A_Progr_2;)];

////METAELIM: Node_M_First_sA_xProgr[Tag†« $TextChars[
 $[
  Mangle,
  $[
   Trim,
   $[
    If,
    $[
     StartsWith,
     StringJoin2[
      "EMPTY",
      "_",
      {
        $LineLocation : STRING[140];
        $FileLocation : STRING["../samples/first.hx"];
        $ColumnLocation : STRING[6]}
       "A_Progr"],
     $],
    StringJoin2[
     "EMPTY",
     "_",
     {
       $LineLocation : STRING[140];
       $FileLocation : STRING["../samples/first.hx"];
       $ColumnLocation : STRING[6]}
      "A_Progr"],
    $[
     :,
     "First",
     $,
     StringJoin2[
      "EMPTY",
      "_",
      {
        $LineLocation : STRING[140];
        $FileLocation : STRING["../samples/first.hx"];
        $ColumnLocation : STRING[6]}
       "A_Progr"]]]]]] »];


////METAPG: %{
////METAPG: /* Meta token for A_Progr. */ 
////METAPG: TOKEN : { < T_meta1_A_Progr : ("\u27e8" (" ")* "A_Progr" (" ")* "\u27e9") > }
////METAPG: MORE : { < "\u27e8" (" ")* "A_Progr" (" ")* ~["\u27e8","\u27e9"] > { nesting = 0; nestedState = curLexState; } : IN_META_A_Progr }
////METAPG: <IN_META_A_Progr> MORE : { "\u27e8" { nesting = 1; } : IN_NESTED_META_A_Progr }
////METAPG: <IN_NESTED_META_A_Progr> MORE : { "\u27e8" { nesting++; } }
////METAPG: <IN_NESTED_META_A_Progr> MORE : { "\u27e9" { if (--nesting <= 0) SwitchTo(IN_META_A_Progr); } }
////METAPG: <IN_META_A_Progr> TOKEN : { < T_meta2_A_Progr : "\u27e9" > { SwitchTo(nestedState); } }
////METAPG: <IN_META_A_Progr,IN_NESTED_META_A_Progr> MORE : { < ~[] > }
////METAPG: %}

////METAPG: /* Hx terms of A_Progr production sort. */
////METAPG: <Hx_A_Progr> (HX) ::= (HX_TOKEN_A_Progr)?  <HxPresorted_A_Progr> .
////METAPG: <HxSorted_A_Progr> (HX) ::= HX_TOKEN_A_Progr <HxPresorted_A_Progr> .
////METAPG: <HxPresorted_A_Progr> (HX) ::=
////METAPG:   {HX_M_VariableUseSorted} ({A_Progr}) ({HX_M_RepeatSingle}) (HX_VARIABLE!!!) <HxAttributes>
////METAPG: | {HX_M_MetaApplicationSorted} ({A_Progr}) ({HX_M_RepeatSingle}) (HX_META_VARIABLE$) ( HX_LBRACKET <HxTerms> HX_RBRACKET | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_ConstructionSorted} ({A_Progr}) ({HX_M_RepeatSingle}) (HX_CONSTRUCTOR$) ( HX_LBRACKET <HxScopes> HX_RBRACKET | HX_LPAREN <HxTerms> HX_RPAREN | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_UnparsedSorted} ({A_Progr}) ({HX_M_RepeatSingle}) (HX_CONCRETE$:unconcrete) <HxAttributes>
////METAPG: | HX_TOKEN_Compile$  HX_LPAREN <Hx_Stat> HX_RPAREN  
////METAPG: .
////METAPG: token HX_TOKEN_A_Progr (HX) ::= "A_Progr" .
////METAPG: token HX_TOKEN_Compile (HX) ::= "Compile" . 



/* Productions for A_Instr sort with (highest) precedence 0. */

<A_Instr> ::= 
  ////METAPG: meta1_A_Instr:unconcrete |
  ////METAPG: meta2_A_Instr$$:[[unmeta(#,7)]]:{ [[ hxornaked("firstHxPresorted_A_Instr") ]] } |
  ("ADDF" <A_Arg>:#_A_Arg_1 "," <A_Arg>:#_A_Arg_2 "," <A_Arg>:#_A_Arg_3  {{ Node_M_First_sA_xInstr[Tag_M_First_sA_xInstr_x_xM_xADDF, (#_A_Arg_1; #_A_Arg_2; #_A_Arg_3;)]}}   
  | ("LDF" <Tmp>:#_Tmp_1 "," <A_Arg>:#_A_Arg_2  {{ Node_M_First_sA_xInstr[Tag_M_First_sA_xInstr_x_xM_xLDF, (#_Tmp_1; #_A_Arg_2;)]}}  
  | ("MULF" <A_Arg>:#_A_Arg_1 "," <A_Arg>:#_A_Arg_2 "," <A_Arg>:#_A_Arg_3  {{ Node_M_First_sA_xInstr[Tag_M_First_sA_xInstr_x_xM_xMULF, (#_A_Arg_1; #_A_Arg_2; #_A_Arg_3;)]}}   
  | "STF" <Name>:#_Name_1 "," <Tmp>:#_Tmp_2  {{ Node_M_First_sA_xInstr[Tag_M_First_sA_xInstr_x_xM_xSTF, (#_Name_1; #_Tmp_2;)]}}  ))) . 


////SORT: TagSort_M_First_sA_xInstr ::= ( Tag_M_First_sA_xInstr_x_xM_xADDF; Tag_M_First_sA_xInstr_x_xM_xLDF; Tag_M_First_sA_xInstr_x_xM_xMULF; Tag_M_First_sA_xInstr_x_xM_xSTF;  );

////METAELIM: Node_M_First_sA_xInstr[Tag_M_First_sA_xInstr_x_xM_xADDF, (#_A_Arg_1; #_A_Arg_2; #_A_Arg_3;)];

////METAELIM: Node_M_First_sA_xInstr[Tag_M_First_sA_xInstr_x_xM_xLDF, (#_Tmp_1; #_A_Arg_2;)];

////METAELIM: Node_M_First_sA_xInstr[Tag_M_First_sA_xInstr_x_xM_xMULF, (#_A_Arg_1; #_A_Arg_2; #_A_Arg_3;)];

////METAELIM: Node_M_First_sA_xInstr[Tag_M_First_sA_xInstr_x_xM_xSTF, (#_Name_1; #_Tmp_2;)];


////METAPG: %{
////METAPG: /* Meta token for A_Instr. */ 
////METAPG: TOKEN : { < T_meta1_A_Instr : ("\u27e8" (" ")* "A_Instr" (" ")* "\u27e9") > }
////METAPG: MORE : { < "\u27e8" (" ")* "A_Instr" (" ")* ~["\u27e8","\u27e9"] > { nesting = 0; nestedState = curLexState; } : IN_META_A_Instr }
////METAPG: <IN_META_A_Instr> MORE : { "\u27e8" { nesting = 1; } : IN_NESTED_META_A_Instr }
////METAPG: <IN_NESTED_META_A_Instr> MORE : { "\u27e8" { nesting++; } }
////METAPG: <IN_NESTED_META_A_Instr> MORE : { "\u27e9" { if (--nesting <= 0) SwitchTo(IN_META_A_Instr); } }
////METAPG: <IN_META_A_Instr> TOKEN : { < T_meta2_A_Instr : "\u27e9" > { SwitchTo(nestedState); } }
////METAPG: <IN_META_A_Instr,IN_NESTED_META_A_Instr> MORE : { < ~[] > }
////METAPG: %}

////METAPG: /* Hx terms of A_Instr production sort. */
////METAPG: <Hx_A_Instr> (HX) ::= (HX_TOKEN_A_Instr)?  <HxPresorted_A_Instr> .
////METAPG: <HxSorted_A_Instr> (HX) ::= HX_TOKEN_A_Instr <HxPresorted_A_Instr> .
////METAPG: <HxPresorted_A_Instr> (HX) ::=
////METAPG:   {HX_M_VariableUseSorted} ({A_Instr}) ({HX_M_RepeatSingle}) (HX_VARIABLE!!!) <HxAttributes>
////METAPG: | {HX_M_MetaApplicationSorted} ({A_Instr}) ({HX_M_RepeatSingle}) (HX_META_VARIABLE$) ( HX_LBRACKET <HxTerms> HX_RBRACKET | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_ConstructionSorted} ({A_Instr}) ({HX_M_RepeatSingle}) (HX_CONSTRUCTOR$) ( HX_LBRACKET <HxScopes> HX_RBRACKET | HX_LPAREN <HxTerms> HX_RPAREN | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_UnparsedSorted} ({A_Instr}) ({HX_M_RepeatSingle}) (HX_CONCRETE$:unconcrete) <HxAttributes>
////METAPG: 
////METAPG: .
////METAPG: token HX_TOKEN_A_Instr (HX) ::= "A_Instr" .
////METAPG: 



/* Productions for A_Arg sort with (highest) precedence 0. */

<A_Arg> ::= 
  ////METAPG: meta1_A_Arg:unconcrete |
  ////METAPG: meta2_A_Arg$$:[[unmeta(#,5)]]:{ [[ hxornaked("firstHxPresorted_A_Arg") ]] } |
  ("#"( <Float>:#_Float_1  {{ Node_M_First_sA_xArg[Tag_M_First_sA_xArg_x_xM_x_xh, (#_Float_1;)]}} 
  |  <Int>:#_Int_1  {{ Node_M_First_sA_xArg[Tag_M_First_sA_xArg_x_xM_x_xh, (#_Int_1;)]}} )
  | ("[" <I_Arg>:#_I_Arg_1 "]" {{ Node_M_First_sA_xArg[Tag_M_First_sA_xArg_x_xM_x_x5b, (#_I_Arg_1;)]}} 
  | ( <Name>:#_Name_1  {{ Node_M_First_sA_xArg[Tag_M_First_sA_xArg_xName, (#_Name_1;)]}} 
  |  <Tmp>:#_Tmp_1  {{ Node_M_First_sA_xArg[Tag_M_First_sA_xArg_xTmp, (#_Tmp_1;)]}} ))) . 


////SORT: TagSort_M_First_sA_xArg ::= ( Tag_M_First_sA_xArg_x_xM_x_xh; Tag_M_First_sA_xArg_x_xM_x_xh; Tag_M_First_sA_xArg_x_xM_x_x5b; Tag_M_First_sA_xArg_xName; Tag_M_First_sA_xArg_xTmp;  );

////METAELIM: Node_M_First_sA_xArg[Tag_M_First_sA_xArg_x_xM_x_xh, (#_Float_1;)];

////METAELIM: Node_M_First_sA_xArg[Tag_M_First_sA_xArg_x_xM_x_xh, (#_Int_1;)];

////METAELIM: Node_M_First_sA_xArg[Tag_M_First_sA_xArg_x_xM_x_x5b, (#_I_Arg_1;)];

////METAELIM: Node_M_First_sA_xArg[Tag_M_First_sA_xArg_xName, (#_Name_1;)];

////METAELIM: Node_M_First_sA_xArg[Tag_M_First_sA_xArg_xTmp, (#_Tmp_1;)];


////METAPG: %{
////METAPG: /* Meta token for A_Arg. */ 
////METAPG: TOKEN : { < T_meta1_A_Arg : ("\u27e8" (" ")* "A_Arg" (" ")* "\u27e9") > }
////METAPG: MORE : { < "\u27e8" (" ")* "A_Arg" (" ")* ~["\u27e8","\u27e9"] > { nesting = 0; nestedState = curLexState; } : IN_META_A_Arg }
////METAPG: <IN_META_A_Arg> MORE : { "\u27e8" { nesting = 1; } : IN_NESTED_META_A_Arg }
////METAPG: <IN_NESTED_META_A_Arg> MORE : { "\u27e8" { nesting++; } }
////METAPG: <IN_NESTED_META_A_Arg> MORE : { "\u27e9" { if (--nesting <= 0) SwitchTo(IN_META_A_Arg); } }
////METAPG: <IN_META_A_Arg> TOKEN : { < T_meta2_A_Arg : "\u27e9" > { SwitchTo(nestedState); } }
////METAPG: <IN_META_A_Arg,IN_NESTED_META_A_Arg> MORE : { < ~[] > }
////METAPG: %}

////METAPG: /* Hx terms of A_Arg production sort. */
////METAPG: <Hx_A_Arg> (HX) ::= (HX_TOKEN_A_Arg)?  <HxPresorted_A_Arg> .
////METAPG: <HxSorted_A_Arg> (HX) ::= HX_TOKEN_A_Arg <HxPresorted_A_Arg> .
////METAPG: <HxPresorted_A_Arg> (HX) ::=
////METAPG:   {HX_M_VariableUseSorted} ({A_Arg}) ({HX_M_RepeatSingle}) (HX_VARIABLE!!!) <HxAttributes>
////METAPG: | {HX_M_MetaApplicationSorted} ({A_Arg}) ({HX_M_RepeatSingle}) (HX_META_VARIABLE$) ( HX_LBRACKET <HxTerms> HX_RBRACKET | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_ConstructionSorted} ({A_Arg}) ({HX_M_RepeatSingle}) (HX_CONSTRUCTOR$) ( HX_LBRACKET <HxScopes> HX_RBRACKET | HX_LPAREN <HxTerms> HX_RPAREN | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_UnparsedSorted} ({A_Arg}) ({HX_M_RepeatSingle}) (HX_CONCRETE$:unconcrete) <HxAttributes>
////METAPG: 
////METAPG: .
////METAPG: token HX_TOKEN_A_Arg (HX) ::= "A_Arg" .
////METAPG: 



/* TOKENS. */

skip ::= ' ' | [' ','\t','\n']   .
token Int ::= ( Digit )+   .
token Float ::= Int "." Int   .
token Id ::= ( Lower )+ ( ( ( '_' )? Int   ) )?   .
token fragment Digit ::= ['0'-'9']   . 
token fragment Lower ::= ['a'-'z']   . 
token T ::= "T" ( ( '_' Int   ) )?   . 
