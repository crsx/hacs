/* PG Grammar for HACS module net.sf.crsx.samples.gentle.First. */

/* INTERFACE. */

class net.sf.crsx.samples.gentle.FirstParser : <Term>,
  <Construction>

prefix first

////METAPG: declarations
////METAPG: %{
////METAPG: String unconcrete(String s) {return s.substring(1, s.length()-1).trim();}
////METAPG: String unmeta(String s, int skip) {return s.substring(1+skip, s.length()-1).trim();}
////METAPG: %}

%{
TOKEN_MGR_DECLS : { int nesting; int nestedState;} /* Used by all nesting constructs. */
%}


////METASORTS: /* META-TERM SORTS. */
////METASORTS:
////METASORTS: Sort_M_First_sTerm ::= (
  ////METASORTS: Node_M_First_sInt[TagSort_M_First_sInt, $List[Sort_M_First_sScope]];
  ////METASORTS: Node_M_First_sFloat[TagSort_M_First_sFloat, $List[Sort_M_First_sScope]];
  ////METASORTS: Node_M_First_sId[TagSort_M_First_sId, $List[Sort_M_First_sScope]];
  ////METASORTS: Node_M_First_sStat[TagSort_M_First_sStat, $List[Sort_M_First_sScope]];
  ////METASORTS: Node_M_First_sExp[TagSort_M_First_sExp, $List[Sort_M_First_sScope]];
  ////METASORTS: Node_M_First_sName[TagSort_M_First_sName, $List[Sort_M_First_sScope]];
  ////METASORTS: Node_M_First_sType[TagSort_M_First_sType, $List[Sort_M_First_sScope]];
  ////METASORTS: Node_M_First_st[TagSort_M_First_st, $List[Sort_M_First_sScope]];
  ////METASORTS: Node_M_First_se[TagSort_M_First_se, $List[Sort_M_First_sScope]];
  ////METASORTS: Node_M_First_sT[TagSort_M_First_sT, $List[Sort_M_First_sScope]];
  ////METASORTS: Node_M_First_sI_xProgr[TagSort_M_First_sI_xProgr, $List[Sort_M_First_sScope]];
  ////METASORTS: Node_M_First_sI_xInstr[TagSort_M_First_sI_xInstr, $List[Sort_M_First_sScope]];
  ////METASORTS: Node_M_First_sI_xArg[TagSort_M_First_sI_xArg, $List[Sort_M_First_sScope]];
  ////METASORTS: Node_M_First_sTmp[TagSort_M_First_sTmp, $List[Sort_M_First_sScope]];
  ////METASORTS: Node_M_First_sTmpType[TagSort_M_First_sTmpType, $List[Sort_M_First_sScope]];
  ////METASORTS: Node_M_First_sA_xProgr[TagSort_M_First_sA_xProgr, $List[Sort_M_First_sScope]];
  ////METASORTS: Node_M_First_sA_xInstr[TagSort_M_First_sA_xInstr, $List[Sort_M_First_sScope]];
  ////METASORTS: Node_M_First_sA_xArg[TagSort_M_First_sA_xArg, $List[Sort_M_First_sScope]];
  ////METASORTS: );
////METASORTS:
////METASORTS: Sort_M_First_sScope ::= (
  ////METASORTS: Tag_M_First_sBinder[binder :: Sort_M_First_sTerm . Sort_M_First_sScope];
  ////METASORTS: Tag_M_First_sSubterm[Sort_M_First_sTerm]; 
////METASORTS: );


/* GRAMMAR. */


/* Productions for Int token. */

<Int> ::= 
////METAPG: meta1_Int:unconcrete |
////METAPG: meta2_Int$$:[[unmeta(#,3)]]:{ [[ hxornaked("firstHxPresorted_Int") ]] } |
{TOKEN_M_First_sInt} Int$ .
////SORT: Sort_M_First_sInt ::= ( TOKEN_M_First_sInt[$String]; );

////METAPG: %{
////METAPG: /* Meta token for Int. */ 
////METAPG: TOKEN : { < T_meta1_Int : ("\u27e8" (" ")* "Int" (" ")* "\u27e9") > }
////METAPG: MORE : { < "\u27e8" (" ")* "Int" (" ")* ~["\u27e8","\u27e9"] > { nesting = 0; nestedState = curLexState; } : IN_META_Int }
////METAPG: <IN_META_Int> MORE : { "\u27e8" { nesting = 1; } : IN_NESTED_META_Int }
////METAPG: <IN_NESTED_META_Int> MORE : { "\u27e8" { nesting++; } }
////METAPG: <IN_NESTED_META_Int> MORE : { "\u27e9" { if (--nesting <= 0) SwitchTo(IN_META_Int); } }
////METAPG: <IN_META_Int> TOKEN : { < T_meta2_Int : "\u27e9" > { SwitchTo(nestedState); } }
////METAPG: <IN_META_Int,IN_NESTED_META_Int> MORE : { < ~[] > }
////METAPG: %}

////METAPG: /* Hx terms of Int token sort. */
////METAPG: <Hx_Int> (HX) ::= (HX_TOKEN_Int)?  <HxPresorted_Int> .
////METAPG: <HxSorted_Int> (HX) ::= HX_TOKEN_Int <HxPresorted_Int> .
////METAPG: <HxPresorted_Int> (HX) ::=
////METAPG:   {HX_M_VariableUseSorted} ({Int}) ({HX_M_RepeatSingle}) (HX_VARIABLE!!!) <HxAttributes>
////METAPG: | {HX_M_MetaApplicationSorted} ({Int}) ({HX_M_RepeatSingle}) (HX_META_VARIABLE$) ( HX_LBRACKET <HxTerms>  HX_RBRACKET | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_UnparsedSorted} ({Int}) ({HX_M_RepeatSingle}) (HX_CONCRETE$:unconcrete) <HxAttributes>
////METAPG: .
////METAPG: token HX_TOKEN_Int (HX) ::= "Int" .


/* Productions for Float token. */

<Float> ::= 
////METAPG: meta1_Float:unconcrete |
////METAPG: meta2_Float$$:[[unmeta(#,5)]]:{ [[ hxornaked("firstHxPresorted_Float") ]] } |
{TOKEN_M_First_sFloat} Float$ .
////SORT: Sort_M_First_sFloat ::= ( TOKEN_M_First_sFloat[$String]; );

////METAPG: %{
////METAPG: /* Meta token for Float. */ 
////METAPG: TOKEN : { < T_meta1_Float : ("\u27e8" (" ")* "Float" (" ")* "\u27e9") > }
////METAPG: MORE : { < "\u27e8" (" ")* "Float" (" ")* ~["\u27e8","\u27e9"] > { nesting = 0; nestedState = curLexState; } : IN_META_Float }
////METAPG: <IN_META_Float> MORE : { "\u27e8" { nesting = 1; } : IN_NESTED_META_Float }
////METAPG: <IN_NESTED_META_Float> MORE : { "\u27e8" { nesting++; } }
////METAPG: <IN_NESTED_META_Float> MORE : { "\u27e9" { if (--nesting <= 0) SwitchTo(IN_META_Float); } }
////METAPG: <IN_META_Float> TOKEN : { < T_meta2_Float : "\u27e9" > { SwitchTo(nestedState); } }
////METAPG: <IN_META_Float,IN_NESTED_META_Float> MORE : { < ~[] > }
////METAPG: %}

////METAPG: /* Hx terms of Float token sort. */
////METAPG: <Hx_Float> (HX) ::= (HX_TOKEN_Float)?  <HxPresorted_Float> .
////METAPG: <HxSorted_Float> (HX) ::= HX_TOKEN_Float <HxPresorted_Float> .
////METAPG: <HxPresorted_Float> (HX) ::=
////METAPG:   {HX_M_VariableUseSorted} ({Float}) ({HX_M_RepeatSingle}) (HX_VARIABLE!!!) <HxAttributes>
////METAPG: | {HX_M_MetaApplicationSorted} ({Float}) ({HX_M_RepeatSingle}) (HX_META_VARIABLE$) ( HX_LBRACKET <HxTerms>  HX_RBRACKET | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_UnparsedSorted} ({Float}) ({HX_M_RepeatSingle}) (HX_CONCRETE$:unconcrete) <HxAttributes>
////METAPG: .
////METAPG: token HX_TOKEN_Float (HX) ::= "Float" .


/* Productions for Id token. */

<Id> ::= 
////METAPG: meta1_Id:unconcrete |
////METAPG: meta2_Id$$:[[unmeta(#,2)]]:{ [[ hxornaked("firstHxPresorted_Id") ]] } |
{TOKEN_M_First_sId} Id$ .
////SORT: Sort_M_First_sId ::= ( TOKEN_M_First_sId[$String]; );

////METAPG: %{
////METAPG: /* Meta token for Id. */ 
////METAPG: TOKEN : { < T_meta1_Id : ("\u27e8" (" ")* "Id" (" ")* "\u27e9") > }
////METAPG: MORE : { < "\u27e8" (" ")* "Id" (" ")* ~["\u27e8","\u27e9"] > { nesting = 0; nestedState = curLexState; } : IN_META_Id }
////METAPG: <IN_META_Id> MORE : { "\u27e8" { nesting = 1; } : IN_NESTED_META_Id }
////METAPG: <IN_NESTED_META_Id> MORE : { "\u27e8" { nesting++; } }
////METAPG: <IN_NESTED_META_Id> MORE : { "\u27e9" { if (--nesting <= 0) SwitchTo(IN_META_Id); } }
////METAPG: <IN_META_Id> TOKEN : { < T_meta2_Id : "\u27e9" > { SwitchTo(nestedState); } }
////METAPG: <IN_META_Id,IN_NESTED_META_Id> MORE : { < ~[] > }
////METAPG: %}

////METAPG: /* Hx terms of Id token sort. */
////METAPG: <Hx_Id> (HX) ::= (HX_TOKEN_Id)?  <HxPresorted_Id> .
////METAPG: <HxSorted_Id> (HX) ::= HX_TOKEN_Id <HxPresorted_Id> .
////METAPG: <HxPresorted_Id> (HX) ::=
////METAPG:   {HX_M_VariableUseSorted} ({Id}) ({HX_M_RepeatSingle}) (HX_VARIABLE!!!) <HxAttributes>
////METAPG: | {HX_M_MetaApplicationSorted} ({Id}) ({HX_M_RepeatSingle}) (HX_META_VARIABLE$) ( HX_LBRACKET <HxTerms>  HX_RBRACKET | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_UnparsedSorted} ({Id}) ({HX_M_RepeatSingle}) (HX_CONCRETE$:unconcrete) <HxAttributes>
////METAPG: .
////METAPG: token HX_TOKEN_Id (HX) ::= "Id" .


/* Productions for Stat sort with (highest) precedence 0. */

<Stat> ::= 
  ////METAPG: meta1_Stat:unconcrete |
  ////METAPG: meta2_Stat$$:[[unmeta(#,4)]]:{ [[ hxornaked("firstHxPresorted_Stat") ]] } |
  ("TA" <Stat>:#_Stat_1  {{ Node_M_First_sStat[Stat__M_TA_Stat, (#_Stat_1;)]}} 
  | ("TA2" <Stat>:#_Stat_1  {{ Node_M_First_sStat[Stat__M_TA2_Stat, (#_Stat_1;)]}} 
  | ("{" <Stat_MaybeSome>:#_Stat_1 "}" {{ Node_M_First_sStat[Stat__M__7b_Stat__M__7d, (#_Stat_1;)]}} 
  |  <Name>:#_Name_1 ":=" <Exp>:#_Exp_2 ";" {{ Node_M_First_sStat[Stat_Name__M__3a_3d_Exp__M__3b, (#_Name_1; #_Exp_2;)]}}  ))) . 


////SORT: TagSort_M_First_sStat ::= ( Tag_M_First_sStat; Tag_M_First_sStat; Tag_M_First_sStat; Tag_M_First_sStat;  );

////METAELIM: Node_M_First_sStat[Tag_M_First_sStat_xM_xTA_xStat, (#_Stat_1;)];

////METAELIM: Node_M_First_sStat[Tag_M_First_sStat_xM_xTA2_xStat, (#_Stat_1;)];

////METAELIM: Node_M_First_sStat[Tag_M_First_sStat_xM_x_x7b_xStat, (#_Stat_1;)];

////METAELIM: Node_M_First_sStat[Tag_M_First_sStatName_x_xM_x_x3a_x3d, (#_Name_1; #_Exp_2;)];


////METAPG: %{
////METAPG: /* Meta token for Stat. */ 
////METAPG: TOKEN : { < T_meta1_Stat : ("\u27e8" (" ")* "Stat" (" ")* "\u27e9") > }
////METAPG: MORE : { < "\u27e8" (" ")* "Stat" (" ")* ~["\u27e8","\u27e9"] > { nesting = 0; nestedState = curLexState; } : IN_META_Stat }
////METAPG: <IN_META_Stat> MORE : { "\u27e8" { nesting = 1; } : IN_NESTED_META_Stat }
////METAPG: <IN_NESTED_META_Stat> MORE : { "\u27e8" { nesting++; } }
////METAPG: <IN_NESTED_META_Stat> MORE : { "\u27e9" { if (--nesting <= 0) SwitchTo(IN_META_Stat); } }
////METAPG: <IN_META_Stat> TOKEN : { < T_meta2_Stat : "\u27e9" > { SwitchTo(nestedState); } }
////METAPG: <IN_META_Stat,IN_NESTED_META_Stat> MORE : { < ~[] > }
////METAPG: %}

////METAPG: /* Hx terms of Stat production sort. */
////METAPG: <Hx_Stat> (HX) ::= (HX_TOKEN_Stat)?  <HxPresorted_Stat> .
////METAPG: <HxSorted_Stat> (HX) ::= HX_TOKEN_Stat <HxPresorted_Stat> .
////METAPG: <HxPresorted_Stat> (HX) ::=
////METAPG:   {HX_M_VariableUseSorted} ({Stat}) ({HX_M_RepeatSingle}) (HX_VARIABLE!!!) <HxAttributes>
////METAPG: | {HX_M_MetaApplicationSorted} ({Stat}) ({HX_M_RepeatSingle}) (HX_META_VARIABLE$) ( HX_LBRACKET <HxTerms> HX_RBRACKET | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_ConstructionSorted} ({Stat}) ({HX_M_RepeatSingle}) (HX_CONSTRUCTOR$) ( HX_LBRACKET <HxScopes> HX_RBRACKET | HX_LPAREN <HxTerms> HX_RPAREN | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_UnparsedSorted} ({Stat}) ({HX_M_RepeatSingle}) (HX_CONCRETE$:unconcrete) <HxAttributes>
////METAPG: 
////METAPG: .
////METAPG: token HX_TOKEN_Stat (HX) ::= "Stat" .
////METAPG: 

/* Productions for Exp sort with precedence 0. */

<Exp> ::= ("TA" <Exp>:#_Exp_1  {{ Node_M_First_sExp[Exp__M_TA_Exp, (#_Exp_1;)]}} 
  |  <Exp1>:#_Exp_1  {{#_Exp_1}} ) . 


////SORT: TagSort_M_First_sExp ::= ( Tag_M_First_sExp; Tag_M_First_sExp;  );

////METAELIM: Node_M_First_sExp[Tag_M_First_sExp_xM_xTA_xExp, (#_Exp_1;)];
 ////METAELIM: Node_M_First_sExp[Tag_M_First_sExpExp, (#_Exp_1;)]; 

/* Productions for Exp sort with precedence 1. */

<Exp1> ::= ( <Exp1>:#_Exp_1 "+" <Exp2>:#_Exp_2  {{ Node_M_First_sExp[Exp1_Exp__M__2b_Exp, (#_Exp_1; #_Exp_2;)]}}  
  |  <Exp2>:#_Exp_1  {{#_Exp_1}} ) . 


////SORT: TagSort_M_First_sExp ::= ( Tag_M_First_sExp_7b_sLineLocation_20_3a_20STRING_5b25_5d_3b_20_sFileLocation_20_3a_20STRING_5b_22_2e_2e_2fsamples_2ffirst_2ehx_22_5d_3b_20_sColumnLocation_20_3a_20STRING_5b36_5d_7d_221_22; Tag_M_First_sExp_7b_sLineLocation_20_3a_20STRING_5b25_5d_3b_20_sFileLocation_20_3a_20STRING_5b_22_2e_2e_2fsamples_2ffirst_2ehx_22_5d_3b_20_sColumnLocation_20_3a_20STRING_5b36_5d_7d_221_22;  );

////METAELIM: Node_M_First_sExp[Tag_M_First_sExpExp_x_xM_x_x2b, (#_Exp_1; #_Exp_2;)];
 ////METAELIM: Node_M_First_sExp[Tag_M_First_sExpExp, (#_Exp_1;)]; 

/* Productions for Exp sort with precedence 2. */

<Exp2> ::= ( <Exp2>:#_Exp_1 "*" <Exp3>:#_Exp_2  {{ Node_M_First_sExp[Exp2_Exp__M__2a_Exp, (#_Exp_1; #_Exp_2;)]}}  
  |  <Exp3>:#_Exp_1  {{#_Exp_1}} ) . 


////SORT: TagSort_M_First_sExp ::= ( Tag_M_First_sExp_7b_sLineLocation_20_3a_20STRING_5b26_5d_3b_20_sFileLocation_20_3a_20STRING_5b_22_2e_2e_2fsamples_2ffirst_2ehx_22_5d_3b_20_sColumnLocation_20_3a_20STRING_5b36_5d_7d_222_22; Tag_M_First_sExp_7b_sLineLocation_20_3a_20STRING_5b26_5d_3b_20_sFileLocation_20_3a_20STRING_5b_22_2e_2e_2fsamples_2ffirst_2ehx_22_5d_3b_20_sColumnLocation_20_3a_20STRING_5b36_5d_7d_222_22;  );

////METAELIM: Node_M_First_sExp[Tag_M_First_sExpExp_x_xM_x_x2a, (#_Exp_1; #_Exp_2;)];
 ////METAELIM: Node_M_First_sExp[Tag_M_First_sExpExp, (#_Exp_1;)]; 



/* Productions for Exp sort with (highest) precedence 3. */

<Exp3> ::= 
  ////METAPG: meta1_Exp:unconcrete |
  ////METAPG: meta2_Exp$$:[[unmeta(#,3)]]:{ [[ hxornaked("firstHxPresorted_Exp") ]] } |
  ("(" <Exp>:# ")" {{ Node_M_First_sExp[Exp3__M__28_Exp__M__29, (#;)]}} 
  | ( <Int>:#_Int_1  {{ Node_M_First_sExp[Exp3_Int, (#_Int_1;)]}} 
  | ( <Float>:#_Float_1  {{ Node_M_First_sExp[Exp3_Float, (#_Float_1;)]}} 
  |  <Name>:#_Name_1  {{ Node_M_First_sExp[Exp3_Name, (#_Name_1;)]}} ))) . 


////SORT: TagSort_M_First_sExp ::= ( Tag_M_First_sExp_7b_sLineLocation_20_3a_20STRING_5b30_5d_3b_20_sFileLocation_20_3a_20STRING_5b_22_2e_2e_2fsamples_2ffirst_2ehx_22_5d_3b_20_sColumnLocation_20_3a_20STRING_5b33_5d_7d_223_22; Tag_M_First_sExp_7b_sLineLocation_20_3a_20STRING_5b30_5d_3b_20_sFileLocation_20_3a_20STRING_5b_22_2e_2e_2fsamples_2ffirst_2ehx_22_5d_3b_20_sColumnLocation_20_3a_20STRING_5b33_5d_7d_223_22; Tag_M_First_sExp_7b_sLineLocation_20_3a_20STRING_5b30_5d_3b_20_sFileLocation_20_3a_20STRING_5b_22_2e_2e_2fsamples_2ffirst_2ehx_22_5d_3b_20_sColumnLocation_20_3a_20STRING_5b33_5d_7d_223_22; Tag_M_First_sExp_7b_sLineLocation_20_3a_20STRING_5b30_5d_3b_20_sFileLocation_20_3a_20STRING_5b_22_2e_2e_2fsamples_2ffirst_2ehx_22_5d_3b_20_sColumnLocation_20_3a_20STRING_5b33_5d_7d_223_22;  );

////METAELIM: Node_M_First_sExp[Tag_M_First_sExp_xM_x_x28_xExp, (#;)];
 ////METAELIM: Node_M_First_sExp[Tag_M_First_sExpInt, (#_Int_1;)];  ////METAELIM: Node_M_First_sExp[Tag_M_First_sExpFloat, (#_Float_1;)];  ////METAELIM: Node_M_First_sExp[Tag_M_First_sExpName, (#_Name_1;)]; 

////METAPG: %{
////METAPG: /* Meta token for Exp. */ 
////METAPG: TOKEN : { < T_meta1_Exp : ("\u27e8" (" ")* "Exp" (" ")* "\u27e9") > }
////METAPG: MORE : { < "\u27e8" (" ")* "Exp" (" ")* ~["\u27e8","\u27e9"] > { nesting = 0; nestedState = curLexState; } : IN_META_Exp }
////METAPG: <IN_META_Exp> MORE : { "\u27e8" { nesting = 1; } : IN_NESTED_META_Exp }
////METAPG: <IN_NESTED_META_Exp> MORE : { "\u27e8" { nesting++; } }
////METAPG: <IN_NESTED_META_Exp> MORE : { "\u27e9" { if (--nesting <= 0) SwitchTo(IN_META_Exp); } }
////METAPG: <IN_META_Exp> TOKEN : { < T_meta2_Exp : "\u27e9" > { SwitchTo(nestedState); } }
////METAPG: <IN_META_Exp,IN_NESTED_META_Exp> MORE : { < ~[] > }
////METAPG: %}




////METAPG: /* Hx terms of Exp production sort. */
////METAPG: <Hx_Exp> (HX) ::= (HX_TOKEN_Exp)?  <HxPresorted_Exp> .
////METAPG: <HxSorted_Exp> (HX) ::= HX_TOKEN_Exp <HxPresorted_Exp> .
////METAPG: <HxPresorted_Exp> (HX) ::=
////METAPG:   {HX_M_VariableUseSorted} ({Exp}) ({HX_M_RepeatSingle}) (HX_VARIABLE!!!) <HxAttributes>
////METAPG: | {HX_M_MetaApplicationSorted} ({Exp}) ({HX_M_RepeatSingle}) (HX_META_VARIABLE$) ( HX_LBRACKET <HxTerms> HX_RBRACKET | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_ConstructionSorted} ({Exp}) ({HX_M_RepeatSingle}) (HX_CONSTRUCTOR$) ( HX_LBRACKET <HxScopes> HX_RBRACKET | HX_LPAREN <HxTerms> HX_RPAREN | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_UnparsedSorted} ({Exp}) ({HX_M_RepeatSingle}) (HX_CONCRETE$:unconcrete) <HxAttributes>
////METAPG: 
////METAPG: .
////METAPG: token HX_TOKEN_Exp (HX) ::= "Exp" .
////METAPG: 



/* Productions for Name sort with (highest) precedence 0. */

<Name> ::= 
  ////METAPG: meta1_Name:unconcrete |
  ////METAPG: meta2_Name$$:[[unmeta(#,4)]]:{ [[ hxornaked("firstHxPresorted_Name") ]] } |
   <Id>!!!:#_Id_1  {{#_Id_1}}  . 


////SORT: TagSort_M_First_sName ::= ( Tag_M_First_sName;  );
////METAELIM: Node_M_First_sName[Tag_M_First_sNameId, (#_Id_1;)]; 

////METAPG: %{
////METAPG: /* Meta token for Name. */ 
////METAPG: TOKEN : { < T_meta1_Name : ("\u27e8" (" ")* "Name" (" ")* "\u27e9") > }
////METAPG: MORE : { < "\u27e8" (" ")* "Name" (" ")* ~["\u27e8","\u27e9"] > { nesting = 0; nestedState = curLexState; } : IN_META_Name }
////METAPG: <IN_META_Name> MORE : { "\u27e8" { nesting = 1; } : IN_NESTED_META_Name }
////METAPG: <IN_NESTED_META_Name> MORE : { "\u27e8" { nesting++; } }
////METAPG: <IN_NESTED_META_Name> MORE : { "\u27e9" { if (--nesting <= 0) SwitchTo(IN_META_Name); } }
////METAPG: <IN_META_Name> TOKEN : { < T_meta2_Name : "\u27e9" > { SwitchTo(nestedState); } }
////METAPG: <IN_META_Name,IN_NESTED_META_Name> MORE : { < ~[] > }
////METAPG: %}

////METAPG: /* Hx terms of Name production sort. */
////METAPG: <Hx_Name> (HX) ::= (HX_TOKEN_Name)?  <HxPresorted_Name> .
////METAPG: <HxSorted_Name> (HX) ::= HX_TOKEN_Name <HxPresorted_Name> .
////METAPG: <HxPresorted_Name> (HX) ::=
////METAPG:   {HX_M_VariableUseSorted} ({Name}) ({HX_M_RepeatSingle}) (HX_VARIABLE!!!) <HxAttributes>
////METAPG: | {HX_M_MetaApplicationSorted} ({Name}) ({HX_M_RepeatSingle}) (HX_META_VARIABLE$) ( HX_LBRACKET <HxTerms> HX_RBRACKET | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_ConstructionSorted} ({Name}) ({HX_M_RepeatSingle}) (HX_CONSTRUCTOR$) ( HX_LBRACKET <HxScopes> HX_RBRACKET | HX_LPAREN <HxTerms> HX_RPAREN | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_UnparsedSorted} ({Name}) ({HX_M_RepeatSingle}) (HX_CONCRETE$:unconcrete) <HxAttributes>
////METAPG: 
////METAPG: .
////METAPG: token HX_TOKEN_Name (HX) ::= "Name" .
////METAPG: 


////METAPG: /* Hx terms of Type production sort. */
////METAPG: <Hx_Type> (HX) ::= (HX_TOKEN_Type)?  <HxPresorted_Type> .
////METAPG: <HxSorted_Type> (HX) ::= HX_TOKEN_Type <HxPresorted_Type> .
////METAPG: <HxPresorted_Type> (HX) ::=
////METAPG:   {HX_M_VariableUseSorted} ({Type}) ({HX_M_RepeatSingle}) (HX_VARIABLE!!!) <HxAttributes>
////METAPG: | {HX_M_MetaApplicationSorted} ({Type}) ({HX_M_RepeatSingle}) (HX_META_VARIABLE$) ( HX_LBRACKET <HxTerms> HX_RBRACKET | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_ConstructionSorted} ({Type}) ({HX_M_RepeatSingle}) (HX_CONSTRUCTOR$) ( HX_LBRACKET <HxScopes> HX_RBRACKET | HX_LPAREN <HxTerms> HX_RPAREN | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_UnparsedSorted} ({Type}) ({HX_M_RepeatSingle}) (HX_CONCRETE$:unconcrete) <HxAttributes>
////METAPG: | HX_TOKEN_Int$ ( HX_LPAREN HX_RPAREN )?  | HX_TOKEN_Float$ ( HX_LPAREN HX_RPAREN )?  | HX_TOKEN_Unif$  HX_LPAREN <Hx_Type> HX_COMMA <Hx_Type> HX_RPAREN  
////METAPG: .
////METAPG: token HX_TOKEN_Type (HX) ::= "Type" .
////METAPG: token HX_TOKEN_Int (HX) ::= "Int" . token HX_TOKEN_Float (HX) ::= "Float" . token HX_TOKEN_Unif (HX) ::= "Unif" . 


////METAPG: <HxAttributeSynthesized_t> (HX) ::= {HX_M_Attribute} ({HX_M_AttributeKindUp}) (HX_TOKEN_t$) HX_LPAREN {HX_M_AttributeValue} <Hx_Type> HX_RPAREN .
////METAPG: token HX_TOKEN_t (HX) ::= "t" . 

////METAPG: <HxAttributeInherited_e> (HX) ::= {HX_M_Attribute} ({HX_M_AttributeKindDown}) (HX_TOKEN_e$) HX_LBRACE {HX_M_AttributeKeyValue} <Hx_Name> HX_COLON <Hx_Type> HX_RBRACE .
    ////METAPG: token HX_TOKEN_e (HX) ::= "e" . 
    

/* Productions for T token. */

<T> ::= 
////METAPG: meta1_T:unconcrete |
////METAPG: meta2_T$$:[[unmeta(#,1)]]:{ [[ hxornaked("firstHxPresorted_T") ]] } |
{TOKEN_M_First_sT} T$ .
////SORT: Sort_M_First_sT ::= ( TOKEN_M_First_sT[$String]; );

////METAPG: %{
////METAPG: /* Meta token for T. */ 
////METAPG: TOKEN : { < T_meta1_T : ("\u27e8" (" ")* "T" (" ")* "\u27e9") > }
////METAPG: MORE : { < "\u27e8" (" ")* "T" (" ")* ~["\u27e8","\u27e9"] > { nesting = 0; nestedState = curLexState; } : IN_META_T }
////METAPG: <IN_META_T> MORE : { "\u27e8" { nesting = 1; } : IN_NESTED_META_T }
////METAPG: <IN_NESTED_META_T> MORE : { "\u27e8" { nesting++; } }
////METAPG: <IN_NESTED_META_T> MORE : { "\u27e9" { if (--nesting <= 0) SwitchTo(IN_META_T); } }
////METAPG: <IN_META_T> TOKEN : { < T_meta2_T : "\u27e9" > { SwitchTo(nestedState); } }
////METAPG: <IN_META_T,IN_NESTED_META_T> MORE : { < ~[] > }
////METAPG: %}

////METAPG: /* Hx terms of T token sort. */
////METAPG: <Hx_T> (HX) ::= (HX_TOKEN_T)?  <HxPresorted_T> .
////METAPG: <HxSorted_T> (HX) ::= HX_TOKEN_T <HxPresorted_T> .
////METAPG: <HxPresorted_T> (HX) ::=
////METAPG:   {HX_M_VariableUseSorted} ({T}) ({HX_M_RepeatSingle}) (HX_VARIABLE!!!) <HxAttributes>
////METAPG: | {HX_M_MetaApplicationSorted} ({T}) ({HX_M_RepeatSingle}) (HX_META_VARIABLE$) ( HX_LBRACKET <HxTerms>  HX_RBRACKET | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_UnparsedSorted} ({T}) ({HX_M_RepeatSingle}) (HX_CONCRETE$:unconcrete) <HxAttributes>
////METAPG: .
////METAPG: token HX_TOKEN_T (HX) ::= "T" .


/* Productions for I_Progr sort with (highest) precedence 0. */

<I_Progr> ::= 
  ////METAPG: meta1_I_Progr:unconcrete |
  ////METAPG: meta2_I_Progr$$:[[unmeta(#,7)]]:{ [[ hxornaked("firstHxPresorted_I_Progr") ]] } |
  ("ICG" <Stat>:#_Stat_1  {{ Node_M_First_sI_xProgr[I_Progr__M_ICG_Stat, (#_Stat_1;)]}} 
  | ("ICGExp" <Tmp>:#_Tmp_1  <Exp>:#_Exp_2  {{ Node_M_First_sI_xProgr[I_Progr__M_ICGExp_Tmp_Exp, (#_Tmp_1; #_Exp_2;)]}}  
  | ("{" <I_Progr>:#_I_Progr_1 "}" <I_Progr>:#_I_Progr_2  {{ Node_M_First_sI_xProgr[I_Progr__M__7b_I_Progr__M__7d_I_Progr, (#_I_Progr_1; #_I_Progr_2;)]}}  
  | ( <I_Instr>:#_I_Instr_1  <I_Progr>:#_I_Progr_2  {{ Node_M_First_sI_xProgr[I_Progr_I_Instr_I_Progr, (#_I_Instr_1; #_I_Progr_2;)]}}  
  |  {{ Node_M_First_sI_xProgr[I_ProgrEMPTY]}})))) . 


////SORT: TagSort_M_First_sI_xProgr ::= ( Tag_M_First_sI_xProgr; Tag_M_First_sI_xProgr; Tag_M_First_sI_xProgr; Tag_M_First_sI_xProgr; Tag_M_First_sI_xProgr;  );

////METAELIM: Node_M_First_sI_xProgr[Tag_M_First_sI_xProgr_xM_xICG_xStat, (#_Stat_1;)];

////METAELIM: Node_M_First_sI_xProgr[Tag_M_First_sI_xProgr_xM_xICGExp_xTmp, (#_Tmp_1; #_Exp_2;)];

////METAELIM: Node_M_First_sI_xProgr[Tag_M_First_sI_xProgr_xM_x_x7b_xI_xProgr, (#_I_Progr_1; #_I_Progr_2;)];

////METAELIM: Node_M_First_sI_xProgr[Tag_M_First_sI_xProgrI_xInstr_xI_xProgr, (#_I_Instr_1; #_I_Progr_2;)];
 ////METAELIM: Node_M_First_sI_xProgr[Tag_M_First_sI_xProgrEMPTY]; 

////METAPG: %{
////METAPG: /* Meta token for I_Progr. */ 
////METAPG: TOKEN : { < T_meta1_I_Progr : ("\u27e8" (" ")* "I_Progr" (" ")* "\u27e9") > }
////METAPG: MORE : { < "\u27e8" (" ")* "I_Progr" (" ")* ~["\u27e8","\u27e9"] > { nesting = 0; nestedState = curLexState; } : IN_META_I_Progr }
////METAPG: <IN_META_I_Progr> MORE : { "\u27e8" { nesting = 1; } : IN_NESTED_META_I_Progr }
////METAPG: <IN_NESTED_META_I_Progr> MORE : { "\u27e8" { nesting++; } }
////METAPG: <IN_NESTED_META_I_Progr> MORE : { "\u27e9" { if (--nesting <= 0) SwitchTo(IN_META_I_Progr); } }
////METAPG: <IN_META_I_Progr> TOKEN : { < T_meta2_I_Progr : "\u27e9" > { SwitchTo(nestedState); } }
////METAPG: <IN_META_I_Progr,IN_NESTED_META_I_Progr> MORE : { < ~[] > }
////METAPG: %}

////METAPG: /* Hx terms of I_Progr production sort. */
////METAPG: <Hx_I_Progr> (HX) ::= (HX_TOKEN_I_Progr)?  <HxPresorted_I_Progr> .
////METAPG: <HxSorted_I_Progr> (HX) ::= HX_TOKEN_I_Progr <HxPresorted_I_Progr> .
////METAPG: <HxPresorted_I_Progr> (HX) ::=
////METAPG:   {HX_M_VariableUseSorted} ({I_Progr}) ({HX_M_RepeatSingle}) (HX_VARIABLE!!!) <HxAttributes>
////METAPG: | {HX_M_MetaApplicationSorted} ({I_Progr}) ({HX_M_RepeatSingle}) (HX_META_VARIABLE$) ( HX_LBRACKET <HxTerms> HX_RBRACKET | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_ConstructionSorted} ({I_Progr}) ({HX_M_RepeatSingle}) (HX_CONSTRUCTOR$) ( HX_LBRACKET <HxScopes> HX_RBRACKET | HX_LPAREN <HxTerms> HX_RPAREN | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_UnparsedSorted} ({I_Progr}) ({HX_M_RepeatSingle}) (HX_CONCRETE$:unconcrete) <HxAttributes>
////METAPG: 
////METAPG: .
////METAPG: token HX_TOKEN_I_Progr (HX) ::= "I_Progr" .
////METAPG: 



/* Productions for I_Instr sort with (highest) precedence 0. */

<I_Instr> ::= 
  ////METAPG: meta1_I_Instr:unconcrete |
  ////METAPG: meta2_I_Instr$$:[[unmeta(#,7)]]:{ [[ hxornaked("firstHxPresorted_I_Instr") ]] } |
  ( <Tmp>:#_Tmp_1 "=" <I_Arg>:#_I_Arg_2 ("*" <I_Arg>:#_I_Arg_3 ";" {{ Node_M_First_sI_xInstr[I_Instr_Tmp__M__3d_I_Arg__M__2a_I_Arg__M__3b, (#_Tmp_1; #_I_Arg_2; #_I_Arg_3;)]}} 
            | ("+" <I_Arg>:#_I_Arg_3 ";" {{ Node_M_First_sI_xInstr[I_Instr_Tmp__M__3d_I_Arg__M__2b_I_Arg__M__3b, (#_Tmp_1; #_I_Arg_2; #_I_Arg_3;)]}} 
            | ";" {{ Node_M_First_sI_xInstr[I_Instr_Tmp__M__3d_I_Arg__M__3b, (#_Tmp_1; #_I_Arg_2;)]}}))  
  |  <Name>:#_Name_1 "=" <Tmp>:#_Tmp_2 ";" {{ Node_M_First_sI_xInstr[I_Instr_Name__M__3d_Tmp__M__3b, (#_Name_1; #_Tmp_2;)]}}  ) . 


////SORT: TagSort_M_First_sI_xInstr ::= ( Tag_M_First_sI_xInstr; Tag_M_First_sI_xInstr; Tag_M_First_sI_xInstr; Tag_M_First_sI_xInstr;  );

////METAELIM: Node_M_First_sI_xInstr[Tag_M_First_sI_xInstrTmp_x_xM_x_x3d, (#_Tmp_1; #_I_Arg_2; #_I_Arg_3;)];

////METAELIM: Node_M_First_sI_xInstr[Tag_M_First_sI_xInstrTmp_x_xM_x_x3d, (#_Tmp_1; #_I_Arg_2; #_I_Arg_3;)];

////METAELIM: Node_M_First_sI_xInstr[Tag_M_First_sI_xInstrTmp_x_xM_x_x3d, (#_Tmp_1; #_I_Arg_2;)];

////METAELIM: Node_M_First_sI_xInstr[Tag_M_First_sI_xInstrName_x_xM_x_x3d, (#_Name_1; #_Tmp_2;)];


////METAPG: %{
////METAPG: /* Meta token for I_Instr. */ 
////METAPG: TOKEN : { < T_meta1_I_Instr : ("\u27e8" (" ")* "I_Instr" (" ")* "\u27e9") > }
////METAPG: MORE : { < "\u27e8" (" ")* "I_Instr" (" ")* ~["\u27e8","\u27e9"] > { nesting = 0; nestedState = curLexState; } : IN_META_I_Instr }
////METAPG: <IN_META_I_Instr> MORE : { "\u27e8" { nesting = 1; } : IN_NESTED_META_I_Instr }
////METAPG: <IN_NESTED_META_I_Instr> MORE : { "\u27e8" { nesting++; } }
////METAPG: <IN_NESTED_META_I_Instr> MORE : { "\u27e9" { if (--nesting <= 0) SwitchTo(IN_META_I_Instr); } }
////METAPG: <IN_META_I_Instr> TOKEN : { < T_meta2_I_Instr : "\u27e9" > { SwitchTo(nestedState); } }
////METAPG: <IN_META_I_Instr,IN_NESTED_META_I_Instr> MORE : { < ~[] > }
////METAPG: %}

////METAPG: /* Hx terms of I_Instr production sort. */
////METAPG: <Hx_I_Instr> (HX) ::= (HX_TOKEN_I_Instr)?  <HxPresorted_I_Instr> .
////METAPG: <HxSorted_I_Instr> (HX) ::= HX_TOKEN_I_Instr <HxPresorted_I_Instr> .
////METAPG: <HxPresorted_I_Instr> (HX) ::=
////METAPG:   {HX_M_VariableUseSorted} ({I_Instr}) ({HX_M_RepeatSingle}) (HX_VARIABLE!!!) <HxAttributes>
////METAPG: | {HX_M_MetaApplicationSorted} ({I_Instr}) ({HX_M_RepeatSingle}) (HX_META_VARIABLE$) ( HX_LBRACKET <HxTerms> HX_RBRACKET | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_ConstructionSorted} ({I_Instr}) ({HX_M_RepeatSingle}) (HX_CONSTRUCTOR$) ( HX_LBRACKET <HxScopes> HX_RBRACKET | HX_LPAREN <HxTerms> HX_RPAREN | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_UnparsedSorted} ({I_Instr}) ({HX_M_RepeatSingle}) (HX_CONCRETE$:unconcrete) <HxAttributes>
////METAPG: 
////METAPG: .
////METAPG: token HX_TOKEN_I_Instr (HX) ::= "I_Instr" .
////METAPG: 



/* Productions for I_Arg sort with (highest) precedence 0. */

<I_Arg> ::= 
  ////METAPG: meta1_I_Arg:unconcrete |
  ////METAPG: meta2_I_Arg$$:[[unmeta(#,5)]]:{ [[ hxornaked("firstHxPresorted_I_Arg") ]] } |
  ( <Name>:#_Name_1  {{ Node_M_First_sI_xArg[I_Arg_Name, (#_Name_1;)]}} 
  | ( <Float>:#_Float_1  {{ Node_M_First_sI_xArg[I_Arg_Float, (#_Float_1;)]}} 
  | ( <Int>:#_Int_1  {{ Node_M_First_sI_xArg[I_Arg_Int, (#_Int_1;)]}} 
  |  <Tmp>:#_Tmp_1  {{ Node_M_First_sI_xArg[I_Arg_Tmp, (#_Tmp_1;)]}} ))) . 


////SORT: TagSort_M_First_sI_xArg ::= ( Tag_M_First_sI_xArg; Tag_M_First_sI_xArg; Tag_M_First_sI_xArg; Tag_M_First_sI_xArg;  );

////METAELIM: Node_M_First_sI_xArg[Tag_M_First_sI_xArgName, (#_Name_1;)];

////METAELIM: Node_M_First_sI_xArg[Tag_M_First_sI_xArgFloat, (#_Float_1;)];

////METAELIM: Node_M_First_sI_xArg[Tag_M_First_sI_xArgInt, (#_Int_1;)];

////METAELIM: Node_M_First_sI_xArg[Tag_M_First_sI_xArgTmp, (#_Tmp_1;)];


////METAPG: %{
////METAPG: /* Meta token for I_Arg. */ 
////METAPG: TOKEN : { < T_meta1_I_Arg : ("\u27e8" (" ")* "I_Arg" (" ")* "\u27e9") > }
////METAPG: MORE : { < "\u27e8" (" ")* "I_Arg" (" ")* ~["\u27e8","\u27e9"] > { nesting = 0; nestedState = curLexState; } : IN_META_I_Arg }
////METAPG: <IN_META_I_Arg> MORE : { "\u27e8" { nesting = 1; } : IN_NESTED_META_I_Arg }
////METAPG: <IN_NESTED_META_I_Arg> MORE : { "\u27e8" { nesting++; } }
////METAPG: <IN_NESTED_META_I_Arg> MORE : { "\u27e9" { if (--nesting <= 0) SwitchTo(IN_META_I_Arg); } }
////METAPG: <IN_META_I_Arg> TOKEN : { < T_meta2_I_Arg : "\u27e9" > { SwitchTo(nestedState); } }
////METAPG: <IN_META_I_Arg,IN_NESTED_META_I_Arg> MORE : { < ~[] > }
////METAPG: %}

////METAPG: /* Hx terms of I_Arg production sort. */
////METAPG: <Hx_I_Arg> (HX) ::= (HX_TOKEN_I_Arg)?  <HxPresorted_I_Arg> .
////METAPG: <HxSorted_I_Arg> (HX) ::= HX_TOKEN_I_Arg <HxPresorted_I_Arg> .
////METAPG: <HxPresorted_I_Arg> (HX) ::=
////METAPG:   {HX_M_VariableUseSorted} ({I_Arg}) ({HX_M_RepeatSingle}) (HX_VARIABLE!!!) <HxAttributes>
////METAPG: | {HX_M_MetaApplicationSorted} ({I_Arg}) ({HX_M_RepeatSingle}) (HX_META_VARIABLE$) ( HX_LBRACKET <HxTerms> HX_RBRACKET | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_ConstructionSorted} ({I_Arg}) ({HX_M_RepeatSingle}) (HX_CONSTRUCTOR$) ( HX_LBRACKET <HxScopes> HX_RBRACKET | HX_LPAREN <HxTerms> HX_RPAREN | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_UnparsedSorted} ({I_Arg}) ({HX_M_RepeatSingle}) (HX_CONCRETE$:unconcrete) <HxAttributes>
////METAPG: 
////METAPG: .
////METAPG: token HX_TOKEN_I_Arg (HX) ::= "I_Arg" .
////METAPG: 



/* Productions for Tmp sort with (highest) precedence 0. */

<Tmp> ::= 
  ////METAPG: meta1_Tmp:unconcrete |
  ////METAPG: meta2_Tmp$$:[[unmeta(#,3)]]:{ [[ hxornaked("firstHxPresorted_Tmp") ]] } |
   <T>!!!:#_T_1  {{#_T_1}}  . 


////SORT: TagSort_M_First_sTmp ::= ( Tag_M_First_sTmp;  );
////METAELIM: Node_M_First_sTmp[Tag_M_First_sTmpT, (#_T_1;)]; 

////METAPG: %{
////METAPG: /* Meta token for Tmp. */ 
////METAPG: TOKEN : { < T_meta1_Tmp : ("\u27e8" (" ")* "Tmp" (" ")* "\u27e9") > }
////METAPG: MORE : { < "\u27e8" (" ")* "Tmp" (" ")* ~["\u27e8","\u27e9"] > { nesting = 0; nestedState = curLexState; } : IN_META_Tmp }
////METAPG: <IN_META_Tmp> MORE : { "\u27e8" { nesting = 1; } : IN_NESTED_META_Tmp }
////METAPG: <IN_NESTED_META_Tmp> MORE : { "\u27e8" { nesting++; } }
////METAPG: <IN_NESTED_META_Tmp> MORE : { "\u27e9" { if (--nesting <= 0) SwitchTo(IN_META_Tmp); } }
////METAPG: <IN_META_Tmp> TOKEN : { < T_meta2_Tmp : "\u27e9" > { SwitchTo(nestedState); } }
////METAPG: <IN_META_Tmp,IN_NESTED_META_Tmp> MORE : { < ~[] > }
////METAPG: %}

////METAPG: /* Hx terms of Tmp production sort. */
////METAPG: <Hx_Tmp> (HX) ::= (HX_TOKEN_Tmp)?  <HxPresorted_Tmp> .
////METAPG: <HxSorted_Tmp> (HX) ::= HX_TOKEN_Tmp <HxPresorted_Tmp> .
////METAPG: <HxPresorted_Tmp> (HX) ::=
////METAPG:   {HX_M_VariableUseSorted} ({Tmp}) ({HX_M_RepeatSingle}) (HX_VARIABLE!!!) <HxAttributes>
////METAPG: | {HX_M_MetaApplicationSorted} ({Tmp}) ({HX_M_RepeatSingle}) (HX_META_VARIABLE$) ( HX_LBRACKET <HxTerms> HX_RBRACKET | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_ConstructionSorted} ({Tmp}) ({HX_M_RepeatSingle}) (HX_CONSTRUCTOR$) ( HX_LBRACKET <HxScopes> HX_RBRACKET | HX_LPAREN <HxTerms> HX_RPAREN | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_UnparsedSorted} ({Tmp}) ({HX_M_RepeatSingle}) (HX_CONCRETE$:unconcrete) <HxAttributes>
////METAPG: 
////METAPG: .
////METAPG: token HX_TOKEN_Tmp (HX) ::= "Tmp" .
////METAPG: 


////METAPG: <HxAttributeInherited_TmpType> (HX) ::= {HX_M_Attribute} ({HX_M_AttributeKindDown}) (HX_TOKEN_TmpType$) HX_LBRACE {HX_M_AttributeKeyValue} <Hx_Tmp> HX_COLON <Hx_Type> HX_RBRACE .
    ////METAPG: token HX_TOKEN_TmpType (HX) ::= "TmpType" . 
    

/* Productions for A_Progr sort with (highest) precedence 0. */

<A_Progr> ::= 
  ////METAPG: meta1_A_Progr:unconcrete |
  ////METAPG: meta2_A_Progr$$:[[unmeta(#,7)]]:{ [[ hxornaked("firstHxPresorted_A_Progr") ]] } |
  ("CG" <I_Progr>:#_I_Progr_1  {{ Node_M_First_sA_xProgr[A_Progr__M_CG_I_Progr, (#_I_Progr_1;)]}} 
  | ("Compile" <Stat>:#_Stat_1  {{ Node_M_First_sA_xProgr[A_Progr__M_Compile_Stat, (#_Stat_1;)]}} 
  | ( <A_Instr>:#_A_Instr_1  <A_Progr>:#_A_Progr_2  {{ Node_M_First_sA_xProgr[A_Progr_A_Instr_A_Progr, (#_A_Instr_1; #_A_Progr_2;)]}}  
  |  {{ Node_M_First_sA_xProgr[A_ProgrEMPTY]}}))) . 


////SORT: TagSort_M_First_sA_xProgr ::= ( Tag_M_First_sA_xProgr; Tag_M_First_sA_xProgr; Tag_M_First_sA_xProgr; Tag_M_First_sA_xProgr;  );

////METAELIM: Node_M_First_sA_xProgr[Tag_M_First_sA_xProgr_xM_xCG_xI_xProgr, (#_I_Progr_1;)];

////METAELIM: Node_M_First_sA_xProgr[Tag_M_First_sA_xProgr_xM_xCompile_xStat, (#_Stat_1;)];

////METAELIM: Node_M_First_sA_xProgr[Tag_M_First_sA_xProgrA_xInstr_xA_xProgr, (#_A_Instr_1; #_A_Progr_2;)];
 ////METAELIM: Node_M_First_sA_xProgr[Tag_M_First_sA_xProgrEMPTY]; 

////METAPG: %{
////METAPG: /* Meta token for A_Progr. */ 
////METAPG: TOKEN : { < T_meta1_A_Progr : ("\u27e8" (" ")* "A_Progr" (" ")* "\u27e9") > }
////METAPG: MORE : { < "\u27e8" (" ")* "A_Progr" (" ")* ~["\u27e8","\u27e9"] > { nesting = 0; nestedState = curLexState; } : IN_META_A_Progr }
////METAPG: <IN_META_A_Progr> MORE : { "\u27e8" { nesting = 1; } : IN_NESTED_META_A_Progr }
////METAPG: <IN_NESTED_META_A_Progr> MORE : { "\u27e8" { nesting++; } }
////METAPG: <IN_NESTED_META_A_Progr> MORE : { "\u27e9" { if (--nesting <= 0) SwitchTo(IN_META_A_Progr); } }
////METAPG: <IN_META_A_Progr> TOKEN : { < T_meta2_A_Progr : "\u27e9" > { SwitchTo(nestedState); } }
////METAPG: <IN_META_A_Progr,IN_NESTED_META_A_Progr> MORE : { < ~[] > }
////METAPG: %}

////METAPG: /* Hx terms of A_Progr production sort. */
////METAPG: <Hx_A_Progr> (HX) ::= (HX_TOKEN_A_Progr)?  <HxPresorted_A_Progr> .
////METAPG: <HxSorted_A_Progr> (HX) ::= HX_TOKEN_A_Progr <HxPresorted_A_Progr> .
////METAPG: <HxPresorted_A_Progr> (HX) ::=
////METAPG:   {HX_M_VariableUseSorted} ({A_Progr}) ({HX_M_RepeatSingle}) (HX_VARIABLE!!!) <HxAttributes>
////METAPG: | {HX_M_MetaApplicationSorted} ({A_Progr}) ({HX_M_RepeatSingle}) (HX_META_VARIABLE$) ( HX_LBRACKET <HxTerms> HX_RBRACKET | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_ConstructionSorted} ({A_Progr}) ({HX_M_RepeatSingle}) (HX_CONSTRUCTOR$) ( HX_LBRACKET <HxScopes> HX_RBRACKET | HX_LPAREN <HxTerms> HX_RPAREN | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_UnparsedSorted} ({A_Progr}) ({HX_M_RepeatSingle}) (HX_CONCRETE$:unconcrete) <HxAttributes>
////METAPG: | HX_TOKEN_Compile$  HX_LPAREN <Hx_Stat> HX_RPAREN  
////METAPG: .
////METAPG: token HX_TOKEN_A_Progr (HX) ::= "A_Progr" .
////METAPG: token HX_TOKEN_Compile (HX) ::= "Compile" . 



/* Productions for A_Instr sort with (highest) precedence 0. */

<A_Instr> ::= 
  ////METAPG: meta1_A_Instr:unconcrete |
  ////METAPG: meta2_A_Instr$$:[[unmeta(#,7)]]:{ [[ hxornaked("firstHxPresorted_A_Instr") ]] } |
  ("ADDF" <A_Arg>:#_A_Arg_1 "," <A_Arg>:#_A_Arg_2 "," <A_Arg>:#_A_Arg_3  {{ Node_M_First_sA_xInstr[A_Instr__M_ADDF_A_Arg__M__2c_A_Arg__M__2c_A_Arg, (#_A_Arg_1; #_A_Arg_2; #_A_Arg_3;)]}}   
  | ("LDF" <Tmp>:#_Tmp_1 "," <A_Arg>:#_A_Arg_2  {{ Node_M_First_sA_xInstr[A_Instr__M_LDF_Tmp__M__2c_A_Arg, (#_Tmp_1; #_A_Arg_2;)]}}  
  | ("MULF" <A_Arg>:#_A_Arg_1 "," <A_Arg>:#_A_Arg_2 "," <A_Arg>:#_A_Arg_3  {{ Node_M_First_sA_xInstr[A_Instr__M_MULF_A_Arg__M__2c_A_Arg__M__2c_A_Arg, (#_A_Arg_1; #_A_Arg_2; #_A_Arg_3;)]}}   
  | "STF" <Name>:#_Name_1 "," <Tmp>:#_Tmp_2  {{ Node_M_First_sA_xInstr[A_Instr__M_STF_Name__M__2c_Tmp, (#_Name_1; #_Tmp_2;)]}}  ))) . 


////SORT: TagSort_M_First_sA_xInstr ::= ( Tag_M_First_sA_xInstr; Tag_M_First_sA_xInstr; Tag_M_First_sA_xInstr; Tag_M_First_sA_xInstr;  );

////METAELIM: Node_M_First_sA_xInstr[Tag_M_First_sA_xInstr_xM_xADDF_xA_xArg, (#_A_Arg_1; #_A_Arg_2; #_A_Arg_3;)];

////METAELIM: Node_M_First_sA_xInstr[Tag_M_First_sA_xInstr_xM_xLDF_xTmp, (#_Tmp_1; #_A_Arg_2;)];

////METAELIM: Node_M_First_sA_xInstr[Tag_M_First_sA_xInstr_xM_xMULF_xA_xArg, (#_A_Arg_1; #_A_Arg_2; #_A_Arg_3;)];

////METAELIM: Node_M_First_sA_xInstr[Tag_M_First_sA_xInstr_xM_xSTF_xName, (#_Name_1; #_Tmp_2;)];


////METAPG: %{
////METAPG: /* Meta token for A_Instr. */ 
////METAPG: TOKEN : { < T_meta1_A_Instr : ("\u27e8" (" ")* "A_Instr" (" ")* "\u27e9") > }
////METAPG: MORE : { < "\u27e8" (" ")* "A_Instr" (" ")* ~["\u27e8","\u27e9"] > { nesting = 0; nestedState = curLexState; } : IN_META_A_Instr }
////METAPG: <IN_META_A_Instr> MORE : { "\u27e8" { nesting = 1; } : IN_NESTED_META_A_Instr }
////METAPG: <IN_NESTED_META_A_Instr> MORE : { "\u27e8" { nesting++; } }
////METAPG: <IN_NESTED_META_A_Instr> MORE : { "\u27e9" { if (--nesting <= 0) SwitchTo(IN_META_A_Instr); } }
////METAPG: <IN_META_A_Instr> TOKEN : { < T_meta2_A_Instr : "\u27e9" > { SwitchTo(nestedState); } }
////METAPG: <IN_META_A_Instr,IN_NESTED_META_A_Instr> MORE : { < ~[] > }
////METAPG: %}

////METAPG: /* Hx terms of A_Instr production sort. */
////METAPG: <Hx_A_Instr> (HX) ::= (HX_TOKEN_A_Instr)?  <HxPresorted_A_Instr> .
////METAPG: <HxSorted_A_Instr> (HX) ::= HX_TOKEN_A_Instr <HxPresorted_A_Instr> .
////METAPG: <HxPresorted_A_Instr> (HX) ::=
////METAPG:   {HX_M_VariableUseSorted} ({A_Instr}) ({HX_M_RepeatSingle}) (HX_VARIABLE!!!) <HxAttributes>
////METAPG: | {HX_M_MetaApplicationSorted} ({A_Instr}) ({HX_M_RepeatSingle}) (HX_META_VARIABLE$) ( HX_LBRACKET <HxTerms> HX_RBRACKET | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_ConstructionSorted} ({A_Instr}) ({HX_M_RepeatSingle}) (HX_CONSTRUCTOR$) ( HX_LBRACKET <HxScopes> HX_RBRACKET | HX_LPAREN <HxTerms> HX_RPAREN | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_UnparsedSorted} ({A_Instr}) ({HX_M_RepeatSingle}) (HX_CONCRETE$:unconcrete) <HxAttributes>
////METAPG: 
////METAPG: .
////METAPG: token HX_TOKEN_A_Instr (HX) ::= "A_Instr" .
////METAPG: 



/* Productions for A_Arg sort with (highest) precedence 0. */

<A_Arg> ::= 
  ////METAPG: meta1_A_Arg:unconcrete |
  ////METAPG: meta2_A_Arg$$:[[unmeta(#,5)]]:{ [[ hxornaked("firstHxPresorted_A_Arg") ]] } |
  ("#"( <Float>:#_Float_1  {{ Node_M_First_sA_xArg[A_Arg__M__h_Float, (#_Float_1;)]}} 
  |  <Int>:#_Int_1  {{ Node_M_First_sA_xArg[A_Arg__M__h_Int, (#_Int_1;)]}} )
  | ("[" <I_Arg>:#_I_Arg_1 "]" {{ Node_M_First_sA_xArg[A_Arg__M__5b_I_Arg__M__5d, (#_I_Arg_1;)]}} 
  | ( <Name>:#_Name_1  {{ Node_M_First_sA_xArg[A_Arg_Name, (#_Name_1;)]}} 
  |  <Tmp>:#_Tmp_1  {{ Node_M_First_sA_xArg[A_Arg_Tmp, (#_Tmp_1;)]}} ))) . 


////SORT: TagSort_M_First_sA_xArg ::= ( Tag_M_First_sA_xArg; Tag_M_First_sA_xArg; Tag_M_First_sA_xArg; Tag_M_First_sA_xArg; Tag_M_First_sA_xArg;  );

////METAELIM: Node_M_First_sA_xArg[Tag_M_First_sA_xArg_xM_x_xh_xFloat, (#_Float_1;)];

////METAELIM: Node_M_First_sA_xArg[Tag_M_First_sA_xArg_xM_x_xh_xInt, (#_Int_1;)];

////METAELIM: Node_M_First_sA_xArg[Tag_M_First_sA_xArg_xM_x_x5b_xI_xArg, (#_I_Arg_1;)];

////METAELIM: Node_M_First_sA_xArg[Tag_M_First_sA_xArgName, (#_Name_1;)];

////METAELIM: Node_M_First_sA_xArg[Tag_M_First_sA_xArgTmp, (#_Tmp_1;)];


////METAPG: %{
////METAPG: /* Meta token for A_Arg. */ 
////METAPG: TOKEN : { < T_meta1_A_Arg : ("\u27e8" (" ")* "A_Arg" (" ")* "\u27e9") > }
////METAPG: MORE : { < "\u27e8" (" ")* "A_Arg" (" ")* ~["\u27e8","\u27e9"] > { nesting = 0; nestedState = curLexState; } : IN_META_A_Arg }
////METAPG: <IN_META_A_Arg> MORE : { "\u27e8" { nesting = 1; } : IN_NESTED_META_A_Arg }
////METAPG: <IN_NESTED_META_A_Arg> MORE : { "\u27e8" { nesting++; } }
////METAPG: <IN_NESTED_META_A_Arg> MORE : { "\u27e9" { if (--nesting <= 0) SwitchTo(IN_META_A_Arg); } }
////METAPG: <IN_META_A_Arg> TOKEN : { < T_meta2_A_Arg : "\u27e9" > { SwitchTo(nestedState); } }
////METAPG: <IN_META_A_Arg,IN_NESTED_META_A_Arg> MORE : { < ~[] > }
////METAPG: %}

////METAPG: /* Hx terms of A_Arg production sort. */
////METAPG: <Hx_A_Arg> (HX) ::= (HX_TOKEN_A_Arg)?  <HxPresorted_A_Arg> .
////METAPG: <HxSorted_A_Arg> (HX) ::= HX_TOKEN_A_Arg <HxPresorted_A_Arg> .
////METAPG: <HxPresorted_A_Arg> (HX) ::=
////METAPG:   {HX_M_VariableUseSorted} ({A_Arg}) ({HX_M_RepeatSingle}) (HX_VARIABLE!!!) <HxAttributes>
////METAPG: | {HX_M_MetaApplicationSorted} ({A_Arg}) ({HX_M_RepeatSingle}) (HX_META_VARIABLE$) ( HX_LBRACKET <HxTerms> HX_RBRACKET | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_ConstructionSorted} ({A_Arg}) ({HX_M_RepeatSingle}) (HX_CONSTRUCTOR$) ( HX_LBRACKET <HxScopes> HX_RBRACKET | HX_LPAREN <HxTerms> HX_RPAREN | {$Nil} ) <HxAttributes>
////METAPG: | {HX_M_UnparsedSorted} ({A_Arg}) ({HX_M_RepeatSingle}) (HX_CONCRETE$:unconcrete) <HxAttributes>
////METAPG: 
////METAPG: .
////METAPG: token HX_TOKEN_A_Arg (HX) ::= "A_Arg" .
////METAPG: 



/* TOKENS. */

skip ::= ' ' | [' ','\t','\n']   .
token Int ::= ( Digit )+   .
token Float ::= Int "." Int   .
token Id ::= ( Lower )+ ( ( ( '_' )? Int   ) )?   .
token fragment Digit ::= ['0'-'9']   . 
token fragment Lower ::= ['a'-'z']   . 
token T ::= "T" ( ( '_' Int   ) )?   . 
