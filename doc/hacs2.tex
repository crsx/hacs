%% HACS 2 NOTES.
%%
%% Copyright (c) 2015 Kristoffer Rose <krisrose@crsx.org>
%%
\documentclass[11pt]{article} %style: font size.
\usepackage[utf8]{inputenc}

\usepackage[type={CC},modifier={by},version={4.0}]{doclicense}
\newcommand{\basecopyright}{\noindent
  \HAX is © 2011, 2016 Kristoffer Rose and released under the
  \href{https://www.eclipse.org/legal/epl-v10.html}{Eclipse Public License 1.0}.\\
  \noindent Documentation is \doclicenseImage[imagewidth=3em]
  2011,2016 Kristoffer Rose.}
\newcommand{\documentcopyright}{\basecopyright}

%% Style.
\usepackage[margin=.7in]{geometry}
\usepackage[T1]{fontenc}
\bibliographystyle{plainurl}
\renewcommand{\rmdefault}{pplx}\usepackage{eulervm}\AtBeginDocument{\SelectTips{eu}{11}}

%% Base format.
\input{setup}

%% Topmatter.
\title{
  Evolution From \HAX\ 1 to 2
}
\author{
  Kristoffer H. Rose\\
  Two Sigma Investments / New York University
}

\begin{document}
\maketitle

\begin{abstract}\noindent
  This document discusses curious implementation details of \HAX version 1 and how they should be
  fixed and new things added in \HAX version 2.

  \compacttableofcontents

  \vspace*{2em}\small\color{gray}\noindent%
  \documentcopyright
\end{abstract}


\section{Overview}\label{sec:overview}

\HAX1 is written as the following components:
%%
\begin{itemize}

\item The main program is a shell script \emph{hacs} combined with a makefile \emph{Hacs.mk}.

\item A parser, \emph{HxRaw}, which is generated by instantiating the \emph{HxRaw.pgtemplate} with
  the four \emph{Hx.*} files and using pg and JavaCC. The resulting parser will take a \emph{.hx}
  file into a generic ``raw'' \CRSX3 term form (the instructions for that are in \emph{Hacs.mk}).

\item A \CRSX3 script, \emph{Prep.crs}, which from a ``raw'' \CRSX3 term form of a \emph{.hx} file
  will generate a single file with three parsers (detailed in Section~\ref{sec:parsing}). One of
  these parsers is fully compiled to serve the following script.

\item A \CRSX3 script, \emph{Cook.crs}, which is run on a \CRSX3 term of the \emph{.hx} file, which
  is generated by one of the custom parsers of the previous step. The output of the \emph{Cook.crs}
  script is itself a \CRSX3 script, which can be run with the special user parser (also from
  \emph{Prep.crs}) to implement the user's intent (see Section~\ref{sec:compiling} for further
  details on this).

\end{itemize}
%%
The following sections give further details on how \HAX1 is implemented and what should be fixed for
\HAX2.


\section{Lexing \& Parsing}\label{sec:parsing}

In version 1, the \emph{Prep.crs} script translates a grammar to three parsers in mixed pg/JavaCC
form:
%%
\begin{itemize}

\item\emph{User input parser.} Has all user syntax as specified by the grammar with no recognition
  of \HAX meta-notation ("⟦⟨⟩⟧"). Generates user AST terms. Only parser that is used by the final
  user script.

\item\emph{Raw parser.} Recognizes all declared ``raw'' constructs as well as generic \HAX syntax
  (meta-variables with \#, \etc). All material in syntax brackets ("⟦⟧") results in invocation of
  the embedded parser below. Generates Cook-ready internal \HAX AST.

\item\emph{Embedded parser.} Recognizes the user's specified syntax extended with \HAX meta-notation
  for embedding ``raw'' \HAX into syntax. All raw syntax is delegated to the raw parser
  above. Generates Cook-ready internal \HAX AST.

\end{itemize}
%%
In version 2, we plan for several tweaks to this. (See also the Modules Section~\ref{sec:modules}
for the plan to allow modular parsers and the Sugar Section~\ref{sec:sugar} for plans to fix
\kw{sugar}.)

\subsection{Repetition}

We reintroduce automatic list generation by having derived non-terminals of the form $NM$
where $N$ is a non-terminal and $M$ is one of "?", "*", and "+"$U$, with the usual RE semantics
and $U$ an optional unit as in \kw{token} declarations allowed just for "+". The resulting
non-terminal is registered as such, making the following kinds of definitions possible:
%% 
\begin{itemize}

\item For $M="?"$ the required patterns are:
  \begin{hacs}[mathescape]
    sort … | scheme F($N$?);
    F(⟦ ⟨$N$ #1⟩ ⟧) →  …; //present
    F(⟦ ⟧) →  …; //absent
  \end{hacs}

\item For $M="*"$ the required patterns are:
  %% 
  \begin{hacs}[mathescape]
    sort … | scheme F($N$*);
    F(⟦ ⟨$N$ #1⟩ ⟨$N$* #rest⟩ ⟧) →  …; //one more
    F(⟦ ⟧) →  …; //end
  \end{hacs}
  %% 
  The first rule is applied for every list element, and the second at the end of the list
  (innermost).

\item For $M="+"U$, the patterns include the special $U$ separator and must have this shape:
  \begin{hacs}[mathescape]
    sort … | scheme F($N$+$U$);
    F(⟦ ⟨$N$ #1⟩ $U$ ⟨$N$+$U$ #rest⟩ ⟧) →  …; //non-last
    F(⟦ ⟨$N$ #1⟩ ⟧) →  …; //last
  \end{hacs}
  where the second rule is applied to just the last list element (so innermost). The first rule
  should insert the $U$ literally, of course, for example like this:
  \begin{hacs}[mathescape]
    sort Bool | scheme IsSingle(Elem+[,]);
    IsSingle(⟦ ⟨Elem #1⟩ ,  ⟨Elem+[,] #rest⟩ ⟧) →  False;
    IsSingle(⟦ ⟨Elem #1⟩ ⟧) →  True;
  \end{hacs}

\end{itemize}
%% 
Note that we will not allow $M="*"U$, which you can emulate with $"*"U"?"$:
%% 
\begin{hacs}[mathescape]
    sort … | scheme F($N$+$U$?) | scheme F2($N$+$U$); F(⟦ ⟨$N$+$U$ #⟩ ⟧) →  F2(#);

    F(⟦ ⟧) →  …;  //empty
    F2(⟦ ⟨$N$ #1⟩ $U$ ⟨$N$*$U$ #rest⟩ ⟧) →  …; //non-last
    F2(⟦ ⟨$N$ #1⟩ ⟧) →  …; //last
\end{hacs}


\section{Modules}\label{sec:modules}

In version 1, one can only have one top level module. In version 2, modules can be combined.  The
semantics of multiple modules is as follows:

\subsection{Inclusion}

Modules can \emph{include} other modules with code like this:
\begin{hacs}
    include org.crsx.hacs.Prelude;
\end{hacs}
This will search for a file named something like \emph{org/crsx/hacs/Prelude.hx} with some search
path mechanism to be determined.  The include mechanism operates as if all the declarations of the
included module were \emph{copied} into the location of the include declaration.  In particular,
all syntax is included as is, so the including module can create extensions of the included
parser. Note that internal nodes generated by the including parser will be incompatible with nodes
generated by the original parser.

\subsection{Import}

Modules can \emph{import} another module with code like this:
\begin{hacs}
    import org.crsx.hacs.Prelude;
\end{hacs}
This will search for a file named something like \emph{org/crsx/hacs/Prelude.hx} with some search
path mechanism to be determined.  After the import, all tokens and sort defined in the imported
module are available with their fully qualified names, however, they cannot be referenced from
inside embedded syntax productions (with "⟨⟩").

\subsection{Private Declarations}

All declarations in a module can be marked with the keyword \kw{private}. This hides them from
\kw{import} (but not from \kw{include}, where the privateness is merely repeated). For the generated
parsers, in addition any \kw{private}-declared syntax is omitted from the user input parsers.


\section{Attributes}\label{sec:attributes}

A key feature of \HAX1 is the rules for synthesized and inherited attributes:
%%
\begin{itemize}

\item Synthesized attributes are limited to simple upwards propagation (S-attributed) rules, and
  only one attribute can be defined at the time in this way.

\item Inherited attributes must be ``carried'' by a scheme and are only available during the single
  traversal of that scheme, leading to complex ``chain rules'' of multiple helper schemes and
  non-trivial interactions with synthesized attributes.

\end{itemize}
%%
This is messy and hard to explain, and \HAX2 attempts to generalize it…

\subsection{Catchers}

First, we intend to follow \hax and change the syntax for ``catcher'' meta-variables in \HAX2 to
just "{#}", changing set lookup to "{#:}" and making "{:#}" deprecated. Also, \HAX2 will permit
multiple maps per instance, \eg, "↓e{a:A,b:B}" and "↓e{#1,#2}" (which in patterns catch all mappings
in both catchers and in contractions compute the biased union of the two, with "#2" dominating
"#1").

\subsection{Inherited Attributes on Data}

In \HAX2, we allow inherited attributes declared on an entire sort (like synthesized
attributes). What this means is that \emph{all} data constructions of that sort can carry that
inherited attribute.

This also means that the ``collect all synthesized'' construct ${↓}m$ is replaced with a ``collect
all attributes'' construct ${↕}\text{\#as}$, which captures all inherited and synthesized attributes.

\subsection{Unified Attribution Rules}

In \HAX2 we unify all attribute rules into rules of the general form
%%
\begin{equation}
  \ov{{↓}i_0}  ~ d\!\left(\,\ov{\, \ov{{↓}i} \, t \, \ov{{↑}s} \,}\,\right) ~ \ov{{↑}s_0}
  \label{eq:attributes}
\end{equation}
%%
with the intent that
%%
\begin{itemize}

\item $d$ is a data constructor representing an abstract syntax tree node corresponding to one
  production that we call ``the $d$ production;''

\item ${↓}i_{0,1}…{↓}i_{0,k}$ (for $k≥0$) represent the inherited attributes that are extracted from
  the $d$ production parent: these should be patterns;

\item The various ${↑}s_{j,1}…{↑}s_{j,k}$ (for $k≥0$) represent the synthesized attributes that are
  extracted from the $d$ production component~$t_j$: these should be patterns;

\item The various ${↓}i_{j,1}…{↓}i_{j,k}$ (for $k≥0$) represent the inherited attributes that are
  defined for the $d$ production component~$t_j$: these should be contractions (so introduce no new
  meta-variables);

\item ${↑}s_{0,1}…{↑}s_{0,k}$ (for $k≥0$) represent the synthesized attributes that are defined for
  the $d$ production parent: these should be contractions;

\end{itemize}
%%
The above works with the following constraints:
%%
\begin{itemize}
\item there are no attributes in the term than those explicitly covered by the rule;
\item the attribute values should follow an ``L-attributed pattern.''
\end{itemize}
%%
Note that the involved attributes should be declared.

With the above, we can observe that the following SDD (inspired by the manual~\cite{Rose:ts2016}) is
\emph{L-attributed}:
%%
\begin{equation*}
  \begin{array}{r@{\;}l|lr}
    \Xhline{2\arrayrulewidth}
    \multicolumn{2}{l|}{\textsc{Production}}  & \textsc{Semantic Rules} &\Bigstrut\\
    \hline\Bigstrut
    S &→ \textbf{id} := E_1; S_2
    & E_1.e = S.e; S_2.e = \op{Extend}(S.e, \textbf{id}.sym, E_1.t) &\thetag{S1}
    \\[\jot]
    &\mid \{~S_1~\}~S_2 & S_1.e = S.e; S_2.e = S.e &\thetag{S2}
    \\[\jot]
    &\mid ε & &\thetag{S3}
    \\[\jot]
    \hline\Bigstrut
    E &→ E_1 + E_2 & E_1.e=E.e; E_2.e=E.e; E.t = \op{Unif}(E_1.t, E_2.t) &\thetag{E1}\\[\jot]
    &\mid \textbf{int} & E.t = \op{Int}&\thetag{E2}\\[\jot]
    &\mid \textbf{id} & E.t = \op{Lookup}(E.e,\textbf{id}.sym)&\thetag{E3}
    \\[\jot]
    \Xhline{2\arrayrulewidth}
  \end{array}
\end{equation*}

\begin{figure}[p]
  \begin{hacs}[texcl,numbers=right,xrightmargin=2em]
// Implementation of simple type checking SDD.
module org.crsx.hacs.samples2.Typing {

  // Grammar.
  token INT  | [0-9]+;
  token ID  | [A-Z] [A-Za-z0-9_]*;
  main sort S  | ⟦ ⟨ID⟩ := ⟨E⟩; ⟨S⟩ ⟧  | ⟦ { ⟨S⟩ } ⟨S⟩ ⟧  | ⟦⟧;
  sort E  | ⟦ ⟨E@1⟩ + ⟨E⟩ ⟧  | ⟦⟨INT⟩⟧@1  | ⟦⟨ID⟩⟧@1;

  // Attributes.
  sort T  | Int  | scheme Unif(T,T);
  attribute ↓e{ID:T};
  attribute ↑t(T);
  //…(rules for Unif omitted)

  // Rules for statements.
  sort S | ↓e;

  // S1: $E_1.e = S.e; S_2.e = \op{Extend}(S.e, \textbf{id}.sym, E_1.t) $
  ↓e{#Se} ⟦ id := ⟨↓e{#Se} E#1 ↑t(#E1t)⟩; ⟨↓e{#Se,⟦id⟧:#E1t}⟩ S#2⟩ ⟧;

  // S2: $S_1.e = S.e; S_2.e = S.e $
  ↓e{#Se} ⟦ { ⟨S#1 ↓e{#Se}⟩ } ⟨S#2 ↓e{#Se}⟩ ⟧;

  // S3:
  ↓e{#Se} ⟦ ⟧;

  // Rules for expressions.
  sort E | ↓e | ↑t; // note: t depends on e from (E3)

  // E1: $E_1.e=E.e; E_2.e=E.e; E.t = \op{Unif}(E_1.t, E_2.t)$
  ↓e{#Ee} ⟦ ⟨↓e{#Ee} E#1 ↑t(#E1t)⟩  + ⟨↓e{#Ee} E#2 ↑t(#E2t) ⟩ ⟧  ↑t(Unif(#E1t,#E2t));

  // E2: $E.t = \op{Int}$
  ⟦ ⟨INT#1⟩ ⟧  ↑t(Int);

  // E3: $E.t = \op{Lookup}(E.e,\textbf{id}.sym)$
  ↓e{⟦id⟧ : #t} ⟦id⟧ ↑t(#t);
}
  \end{hacs}
  \caption{Translation of sample SDD.}
  \label{fig:sdd-in-hacs}
\end{figure}

Figure~\ref{fig:sdd-in-hacs} shows the \HAX2 encoding of the rules.
%%
Note that we are here using the new notation permitted for \HAX2: that the order or attributes and
their associated term does not matter: "↓a(A)B" is the same as "B↓a(A)".
%%
The full formal details of how attribution rules are realized are given in
Appendix~\ref{app:attributes}.


\section{Inference Rules}\label{sec:infer}

\HAX1 has no support for inference rules. In \HAX2, we hope to add (higher order) \emph{inference
  rules} of the form
%%
\begin{equation}\label{eq:when-infer}
  \kw{sort}~S~;\quad
  [R]~\kw{when}~[\ov{x~\kw{as}~S'}](\, C_1⇒P_1 ~\cdots~ C_n⇒P_n \,) ~ \kw{infer} ~ P_0 ⇒ C_{n+1} ~;
\end{equation}
%% 
where
%% 
\begin{itemize}
\item $R$ is the unique name of the rule (as also allowed on other rules).
\item $P_0$ and all of $C_1,…,C_n$ are \emph{function constructions}.
\item $P_0$ is a \emph{pattern} and all of $P_1,…,P_n$ are \emph{pattern fragments}.
\item $∀i\colon \op{mv}(C_i) ⊆ \op{mv}(P_0…P_{i-1})$.
\item Each of the $C_i,P_i$ terms has some sort $S_i$.
\item The variables $x_i$ can occur in all the $C_j,P_j$ of sort $S'_i$.
\end{itemize}
%%
You must define the shape of $P_0$ as a \kw{scheme} of the sort $S$ in the usual way, and the
inference rule translate to rewrite rules that simplify $P_0$, however, the inference rule mechanism
allows multiple inference rules for the same $P_0$ as long as they differ in some $P_i$.

The new syntax is meant to correspond to a traditional inference rule with explicit higher order
binders that we could write
%% 
\begin{equation}
  \dfrac
  { ∀\,\ov{x} : (\, C_1⇒P_1 ~\cdots~ C_n⇒P_n \,) }
  { P_0 ⇒ C_{n+1}}
  ~(R)
  \label{eq:infer}
\end{equation}
%%
Note that inference rules as described here are \emph{not} ``Conditional Term Rewriting Systems:''
no restrictions on evaluation are implied.

We formalize in some detail in Appendix~\ref{app:infer}.


\section{Sugar}\label{sec:sugar}

\HAX2 permits some additional syntactic sugar:
%%
\begin{enumerate}

\item Currently \kw{sugar} declarations really only work for usual parenthesis. The notion should be
  extended to allow any syntax to rewrite to other syntax, possibly by reverting to using rewrite
  steps except in the most simple cases. Sugar should also be more intelligently reinserted when
  possible: in fact the only difference between sugar and schemes (as discussed in the next bullet)
  is that it gets inserted on output.

\item In \HAX2, we will extend the "scheme" declaration to allow
  \begin{displaymath}
    \kw{|scheme}~P~\kw{$→$}~M\,\kw;  \quad\text{for}\quad
    \kw{|scheme}~P'\,\kw; ~ P~\kw{$→$}~M\,\kw;
  \end{displaymath}
  where $P'$ is $P$ cleared of "#"s. (Alternatively, we can simply allow "#"s in productions.)

\end{enumerate}


\section{Behavior}\label{sec:behavior}

\HAX1 has a special built-in "Computed" pseudo-module, which has special ``behavior'' in that
"Computed" terms are \emph{evaluated} following hard-coded rules. In \HAX2, this should be
generalized to allow programmable rules.  I am as of yet unsure what the best notation for this
would be---alternatives include
%%
\begin{itemize}

\item Eliminate "Computed" and instead make numeric and atom types native to \HAX with the
  expression syntax native to (raw) \HAX.

\item 

\end{itemize}


\section{Compiling}\label{sec:compiling}

Generated \HAX1 rewrite systems are currently in untyped \CRSX3 form. It would be nice if the
generated rewrite systems were compilable with the \CRSX rules-compiler (initially using \CRSX3 but
eventually moving to \CRSX4/\hax). This would involve the following steps:
%%
\begin{itemize}

\item Extend the \emph{Cook.crs} script to generate full sort information in the generated \CRSX3
  script, so the \CRSX3 full compiler can be used (as it is used for the \HAX scripts).

\item Modify the \emph{Prep.crs} to generate parsers to use flex/bison directly. Initially just the
  user parser should be generated this way: the parser needs to reflect the semantics of the way the
  current pg→\emph{file}→crsx\_scan→\emph{term} (in memory) works.

\end{itemize}


\appendix\small

\section{Core \HAX}
\label{app:core}

``Core \HAX2'' is the part of \HAX2 that can be executed directly. It does not have attribution and
inference rules, and there is no support for user syntax (including sugar and precedence). It is
almost unchanged from \HAX1 (more specifically the ``raw'' subset of \HAX1).

The terminals are $q$ for qualified module names, $m$ for meta-variable names (written with leading
\#), $c$ for constructor names (capitalized and may include a $q$ qualification prefix; also when
used for sort names), and $v$ for variable names (starts with lower case, also used as attribute
names and sort variables).
%%
\begin{align*}
  \lefteqn{\textsc{Production}}\qquad &&& \textsc{Notes} \tag{\textsc{Name}}
  \\
  M \tag{Module}
  &::= \kw{module} ~ q ~ \kw\{ ~ U^* ~ \kw\}
  &&\ref{note:module}
  \\
  U \tag{Unit}
  &::= \kw{import} ~ q ~ \kw;
  ~\bigm|~ \kw{attribute} ~ AR ~ AF ~ \kw;
  &&\ref{note:u-import},\ref{note:u-a} \\[-1pt]
  &~~\bigm|~ \kw{main}^? ~ \kw{sort} ~ SF ~ \kw;
  ~\bigm|~ \kw{\texttt{|}}\, AR ~  \kw;
  ~\bigm|~ \kw{\texttt{|}}\, CF ~ \kw;
  ~\bigm|~ \kw{\texttt{|}}\, \kw{scheme} ~ CF ~ AR^* ~  \kw;
  ~\bigm|~ \kw{\texttt{|}}\, \kw{variable} ~ \kw;
  &&\ref{note:u-sort},\ref{note:u-ar},\ref{note:u-cf},\ref{note:u-scheme},\ref{note:u-var} \\[-1pt]
  &~~\bigm|~ \kw[~O^{*\kw,}~\kw] ~ T ~ \kwm{→} ~ T ~  \kw;
  &&\ref{note:u-rule}
  \\[1ex]
  SF \tag{SortForm}
  &::= v ~\bigm|~ c ~ SA^*
  &&\ref{note:sf}
  \\
  SA \tag{SortArgument}
  &::= v ~\bigm|~ c ~\bigm|~ \kw( ~ SF ~ \kw)
  &&\ref{note:sa}
  \\
  AR \tag{AttributeReference}
  &::= \kwm{↑} ~ v ~\bigm|~ \kwm{↓} ~ v
  &&\ref{note:ar}
  \\
  AF \tag{AttributeForm}
  &::= \kw( ~ SF ~ \kw) ~\bigm|~ \kw\{ ~ SF ~ \kw: ~ SF ~ \kw\}
  &&\ref{note:af}
  \\
  CF \tag{ConstructorForm}
  &::= c ~ \kw( ~ PF^{*\kw,} ~ \kw)
  &&\ref{note:cf}
  \\
  PF \tag{PieceForm}
  &::= \kw[ ~ SF^{*\kw,} ~ \kw] ~ SF
  &&\ref{note:pf}
  \\[1ex]
  T \tag{Term}
  &::= c ~ \kw( ~ P^{*\kw,} ~ \kw) ~ A^* ~\bigm|~ v ~ A^* ~\bigm|~ m ~ \kw[ ~ T^{*\kw,} ~ \kw] ~ A^*
  &&\ref{note:t-cons},\ref{note:t-var},\ref{note:t-meta}
  \\
  P \tag{Piece}
  &::= \kw[ ~ v^{*\kw,} ~ \kw] ~ T
  &&\ref{note:piece}
  \\
  A \tag{Attribute}
  &::= AR ~ \kw( ~ T ~ \kw)
  ~\bigm|~ AR ~ \kw\{ ~ T ~ \kw: ~ T ~ \kw\} ~\bigm|~ AR ~ \kw\{ ~ \kwm{¬} ~ T ~ \kw\} ~\bigm|~ AR ~ \kw\{ ~ m ~ \kw\}
  ~\bigm|~ \kwm{↕} ~ m
  &&\ref{note:a-value},\ref{note:a-map},\ref{note:a-not},\ref{note:a-catch},\ref{note:a-all}
  \\[1ex]
  O \tag{Option}
  &::= c ~\bigm|~ \kw{priority} ~\bigm|~ \kw{default}
  ~\bigm|~ \kw{free}\kw(~v~\kw{as}~SF~\kw) ~\bigm|~ \kw{fresh}\kw(~v~\kw{as}~SF~\kw)
  &&\ref{note:o-name},\ref{note:o-priority},\ref{note:o-ff}
\end{align*}
%%
Notes on the semantics of the core.
%%
\begin{enumerate}

\item\label{note:module} \kw{module} sets it up such that all unqualified names in all the $U^*$
  declarations are implicitly prefixed with the $q$ qualification.

\item\label{note:u-import} \kw{import} allows references to names that start with the imported prefix $q$ in
  the module.

\item\label{note:u-a} \kw{attribute} declares the allowed values of an attribute: the $AR$ specifies
  which attribute and the $AF$ specifies the allowed forms of the attribute. There must be exactly
  one attribute declaration for each used attribute reference.

\item\label{note:u-sort} \kw{sort} sets the \emph{current sort form}. If \kw{main} is included then
  the sort form must be primary (see point \ref{note:primary} below) and the sort is the default
  input sort.

\item\label{note:u-ar} A declaration $\kw{|}AR\kw;$ declares that the referenced attribute can be
  associated with data constructors of the current sort, which must be primary.

\item\label{note:u-cf} A declaration $\kw{|}CF\kw;$ declares that the current sort, which must be
  primary, owns the data constructor described by~$CF$.

\item\label{note:u-scheme} A declaration $\kw{|scheme}~CF\kw;$ declares that the constructor
  described by $CF$ is a function construction, which is permitted by all sorts that instantiate the
  current sort form. The added $AR$, restricted to inherited attributes, declares that all
  invocations of the function must be annotated with values for those attributes.

\item\label{note:u-var} A declaration \kw{|variable;} declares that all variables of the current
  sort, which must be primary, are \emph{syntactic}. This allows use of ``free'' and ``fresh''
  variables of the sort in rules but prevents substitution of non-variables for the sort; \TBD{see
    the explanation of variables below}.

\item\label{note:u-rule} A rule $T_1\kwm{→}T_2\kw;$ expresses that terms that match the $T_1$
  \emph{pattern} of the current sort may be replaced by $T_2$ after suitable substitutions of
  meta-variables and bound variables. The rule may be subject to some options; the precise rules for
  how rewrites are performed \TBD{are given in the rewriting section}.

\item\label{note:sf}\label{note:primary} A sort form $SF$ is either a polymorphic sort variable or a
  parametric named sort. If $SF$ has the form $c~v^*$ with distinct $v_i$, we say that it is a
  \emph{primary sort form}. A sort $c$ must always have the same number of sort parameters. A sort
  form with no variables is called a \emph{ground} sort. We say that a ground sort
  \emph{instantiates} a sort form if usual substitution in the form can be used to generate it.

\item\label{note:sa} A sort argument $SA$ is either a sort variable or a proper sort; if a sort
  argument has arguments of its own it must be parenthesized.

\item\label{note:ar} An attribute reference $AR$ identifies an attribute: \kwm{↓} for inherited,
  \kwm{↑} for synthesized, in each case followed by the name.

\item\label{note:af} An attribute form $AF$ declares what shape an attribute must take. It may
  either be a \emph{simple} attribute of sort $S$, written $\kw(S\kw)$, or an \emph{environment}
  from variables of a sort $S_1$ to values of another sort $S_2$, written $\kw\{S_1\kw:S_2\kw\}$.

\item\label{note:cf} A construction form $CF$ declares the arity and shape of the parameter pieces of a
  construction (either data or function).

\item\label{note:pf} A piece form $PF$ gives the shape of one parameter piece to a constructor: that
  parameter must always bind distinct local variables of the sorts in the brackets (in order), and
  must contain a term of the sort after the bracket.

\item\label{note:t-cons} A term $T$ can be a \emph{construction} $c\kw(\ov{P}\kw)$ optionally
  followed by some attribute values~$\ov{A}$. The pieces $P_i$ must correspond in order to the
  declared piece forms for the constructor, and the attributes must be allowed for the sort for data
  constructors, or allowed for the function construction.

\item\label{note:t-var} A term $T$ can be a \emph{variable occurrence} $v$, optionally followed by
  some attribute values~$\ov{A}$. $v$ must have a sort from the context, and if attribute values are
  given they must be permitted for that sort.

\item\label{note:t-meta} Finally, a term $T$ can be a \emph{meta-application} $m\kw[\ov{T}\kw]$
  optionally followed by some attribute values~$\ov{A}$. A meta-application must be used
  consistently inside a rewrite rule according to specific constraints.

\item\label{note:piece} A piece $P$ has a list of \emph{binders} $\kw[\ov{v}\kw]$ followed by a term $T$, which is the
  scope for the bound variables. The variables will be assigned sorts according to the $PF$ that the
  piece must correspond to, and with this assigment, $T$ must have the term sort of the~$PF$.

\item\label{note:a-value} An attribute $A$ can be a \emph{simple attribute value} written as the reference to the
  attribute followed by the value in parenthesis. The attribute reference must be declared to take
  such a value and the sort must match. There can be at most one simple attribute value for a given
  attribute reference in a list of attributes.

\item\label{note:a-map} An \emph{environment attribute mapping} $AR\,\kw\{T_1\kw:T_2\}$ is permitted
  if the $AR$ is declared as an environment and the two subterms have the appropriate types. In
  addition, there are some constraints on what $T_1$ can be, which are described along with rule
  matching. Essentially the mapping expresses the constraint that the actual environment associated
  with the $AR$ contains a mapping where the variable matches $T_1$ and the value matches~$T_2$

\item\label{note:a-not} An \emph{environment attribute exclusion} $AR\,\kw\{¬T_1\}$ is permitted if
  the $AR$ is declared as an environment with $T$ of the key sort. In addition, there are some
  constraints on what $T_1$ can be, which are described along with rule matching. Essentially the
  mapping expresses the constraint that the actual environment associated with the $AR$ does not
  contain a mapping where the variable matches~$T_1$.

\item\label{note:a-catch} An \emph{environment attribute catcher} $AR\kw\{m\kw\}$ is permitted if
  the $AR$ is declared as an environment. The precise semantics is described along with rule
  matching, essentially the catcher expresses the constraint that $m$ contains mappings that must be
  associated with as many mappings in the~$AR$ as possible. An $m$ used in this way in a rule should
  only be used in this way.

\item\label{note:a-all} Finally, the \emph{attribute catch-all} $\kwm{↕}m$ expresses that the meta-variable $m$ should
  capture as many of the attributes associated with the current term as possible.

\item\label{note:o-name} Specifying a $c$ as an option names the rule~$c$. All names must be unique.

\item\label{note:o-priority} The \kw{priority} and \kw{default} options make \HAX try the rule before
  and after other rules, respectively.

\item\label{note:o-ff} The $\kw{free}\kw(v~\kw{as}~SF\kw)$ and $\kw{fresh}\kw(v~\kw{as}~SF\kw)$ allow
  for using syntactic variables in rules (consistent with sorts with the \kw{variable} declaration);
  for details \TBD{see varables}.

\end{enumerate}
%%
Notes on translating to \hax.
%%
\begin{enumerate}

\item \TBD{?}

\end{enumerate}

\section{Attribute Normalization}
\label{app:attributes}

In this appendix we give the formal rules for translating the new attribution rules from
Section~\ref{sec:attributes} to core \HAX2 rules.

\begin{example}
  As an example, consider the \HAX2 attribution rule
  \begin{equation}
    \kw{sort}~S\kw; \quad
    [R] ~~ {↓}i ~ d(\, {↓}i_1 \#_1 {↑}s_1 \,,\, {↓}i_2 \#_2 {↑}s_2 \,) ~ {↑}s
  \end{equation}
  with $R$ the rule name, $d$ a data constructor of sort $S$, and each of $i,i_1,i_2,s,s_1,s_2$ a
  \HAX2 ``attribution.''  Such a rule is translated into the following core \HAX rule system:
  %% 
  \begin{align}
    \op{Prop}_i \bigl( d( \#_1, \#_2 ) ~ {↕}\#d \bigr) ~ {↓}i ~
    & → \op{Susp}_{R,1} \bigl( d( \op{Need}_{s_1} ( \op{Prop}_{i_1}(\#_1) ~ {↓}i_1), \#_2 ) ~ {↕}\#d ~ {↓}i \bigr)
    \\
    \op{Susp}_{R,1} \bigl( d( \#_1 \, {↓}i_1 \, {↑}s_1, \#_2 ) ~ {↕}\#d ~ {↓}i \bigr) ~
    & → \op{Susp}_{R,2} \bigl( d( \#_1, \op{Need}_{s_2} ( \op{Prop}_{i_2}(\#_2) \, {↓}i_2) ) ~ {↕}\#d \bigr)
    \\
    \op{Susp}_{R,2} \bigl( d( \#_1 \, {↓}i_1 \, {↑}s_1, \#_2 \, {↓}i_2 \, {↑}s_2 ) ~ {↕}\#d ~ {↓}i \bigr) ~
    & → d( \#_1, \#_2 ) ~ {↕}\#d ~ {↑}s
  \end{align}
  %%
\end{example}

\begin{definition}\label{def:general-attribution}
  A \HAX2 attribution rule has the form
  %% 
  \begin{equation}
    \kw{sort}~S\kw; \quad
    [R] ~~ \ov{{↓}i_0} ~ d\bigl(\,
      [\ov{v_1}] \, \ov{{↓}i_1} \, M_1 \, \ov{{↑}s_1} \,,…,\,
      [\ov{v_n}] \, \ov{{↓}i_n} \, M_n \, \ov{{↑}s_n}
    \,\bigr) ~ \ov{{↑}s_0}
  \end{equation}
  %% 
  with $R$ the rule name, $d$ a data constructor of sort $S$, each of the $M_j$ a meta-term with
  associated binders $\ov{v_j}$, and each of $i_j,s_j$ a \HAX2 ``attribution.''
\end{definition}

\begin{definition}\label{def:L-attributed}
  A \HAX2 attribution as defined in Definition~\ref{def:general-attribution} is \emph{locally
    L-attributed} if
  \begin{align}
    ∀j, 1≤j≤\$\colon
    \op{mv}\bigl( ~ \ov{{↓}i_0} ~ \ov{{↓}i_1}…\ov{{↓}i_{j-1}} ~ \ov{{↑}s_1}…\ov{{↑}s_{j-1}} ~ \bigr)
    &⊇ \op{mv}\bigl( \ov{{↓}i_j} \bigr)
    \\
    ∀j, 1≤j≤\$\colon
    \op{mv}\bigl( ~ \ov{{↓}i_0} ~ \ov{{↓}i_1}…\ov{{↓}i_j} ~ \ov{{↑}s_1}…\ov{{↑}s_{j-1}} ~ \bigr)
    &⊇ \op{mv}\bigl( \ov{{↑}s_j} \bigr)
    \\
    \op{mv}\bigl( ~ \ov{{↓}i_0} ~ \ov{\ov{{↓}i}} ~ \ov{\ov{{↑}s}} ~ \bigr)
    &⊇ \op{mv}\bigl( \ov{{↑}s_0} \bigr)
  \end{align}
\end{definition}

\begin{lemma}
  Every L-attributed attribute grammar can be expressed as a collection of locally L-attributed
  \HAX2 attributions.
\end{lemma}

\begin{formalization}
  %%
  Given a \HAX2 attribution as defined in Definition~\ref{def:general-attribution}. The following
  core \HAX rule system is the \emph{attribute simplification} of the attribution:
  %% 
  \begin{align}
    %%
    \lefteqn{ \kw{sort}~S ~; }\qquad
    \\[\jot]
    %%
    \lefteqn{\kw{|} ~ \kw{scheme} ~ \op{Prop}_{\ov{i_0}}(S) ~ \ov{{↓}i_0} ~; }\qquad
    \\
    \lefteqn{ \op{Prop}_{\ov{i_0}} \bigl( d( [\ov{v_1}]M_1{↕}\#_1,…, [\ov{v_n}]M_n{↕}\#_n ) ~ {↕}\#d \bigr) ~ \ov{{↓}i_0 } }\qquad\\*[-1pt]
    &→ \op{Susp}_{R,1} \bigl( d( [\ov{v_1}] \op{Need}_{s_{1,1}}(\cdots(\op{Need}_{s_{1,\$}} ( \op{Prop}_{\ov{i_1}}(M_1{↕}\#_1) ~ \ov{{↓}i_1}))\cdots), [\ov{v_2}] M_2{↕}\#_2, …, [\ov{v_n}] M_n{↕}\#_n ) ~ {↕}\#d ~ \ov{{↓}i_0} \bigr) ~;
    \notag
    \\[\jot]
    %%
    \lefteqn{ \kw{|} ~ \kw{scheme} ~ \op{Susp}_{R,1}(S); }\qquad
    \\
    \lefteqn{ \op{Susp}_{R,1} \bigl( d( [\ov{v_1}]M_1 \,{↕}\#_1 \ov{{↓}i_1} \, \ov{{↑}s_1}, [\ov{v_2}]M_2{↕}\#_2, …, [\ov{v_n}]M_n{↕}\#_n ) ~ {↕}\#d ~ \ov{{↓}i_0} ~\bigr) }\qquad\\*[-1pt]
    & → \op{Susp}_{R,2} \bigl( d( [\ov{v_1}]M_1{↕}\#_1, [\ov{v_2}]\op{Need}_{s_{2,1}}(\cdots( \op{Need}_{s_{2,\$}} ( \op{Prop}_{i_2}(M_2{↕}\#_2) \, {↓}i_2))\cdots), [\ov{v_3}]M_3{↕}\#_3, …, [\ov{v_n}]M_n{↕}\#_n ) ~ {↕}\#d \bigr) ~;
    \notag
    \\[-\jot]
    \vdots\!\qquad\notag
    \\
    %%
    \lefteqn{ \kw{|} ~ \kw{scheme} ~ \op{Susp}_{R,n-1}(S); }\qquad
    \\
    \lefteqn{ \op{Susp}_{R,n-1} \bigl( d( [\ov{v_1}]M_1 \,{↕}\#_1 \ov{{↓}i_1} \, \ov{{↑}s_1}, … , [\ov{v_{n-1}}]M_{n-1}{↕}\#_{n-1} \ov{{↓}i_{n-1}} \, \ov{{↑}s_{n-1}}, [\ov{v_n}]M_n{↕}\#_n ) ~ {↕}\#d ~ \ov{{↓}i_0} ~\bigr) }\qquad\\*[-1pt]
    & → \op{Susp}_{R,n} \bigl( d( [\ov{v_1}]M_1{↕}\#_1, …, [\ov{v_{n-1}}]M_{n-1}{↕}\#_{n-1}, [\ov{v_n}]\op{Need}_{s_{n,1}}(\cdots( \op{Need}_{s_{n,\$}} ( \op{Prop}_{i_n}(M_n{↕}\#_n) \, {↓}i_n))\cdots) ) ~ {↕}\#d \bigr) ~;
    \notag
    \\[\jot]
    %%
    \lefteqn{ \kw{|} ~ \kw{scheme} ~ \op{Susp}_{R,n}(S); }\qquad
    \\
    \lefteqn{ \op{Susp}_{R,n} \bigl( d( [\ov{v_1}]M_1 \,{↕}\#_1 \ov{{↓}i_1} \, \ov{{↑}s_1}, … , [\ov{v_n}]M_n{↕}\#_n \ov{{↓}i_n} \, \ov{{↑}s_n} ) ~ {↕}\#d ~ \ov{{↓}i_0} ~\bigr) }\qquad\\*[-1pt]
    & → d( M_1\,{↕}\#_1,…, M_n\,{↕}\#_n ) ~ {↕}\#d ~ \ov{{↑}s_0} ~;
    \notag
  \end{align}
  %%
\end{formalization}

\begin{itemize}

\item We have been slightly sloppy with the notations: The attributes in the \kw{scheme} declaration
  for and constructor name for $\op{Prop}_{\ov{i_0}}$ should not include the attribute values, just
  the names.

\item Notice how the rule patterns progressively capture more and more of the available attributes,
  following the rules for local L-attributed specifications.

\end{itemize}
%%




\section{Inference System Normalization}
\label{app:infer}

Recall~\thetag{\ref{eq:when-infer}} from Section~\ref{sec:infer}:
%%
\begin{equation}
  \kw{sort}~S; \quad [R]~\kw{when}~[\ov{x~\kw{as}~S'}](\, C_1⇒P_1 ~\cdots~ C_n⇒P_n \,) ~ \kw{infer} ~ P_0 ⇒ C_{n+1}
  \tag{\ref{eq:when-infer}}
\end{equation}
%% 
\begin{formalization}
  %%
  Assume rule \thetag{\ref{eq:when-infer}}, where furthermore the $C_i,P_i$ pairs have sort $S_i$.
  The \emph{inference simplification system} for the rule is
  %% 
  \begin{align}
    &\kw{sort}~S~;
    & P_0 &→ R_1(P_0, [\ov{x}]C_1) \tag{$R_0$} ~;
    \\
    &\kw{|scheme} ~ R_1(S, [\ov{S'}]S_1) ~;
    & R_1(P_0, [\ov{x}]P_1) &→ R_2(P_0, [\ov{x}]P_1, [\ov{x}]C_2) \tag{$R_1$} ~;
    \\[-\jot]
    &~~\vdots\notag\\
    &\kw{|scheme} ~ R_{n-1}(S, [\ov{S'}]S_1,…, [\ov{S'}]S_{n-1}) ~;
    & R_{n-1}(P_0, [\ov{x}]P_1, …, [\ov{x}]P_{n-1}) &→ R_n(P_0, [\ov{x}]P_1, …, [\ov{x}]P_{n-1}, [\ov{x}]C_n) \tag{$R_{n-1}$} ~;
    \\
    &\kw{|scheme} ~ R_n(S, [\ov{S'}]S_1,…, [\ov{S'}]S_n) ~;
    & R_n(P_0, [\ov{x}]P_1, …, [\ov{x}]P_n) &→ C_{n+1} \tag{$R_n$} ~;
  \end{align}
  %% 
  (where all symbols, including the variables $\ov{x}$, are the same as in the initial rule). All
  these rules need to be part of the "sort" declaration for the sort of $P_0$ and $C_{n+1}$, along
  with "scheme" declarations for all the introduced $R_i$ symbols.
\end{formalization}



\section{Necessary Optimizations}
\label{app:optim}

With the attribute and inference rule simplifications above, multiple conflicting rules may be
generated. Therefore we'll need a \emph{left factoring} phase. The principle is simple: if there are
two rules that have the same pattern and only differ in a function names:
%%
\begin{align*}
  P &→ …f_1(…)… \\
  P &→ …f_2(…)…
\end{align*}
%%
then the two functions $f_1$ and $f_2$ must be \emph{merged}, for example by removing the second
rule and then replace all occurrences of $f_2$ with $f_1$. This will (recursively) create some new
situations, and so on.


\bibliography{crs}

\end{document}


%%---------------------------------------------------------------------
% Tell Emacs that this is a LaTeX document and how it is formatted:
% Local Variables:
% mode:latex
% fill-column:100
% TeX-master: t
% End:
